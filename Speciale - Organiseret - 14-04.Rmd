---
title: "Green Party Parliamentary Representation and Climate Policy"
author: "Tobias"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# 1. Setup and Data Preparation

## 1.1 Package Installation and Loading

```{r package_installation}
# Install pacman if not already installed
if (!require("pacman")) install.packages("pacman")

# Use pacman to load all required packages
pacman::p_load(
  # Data manipulation
  dplyr, tidyr, magrittr, purrr, data.table, readr, lubridate, quantreg, MASS,
  
  # Visualization
  ggplot2, patchwork, scales, RColorBrewer, gridExtra, ggridges, corrplot, ggh4x,
  
  # Statistical analysis
  rdd, rddtools, rddensity, rdrobust, rdlocrand, AER, ivreg,
  lmtest, sandwich, stargazer, broom, memisc, strucchange, plm,
  
  # Missing data analysis
  naniar,
  
  # Specific data sources
  manifestoR
)

# Load custom RDD functions if available
if (file.exists("gp_rdd_funktioner.R")) {
  source("gp_rdd_funktioner.R")
}

if (file.exists("coefficient_stability_plots.R")) {
  source("coefficient_stability_plots.R")
}

if (file.exists("placebo_tests.R")) {
  source("placebo_tests.R")
} 
```

## 1.2 Helper Functions

```{r helper_functions}
# Function to filter European countries
filter_european_countries <- function(data, country_col = "country_name") {
  european_countries <- c(
    "Austria", "Bulgaria", "Croatia", "Czech Republic", "Denmark", 
    "Estonia", "Finland", "Germany", "Greece", "Ireland", "Italy", 
    "Latvia", "Luxembourg", "Netherlands", "Norway", "Poland", 
    "Portugal", "Romania", "Slovakia", "Slovenia", "Spain", 
    "Sweden", "Switzerland"
  )
  
  filter(data, !!sym(country_col) %in% european_countries)
}

# Funktion til at udføre robusthedstest med forskellige båndbredder
run_rdd_robustness <- function(data, 
                              outcome_var = "miljø_afhængig",
                              running_var = "centered_lagged_pervote_samlet", 
                              bw_list = c(1, 1.5, 2, 2.5, 3),
                              polynomials = c(1, 2, 3, 4),
                              cutpoint = 0,
                              covariates = NULL,
                              group_label = "") {
  
  # Tom liste til resultater
  all_results <- list()
  
  # Håndtering af kovariater
  if (!is.null(covariates)) {
    # Opret kovariat-matrix på forhånd
    covs_matrix <- NULL
    if (length(covariates) > 0) {
      # Forsøg at bygge kovariat-matrix manuelt
      covs_list <- list()
      for (i in 1:length(covariates)) {
        col_name <- covariates[i]
        if (col_name %in% names(data)) {
          covs_list[[i]] <- data[[col_name]]
        } else {
          warning(paste("Kolonne", col_name, "findes ikke i datasættet."))
          covs_list[[i]] <- NULL
        }
      }
      # Fjern NULL værdier
      covs_list <- covs_list[!sapply(covs_list, is.null)]
      
      # Hvis der er nogen kovariater tilbage, lav en matrix
      if (length(covs_list) > 0) {
        covs_matrix <- do.call(cbind, covs_list)
      }
    }
  } else {
    covs_matrix <- NULL
  }
  
  # Loop over polynomier
  for (p in polynomials) {
    
    # HVIS p <= 2, laver vi 'ikke-parametrisk' med faste båndbredder
    if (p <= 2) {
      
      # Loop over båndbredder
      for (bw in bw_list) {
        # Prøv at køre rdrobust med fejlhåndtering
        tryCatch({
          # Kør rdrobust uden kovariater
          if (is.null(covs_matrix)) {
            rd <- rdrobust(
              y = data[[outcome_var]],
              x = data[[running_var]],
              c = cutpoint,
              p = p,
              h = bw
            )
          } else {
            # Kør rdrobust med kovariater
            rd <- rdrobust(
              y = data[[outcome_var]],
              x = data[[running_var]],
              c = cutpoint,
              p = p,
              h = bw,
              covs = covs_matrix
            )
          }
          
          # Gem KUN conventional-estimatet: [1]
          tmp <- data.frame(
            Bandwidth    = bw,
            Polynomial   = p,
            LATE         = formatC(rd$Estimate[1], format = "f", digits = 4),
            StdErr       = formatC(rd$se[1], format = "f", digits = 4),
            p_value      = formatC(rd$pv[1], format = "f", digits = 4),
            N_left_of_c  = rd$N_h[1],
            N_right_of_c = rd$N_h[2]
          )
          
          # Tilføj en kolonne med p-værdi-stjerner
          tmp$p_value_star <- paste0(
            tmp$p_value,
            ifelse(as.numeric(tmp$p_value) < 0.01, "***",
                   ifelse(as.numeric(tmp$p_value) < 0.05, "**",
                          ifelse(as.numeric(tmp$p_value) < 0.1, "*", "")))
          )
          
          # Læg i listen over resultater
          all_results[[paste0("p", p, "_bw", bw)]] <- tmp
          
        }, error = function(e) {
          warning(paste("Fejl ved kørsel af rdrobust med p =", p, "og bw =", bw, ":", e$message))
        })
      }
      
    } else {
      # HVIS p > 2, laver vi "global" og sætter h = NULL (eller en meget stor værdi)
      tryCatch({
        # Kør rdrobust uden kovariater
        if (is.null(covs_matrix)) {
          rd <- rdrobust(
            y = data[[outcome_var]],
            x = data[[running_var]],
            c = cutpoint,
            p = p,
            h = NULL   # lader rdrobust selv vælge båndbredde
          )
        } else {
          # Kør rdrobust med kovariater
          rd <- rdrobust(
            y = data[[outcome_var]],
            x = data[[running_var]],
            c = cutpoint,
            p = p,
            h = NULL,   # lader rdrobust selv vælge båndbredde
            covs = covs_matrix
          )
        }
        
        # Gem KUN conventional-estimatet: [1]
        tmp <- data.frame(
          Bandwidth    = NA,  # "Global" => ingen fastsat h
          Polynomial   = p,
          LATE         = formatC(rd$Estimate[1], format = "f", digits = 4),
          StdErr       = formatC(rd$se[1], format = "f", digits = 4),
          p_value      = formatC(rd$pv[1], format = "f", digits = 4),
          N_left_of_c  = rd$N_h[1],
          N_right_of_c = rd$N_h[2]
        )
        
        # Tilføj en kolonne med p-værdi-stjerner
        tmp$p_value_star <- paste0(
          tmp$p_value,
          ifelse(as.numeric(tmp$p_value) < 0.01, "***",
                 ifelse(as.numeric(tmp$p_value) < 0.05, "**",
                        ifelse(as.numeric(tmp$p_value) < 0.1, "*", "")))
        )
        
        # Læg i listen
        all_results[[paste0("p", p, "_global")]] <- tmp
        
      }, error = function(e) {
        warning(paste("Fejl ved kørsel af rdrobust med p =", p, "og global båndbredde:", e$message))
      })
    }
  }
  
  # Bind alle resultaterne sammen, men tjek at vi har nogle resultater
  if (length(all_results) > 0) {
    results_df <- do.call(rbind, all_results)
    
    # Tilføj en kolonne med gruppelabel, hvis angivet
    if (group_label != "") {
      results_df$Group <- group_label
    }
    
    return(results_df)
  } else {
    warning("Ingen resultater produceret. Tjek data og parametre.")
    return(NULL)
  }
}



# Function to calculate Lowe's RILE score
calculate_rile_lowe <- function(data) {
  right_cols <- c("per104", "per201", "per203", "per305", "per401", "per402", "per407", 
                 "per414", "per505", "per601", "per603", "per605", "per606")
  left_cols <- c("per103", "per105", "per106", "per107", "per202", "per403", "per404", 
                "per406", "per412", "per413", "per504", "per506", "per701")
  
  # Debug: Identify missing columns
  missing_right <- right_cols[!right_cols %in% names(data)]
  missing_left <- left_cols[!left_cols %in% names(data)]
  print(paste("Missing right columns:", paste(missing_right, collapse=", ")))
  print(paste("Missing left columns:", paste(missing_left, collapse=", ")))
  
  # Filter to only include columns that exist in the dataset
  right_cols_exist <- right_cols[right_cols %in% names(data)]
  left_cols_exist <- left_cols[left_cols %in% names(data)]
  
  # Calculate RILE score
  data %>%
    mutate(rile_lowe = log((rowSums(dplyr::select(., dplyr::all_of(right_cols_exist)) + 0.5)) / 
                          (rowSums(dplyr::select(., dplyr::all_of(left_cols_exist)) + 0.5))))
}

# Function to calculate environmental position
calculate_env_position <- function(data) {
  data %>%
    mutate(
      miljø_afhængig = log((per416 + per501 + 0.5) / (per410 + 0.5))
    )
}

# Function to remove duplicates based on specific columns
remove_duplicates <- function(data, group_cols, value_col) {
  data %>%
    dplyr::group_by(dplyr::across(dplyr::all_of(group_cols))) %>%
    dplyr::mutate(max_value = max({{value_col}}, na.rm = TRUE)) %>%
    dplyr::filter({{value_col}} == max_value) %>%
    dplyr::distinct(dplyr::across(dplyr::all_of(group_cols)), .keep_all = TRUE) %>%
    dplyr::ungroup() %>%
    dplyr::select(-"max_value")  # Change to this or the alternate option below
}

# Function to create standard RDD plot
plot_rdd <- function(data, x_var, y_var, group_var, 
                    x_limit = 10, 
                    x_label = "Running Variable", 
                    y_label = "Outcome", 
                    title = "RDD Plot") {
  # Ensure x_var, y_var, and group_var are treated as strings (column names)
  ggplot(data = subset(data, data[[x_var]] <= x_limit)) +
    geom_point(aes(x = .data[[x_var]], y = .data[[y_var]], shape = .data[[group_var]]), size = 2) +
    geom_smooth(data = subset(data, data[[x_var]] < 0),
                aes(x = .data[[x_var]], y = .data[[y_var]]),
                method = 'lm', formula = y ~ poly(x, 3, raw = TRUE), 
                linetype = 1, color = 'black', size = 1) +
    geom_smooth(data = subset(data, data[[x_var]] >= 0),
                aes(x = .data[[x_var]], y = .data[[y_var]]),
                method = 'lm', formula = y ~ poly(x, 3, raw = TRUE), 
                linetype = 1, color = 'black', size = 1) +
    scale_shape_manual(values = c(1, 16)) +  # 1 = tom cirkel, 16 = fyldt cirkel
    geom_vline(xintercept = 0, linetype = 2, size = .6) +
    xlim(-5, x_limit) +  # Sætter x-aksens grænser
    theme_minimal() +
    labs(title = title, x = x_label, y = y_label) +
    theme(legend.position = 'bottom', legend.title = element_blank())
}

# Run RDD analysis with multiple specifications
run_rdrobust_analysis <- function(data, p, bw = NULL, interaction_var = NULL) {
  # Base covariates
  base_covs <- cbind(
    as.numeric(factor(data$country)),
    as.numeric(factor(data$edate))
  )
  
  # Add interaction term if provided
  if(!is.null(interaction_var)) {
    covs <- cbind(
      base_covs,
      data[[interaction_var]],
      data[[interaction_var]] * data$lagged_i_parlament
    )
  } else {
    covs <- base_covs
  }
  
  # Run RD analysis
  rd <- rdrobust(
    y = data$miljø_afhængig,
    x = data$centered_lagged_pervote_samlet,
    c = 0,
    p = p,
    h = bw,
    covs = covs
  )
  
  return(rd)
}

# Function for zoomed-in RDD plots
jump_plot_cutoff <- function(data, force_var, y_var, group_var, polynomial=1, window=2) {
  # Select data within window
  plot_data <- subset(data, abs(data[[force_var]]) <= window)
  
  # Create plot
  p <- ggplot() +
    geom_point(data = plot_data,
              aes_string(x = force_var, y = y_var, shape = group_var),
              size = 2) +
    geom_smooth(data = subset(plot_data, plot_data[[force_var]] < 0),
                aes_string(x = force_var, y = y_var),
                method = 'lm',
                formula = y ~ poly(x, polynomial, raw = TRUE),
                linetype = 1,
                color = 'black',
                size = 1) +
    geom_smooth(data = subset(plot_data, plot_data[[force_var]] >= 0),
                aes_string(x = force_var, y = y_var),
                method = 'lm',
                formula = y ~ poly(x, polynomial, raw = TRUE),
                linetype = 1,
                color = 'black',
                size = 1) +
    scale_x_continuous(name = 'Green Party Vote Share (centered)',
                     limits = c(-window, window),
                     breaks = seq(-window, window, window/2)) +
    geom_vline(xintercept = 0, linetype = 2, size = 0.6) +
    theme_minimal() +
    theme(legend.position = 'bottom', legend.title = element_blank()) +
    labs(title = paste0("RDD Plot (Window = ±", window, ")"),
         y = "Climate Position")
  
  return(p)
}
```

## 1.3 Data Acquisition

```{r data_acquisition, warning=FALSE}
# Load Manifesto Project Dataset
mp_setapikey(key = "c1f14c8fb84af448bfdb511afd7f415e")
mpds <- mp_maindataset(version = "MPDS2024a")

# Load election and party data
view_election <- read_csv("view_election.csv")
view_party <- read_csv("view_party.csv")

# GDP Per Capita
gdp_per_capita <- read_delim("gdp_per_capita.csv", 
     delim = ";", escape_double = FALSE, col_types = cols(GDP_per_capita = col_number()), 
     locale = locale(decimal_mark = ",", grouping_mark = "."), 
     trim_ws = TRUE)
#View(gdp_per_capita)

gdp_per_capita_growth <- read_delim("gdp_per_capita_growth.csv", 
    delim = ";", escape_double = FALSE, col_types = cols(`GDP per capita growth` = col_number()), 
    locale = locale(decimal_mark = ",", grouping_mark = "."), 
    trim_ws = TRUE)

inflation_consumer_prices <- read_delim("inflation-consumer_prices.csv", 
    delim = ";", escape_double = FALSE, col_types = cols(`Inflation-consumer prices` = col_number()), 
    locale = locale(decimal_mark = ",", grouping_mark = "."), 
    trim_ws = TRUE)

unemployment <- read_delim("unemployment.csv", 
    delim = ";", escape_double = FALSE, col_types = cols(Unemployment = col_number()), 
    locale = locale(decimal_mark = ",", grouping_mark = "."), 
    trim_ws = TRUE)

# Filter for European countries
election_european <- filter_european_countries(view_election)
party_european <- filter_european_countries(view_party)
mpds_european <- filter_european_countries(mpds, "countryname")

# Subsetting to post-1960 data
mpds_european_1960 <- filter(mpds_european, date > 196000)
pg_election_all <- filter(election_european, election_date > "1960-01-01")
pg_parties_all <- party_european  # No date filtering needed
```

## 1.4 Data Integration and Preprocessing

```{r data_processing}
# Merge party and election data
pg_election_parties_europa <- merge(
  pg_election_all, 
  pg_parties_all[, c("party_id", "cmp", "family_id", "family_name", "family_name_short")], 
  by = "party_id", 
  all.x = FALSE, 
  all.y = FALSE
)

# Filter to ecology/green parties (family_id = 19) in parliamentary elections
pg_election_parties_europa_eco <- filter(
  pg_election_parties_europa, 
  family_id == 19 & election_type == "parliament"
)

# Filter to ecological parties in Manifesto data
mpds_european_1960_eco <- filter(mpds_european_1960, parfam == "10")

# Create a correction lookup table for Green parties
party_corrections <- tribble(
  ~party_id, ~country_name, ~cmp,
  308,  "Switzerland",    43120,
  1781, "Portugal",       35120,
  2254, "Norway",         12110,
  2651, "Austria",        42120,
  196,  "Czech Republic", 82110,
  219,  "Estonia",        83110
)

# Apply corrections to green party data
pg_election_parties_europa_eco <- pg_election_parties_europa_eco %>%
  rows_update(party_corrections, by = c("party_id", "country_name"))

# Merge manifesto data with party-election data for green parties
mpds_pg_1960_eco <- merge(
  mpds_european_1960_eco,
  pg_election_parties_europa_eco,
  by.x = c("countryname", "edate", "party"),
  by.y = c("country_name", "election_date", "cmp"),
  all = TRUE
)
```

## 1.5 Electoral Thresholds and Party Size

```{r thresholds_and_party_size}
# Import electoral threshold data
samlede_thresholds <- read_delim("Samlede Thresholds.csv", 
    delim = ";", 
    escape_double = FALSE, 
    locale = locale(decimal_mark = ",", grouping_mark = "."), 
    trim_ws = TRUE) %>%
  mutate(edate = dmy(edate))  # Convert to date format
#View(samlede_thresholds)
print(names(samlede_thresholds))

# Select relevant threshold columns
samlede_thresholds_sub <- samlede_thresholds %>%
  dplyr::select(country, edate, threshold, threshold_lagged)

# Merge thresholds with main manifesto dataset
mpds_european_1960 <- merge(
  mpds_european_1960,
  samlede_thresholds_sub,
  by = c("country", "edate"),
  all.x = FALSE
)

# Calculate average vote share and filter to mainstream parties (>=10% avg)
mpds_european_1960 <- mpds_european_1960 %>% 
  group_by(party) %>% 
  mutate(avg_pervote_main = mean(pervote, na.rm = TRUE)) %>% 
  ungroup() %>%
  filter(avg_pervote_main >= 10)
```

## 1.6 Green Party Parliament Presence and Vote Share

```{r green_party_data}
# Import green party vote share and parliament data
green_party_data <- read_delim(
  "mpds_pg_1960_eco_færdig_tilføjelse_af_ekstra_votes.csv", 
  delim = ";", 
  escape_double = FALSE, 
  col_types = cols(avg_vote_share = col_double()), 
  locale = locale(decimal_mark = ",", grouping_mark = "."), 
  trim_ws = TRUE
) %>%
  mutate(
    edate = as.Date(edate, format = "%d-%m-%Y"),
    edate = format(edate, "%Y/%m/%d")
  )


# Select relevant green party columns
green_party_data_sub <- green_party_data[
  , c("countryname", "edate", "pervote_samlet", "lagged_pervote_samlet", "i_parlament", "lagged_i_parlament")
]

# Merge with mainstream party data
full_dataset <- merge(
  mpds_european_1960,
  green_party_data_sub,
  by = c("countryname", "edate"),
  all.x = FALSE
)

# Fjern rader hvor parfam = 10
full_dataset <- full_dataset %>%
  filter(parfam != "10")

#View(full_dataset)

# Calculate Lowe's RILE score
full_dataset <- calculate_rile_lowe(full_dataset)

# Select final columns and remove duplicates
final_dataset <- full_dataset %>%
  dplyr::select(
    countryname, edate, country, party, oecdmember, eumember, date, 
    partyname, partyabbrev, parfam, absseat, per410, per416, per501, 
    threshold, threshold_lagged, pervote_samlet, lagged_pervote_samlet, 
    i_parlament, lagged_i_parlament, avg_pervote_main, rile, rile_lowe
  ) %>%
  remove_duplicates(
    c("countryname", "edate", "party"),
    pervote_samlet
  )
```

## 1.7 Final Variable Creation og Radical Right Parti Presence

```{r create_final_variables}
# Create all derived variables needed for analysis
final_dataset <- final_dataset %>%
  mutate(
    # Convert to numeric
    pervote_samlet = as.numeric(pervote_samlet),
    lagged_pervote_samlet = as.numeric(lagged_pervote_samlet),
    
    # Create centered variables (running variables for RDD)
    centered_pervote_samlet = pervote_samlet - threshold,
    centered_lagged_pervote_samlet = lagged_pervote_samlet - threshold_lagged,
    
    # Create dependent variable: environmental position
    miljø_afhængig = log((per416 + per501 + 0.5) / (per410 + 0.5)),
    
    miljø_afhængig_alt = log(per416 + per501 + 0.5) - log(per410 + 0.5),
    
    # Create factor variables for parliament presence
    factor_lagged_i_parlament = factor(
      lagged_i_parlament, 
      levels = c(0, 1), 
      labels = c("Green parties w/o seats", "Green parties w seat(s)")
    ),
    factor_i_parlament = factor(
      i_parlament, 
      levels = c(0, 1), 
      labels = c("Green parties w/o seats", "Green parties w seat(s)")
    ),
    
    # Create variables for party size (for H5)
    large_party = ifelse(avg_pervote_main > median(avg_pervote_main, na.rm = TRUE), 1, 0),
    
    # Create variables for left-right orientation (for H4)
    left_party = ifelse(rile_lowe < 0, 1, 0)
  )

# Sortér data efter parti og dato
final_dataset <- final_dataset %>% dplyr::arrange(party, edate)

# Beregn first difference inden for hvert parti
final_dataset <- final_dataset %>% 
  dplyr::group_by(party) %>% 
  dplyr::mutate(miljø_afhængig_fd = miljø_afhængig - dplyr::lag(miljø_afhængig)) %>% 
  dplyr::ungroup()



#GDP Per Capita
# Forbered datasættene ved at ekstrahere årstallet fra edate
final_dataset <- dplyr::mutate(final_dataset, 
                                Year = as.numeric(substr(edate, 1, 4)))

# Match datasættene ved hjælp af left_join
# Dette kopierer GDP_per_capita over i final_dataset
final_dataset <- dplyr::left_join(final_dataset, 
                                   gdp_per_capita, 
                                   by = c("countryname" = "countryname", 
                                          "Year" = "Year"))

# Lagged gdp_per_capita
#final_dataset <- final_dataset %>%
 # dplyr::arrange(party, edate) %>%
#  dplyr::group_by(party) %>%
 # dplyr::mutate(GDP_per_capita_lag1 = dplyr::lag(GDP_per_capita, n = 1, order_by = edate))

#GDP Per Capita Growth
# Match datasættene ved hjælp af left_join
# Dette kopierer GDP_per_capita over i final_dataset
final_dataset <- dplyr::left_join(final_dataset, 
                                   gdp_per_capita_growth, 
                                   by = c("countryname" = "countryname", 
                                          "Year" = "Year"))

# Step 1: Identify when radical right parties (parfam == 70) were present in each country-election
rrp_presence <- MPDataset_MPDS2024a %>%
  filter(parfam == "70" & absseat > 0) %>% # Filter to RRP with at least one seat
  dplyr::select(country, date) %>% # Use edate instead of date to match final_dataset
  distinct() %>% # Get unique country-election combinations
  mutate(rrp_present = 1) # Add indicator that RRP present

# Step 2: Create a time series of elections for each country from the final_dataset
country_elections <- final_dataset %>%
  dplyr::select(country, date) %>%
  distinct() %>%
  arrange(country, date)

# Step 3: For each country-election, determine if RRP has ever been in parliament by that time
rrp_cumulative <- country_elections %>%
  left_join(rrp_presence, by = c("country", "date")) %>%
  replace_na(list(rrp_present = 0)) %>%
  group_by(country) %>%
  mutate(
    # Create cumulative indicator: 1 if RRP has ever been in parliament up to this date
    rrp_i_p = as.integer(cumsum(rrp_present) > 0)
  ) %>%
  ungroup()

# Step 4: Add lagged rrp_i_p indicator
rrp_with_lag <- rrp_cumulative %>%
  group_by(country) %>%
  arrange(date) %>%
  mutate(
    # For each country, add lagged version (shifted by one election)
    rrp_i_p_lag1 = lag(rrp_i_p, n = 1, order_by = edate)
  ) %>%
  ungroup()

# Step 5: Join to the final_dataset
final_dataset <- final_dataset %>%
  left_join(
    rrp_with_lag %>% 
      dplyr::select(country, date, rrp_i_p, rrp_i_p_lag1),
    by = c("country", "date")
  )

# Step 6: Check the distribution of the new variables - now with $ operator
print("Distribution of rrp_i_p:")
print(table(final_dataset$rrp_i_p, useNA = "always"))

print("Distribution of rrp_i_p_lag1:")
print(table(final_dataset$rrp_i_p_lag1, useNA = "always"))

# Optional: Visualize the presence of RRPs over time - with proper error handling
if(all(!is.na(final_dataset$rrp_i_p))) {
  ggplot(final_dataset, aes(x = factor(rrp_i_p))) +
    geom_bar(fill = c("skyblue", "salmon")) +
    labs(
      title = "Distribution of Radical Right Parties",
      x = "RRP in Parliament (0 = No, 1 = Yes)",
      y = "Number of Observations"
    ) +
    theme_minimal()
}

#Unemployment
# Dette kopierer GDP_per_capita over i final_dataset
final_dataset <- dplyr::left_join(final_dataset, 
                                   unemployment, 
                                   by = c("countryname" = "countryname", 
                                          "Year" = "Year"))


#Inflation
# Dette kopierer GDP_per_capita over i final_dataset
final_dataset <- dplyr::left_join(final_dataset, 
                                   inflation_consumer_prices, 
                                   by = c("countryname" = "countryname", 
                                          "Year" = "Year"))

# ============================================================================
# 0. Create economic indicators
# ============================================================================

# Create a composite economic indicator from existing variables in final_dataset
# Standardize each variable first (higher value = better economy)
final_dataset <- final_dataset %>%
  mutate(
    gdp_growth_std = scale(`GDP per capita growth`),
    inflation_std = -scale(`Inflation-consumer prices`),  # Minus because lower inflation is better
    unemployment_std = -scale(Unemployment)  # Minus because lower unemployment is better
  )

# Calculate an overall economic index (average of standardized values)
final_dataset <- final_dataset %>%
  mutate(
    economic_index = rowMeans(
      cbind(gdp_growth_std, inflation_std, unemployment_std),
      na.rm = TRUE
    ),
    # Create binary variable for good economy based on composite index
    good_economy = ifelse(economic_index > median(economic_index, na.rm = TRUE), 1, 0),
    # Add factor version of the variable for plots and models
    factor_good_economy = factor(good_economy, levels = c(0, 1), 
                                labels = c("Poor economy", "Good economy"))
  )

# Forberedelse af data med BNP-vækst som moderator
final_dataset <- final_dataset %>%
  mutate(
    # Opret binær variabel for høj/lav BNP-vækst baseret på median
    high_gdp_growth = ifelse(`GDP per capita growth` > median(`GDP per capita growth`, na.rm = TRUE), 1, 0),
    # Tilføj faktorniveauer for pænere plots og modeller
    factor_high_gdp_growth = factor(high_gdp_growth, levels = c(0, 1), 
                                  labels = c("Lav BNP-vækst", "Høj BNP-vækst"))
  )

# Create clean dataset for analysis (remove missing values)
clean_data <- na.omit(final_dataset)

#View(final_dataset)

```


# 2. Exploratory Data Analysis

```{r exploratory_plots}
#------------------------------------------------------------
# 1. Descriptive Statistics
#------------------------------------------------------------

# 1.1 Summary statistics table for key variables
summary_stats <- final_dataset %>%
  dplyr::select(
    miljø_afhængig, per410, per416, per501, 
    pervote_samlet, lagged_pervote_samlet, 
    i_parlament, lagged_i_parlament,
    rile_lowe, avg_pervote_main, 
    rrp_i_p_lag1, `GDP per capita growth`, Unemployment, `Inflation-consumer prices`
  ) %>%
  summary()

# Creating a more formatted table
summary_table <- final_dataset %>%
  dplyr::select(
    miljø_afhængig, per410, per416, per501, 
    pervote_samlet, lagged_pervote_samlet, 
    i_parlament, lagged_i_parlament,
    rile_lowe, avg_pervote_main, 
    rrp_i_p_lag1, `GDP per capita growth`, Unemployment, `Inflation-consumer prices`
  ) %>%
  summarise(across(where(is.numeric), 
                   list(
                     mean = ~mean(., na.rm = TRUE),
                     median = ~median(., na.rm = TRUE),
                     sd = ~sd(., na.rm = TRUE),
                     min = ~min(., na.rm = TRUE),
                     max = ~max(., na.rm = TRUE),
                     n = ~sum(!is.na(.))
                   )))

# Reshape for better presentation
summary_long <- summary_table %>%
  pivot_longer(cols = everything(),
               names_to = c("variable", "stat"),
               names_pattern = "(.*)_(.*)",
               values_to = "value")

summary_wide <- summary_long %>%
  pivot_wider(names_from = stat, values_from = value) %>%
  arrange(variable)

# 1.2 Country-level summary
country_summary <- final_dataset %>%
  group_by(countryname) %>%
  summarise(
    n_observations = n(),
    first_year = min(Year, na.rm = TRUE),
    last_year = max(Year, na.rm = TRUE),
    n_parties = n_distinct(party),
    avg_parties_per_year = n_parties / (last_year - first_year + 1),
    n_green_in_parl = sum(lagged_i_parlament, na.rm = TRUE),
    n_rrp_in_parl = sum(rrp_i_p_lag1, na.rm = TRUE),
    avg_climate_position = mean(miljø_afhængig, na.rm = TRUE)
  )

# 1.3 Electoral threshold variation
threshold_summary <- final_dataset %>%
  group_by(countryname) %>%
  summarise(
    min_threshold = min(threshold, na.rm = TRUE),
    max_threshold = max(threshold, na.rm = TRUE),
    threshold_changed = min_threshold != max_threshold,
    avg_threshold = mean(threshold, na.rm = TRUE)
  )

# 1.4 Green party success rates over time
green_success_time <- final_dataset %>%
  group_by(Year) %>%
  summarise(
    green_parties = sum(!is.na(pervote_samlet)),
    greens_in_parl = sum(i_parlament, na.rm = TRUE),
    success_rate = greens_in_parl / green_parties
  )

# Green party success by country
green_success_country <- final_dataset %>%
  group_by(countryname) %>%
  summarise(
    green_parties = sum(!is.na(pervote_samlet)),
    greens_in_parl = sum(i_parlament, na.rm = TRUE),
    success_rate = greens_in_parl / green_parties
  )

# 1.5 Visualize country coverage
country_coverage_plot <- ggplot(country_summary, aes(x = reorder(countryname, n_observations), y = n_observations)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  labs(
    title = "Number of Observations by Country",
    x = "Country",
    y = "Number of Observations"
  ) +
  theme_minimal()

# 1.6 Time coverage by country
time_coverage <- final_dataset %>%
  group_by(countryname, Year) %>%
  summarise(has_obs = TRUE, .groups = "drop") %>%
  complete(countryname, Year = min(final_dataset$Year, na.rm = TRUE):max(final_dataset$Year, na.rm = TRUE)) %>%
  mutate(has_obs = ifelse(is.na(has_obs), FALSE, TRUE))

time_coverage_plot <- ggplot(time_coverage, aes(x = Year, y = countryname, fill = has_obs)) +
  geom_tile(color = "white") +
  scale_fill_manual(values = c("TRUE" = "steelblue", "FALSE" = "lightgray")) +
  labs(
    title = "Time Coverage by Country",
    x = "Year",
    y = "Country",
    fill = "Has Data"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")

#------------------------------------------------------------
# 2. Outcome Variable Analysis
#------------------------------------------------------------

# 2.1 Distribution of climate position
climate_dist_plot <- ggplot(final_dataset, aes(x = miljø_afhængig)) +
  geom_histogram(aes(y = ..density..), bins = 30, fill = "steelblue", color = "darkblue", alpha = 0.7) +
  geom_density(color = "red", size = 1) +
  labs(
    title = "Distribution of Climate Position Variable",
    x = "Climate Position (miljø_afhængig)",
    y = "Density"
  ) +
  theme_minimal()

# 2.2 Climate position by country
climate_country_plot <- ggplot(final_dataset, aes(x = reorder(countryname, miljø_afhængig, FUN = median, na.rm = TRUE), 
                                               y = miljø_afhængig)) +
  geom_boxplot(fill = "steelblue", alpha = 0.7) +
  coord_flip() +
  labs(
    title = "Climate Position by Country",
    x = "Country",
    y = "Climate Position"
  ) +
  theme_minimal()

# 2.3 Climate position over time
climate_time_plot <- final_dataset %>%
  group_by(Year) %>%
  summarise(
    mean_climate = mean(miljø_afhængig, na.rm = TRUE),
    median_climate = median(miljø_afhængig, na.rm = TRUE),
    lower_ci = mean_climate - 1.96 * sd(miljø_afhængig, na.rm = TRUE) / sqrt(n()),
    upper_ci = mean_climate + 1.96 * sd(miljø_afhængig, na.rm = TRUE) / sqrt(n())
  ) %>%
  ggplot(aes(x = Year, y = mean_climate)) +
  geom_line(size = 1, color = "steelblue") +
  geom_ribbon(aes(ymin = lower_ci, ymax = upper_ci), alpha = 0.2) +
  geom_line(aes(y = median_climate), linetype = "dashed", color = "darkred") +
  labs(
    title = "Climate Position Over Time",
    x = "Year",
    y = "Average Climate Position",
    caption = "Solid line: mean with 95% CI; Dashed line: median"
  ) +
  theme_minimal()

# 2.4 Components of climate position
components_data <- final_dataset %>%
  dplyr::select(countryname, edate, party, per410, per416, per501) %>%
  pivot_longer(cols = c(per410, per416, per501),
               names_to = "component",
               values_to = "value") %>%
  mutate(component = case_when(
    component == "per410" ~ "Environmental Protection (per410)",
    component == "per416" ~ "Anti-Growth Economy (per416)",
    component == "per501" ~ "Environmental Protection: Positive (per501)",
    TRUE ~ component
  ))

components_plot <- ggplot(components_data, aes(x = value, fill = component)) +
  geom_histogram(bins = 20, alpha = 0.7, position = "identity") +
  facet_wrap(~ component) +
  labs(
    title = "Distribution of Climate Position Components",
    x = "Value",
    y = "Count"
  ) +
  theme_minimal() +
  theme(legend.position = "none")

# 2.5 Climate position zero values analysis
zero_prop <- final_dataset %>%
  dplyr::group_by(countryname) %>%
  summarise(
    total = n(),
    zero_values = sum(miljø_afhængig == 0, na.rm = TRUE),
    prop_zero = zero_values / total
  ) %>%
  arrange(desc(prop_zero))

zero_plot <- ggplot(zero_prop, aes(x = reorder(countryname, prop_zero), y = prop_zero)) +
  geom_bar(stat = "identity", fill = "darkred") +
  coord_flip() +
  labs(
    title = "Proportion of Zero Climate Position Values by Country",
    x = "Country",
    y = "Proportion of Zero Values"
  ) +
  theme_minimal()

# 2.6 Climate position by party family
party_family_climate <- final_dataset %>%
  dplyr::mutate(
    party_family = case_when(
      parfam == "10" ~ "Green",
      parfam == "20" ~ "Socialist/Other left parties",
      parfam == "30" ~ "Social Democratic",
      parfam == "40" ~ "Liberal",
      parfam == "50" ~ "Christian Democratic",
      parfam == "60" ~ "Conservative",
      parfam == "70" ~ "Nationalist",
      parfam == "80" ~ "Agrarian",
      parfam == "90" ~ "Ethnic/Regional",
      parfam == "95" ~ "Special issue parties",
      parfam == "98" ~ "Electoral alliance w/o leader",
      TRUE ~ "Other"
    )
  ) %>%
  filter(!is.na(party_family))

family_climate_plot <- ggplot(party_family_climate, aes(x = reorder(party_family, miljø_afhængig, FUN = median, na.rm = TRUE), 
                                                     y = miljø_afhængig)) +
  geom_boxplot(fill = "steelblue", alpha = 0.7) +
  coord_flip() +
  labs(
    title = "Climate Position by Party Family",
    x = "Party Family",
    y = "Climate Position"
  ) +
  theme_minimal()

# 2.7 Andel nul-værdier for partifamilierne
# Oprettelse af forbedret graf med de rigtige partifamilienavne
zero_climate_by_parfam <- final_dataset %>%
   mutate(
     party_family = case_when(
       parfam == "10" ~ "Green",
       parfam == "20" ~ "Socialist/Other left parties",
       parfam == "30" ~ "Social Democratic",
       parfam == "40" ~ "Liberal",
       parfam == "50" ~ "Christian Democratic",
       parfam == "60" ~ "Conservative",
       parfam == "70" ~ "Nationalist",
       parfam == "80" ~ "Agrarian",
       parfam == "90" ~ "Ethnic/Regional",
       parfam == "95" ~ "Special issue parties",
       parfam == "98" ~ "Electoral alliance w/o leader",
       TRUE ~ "Other"
     )
   ) %>%
   group_by(party_family) %>%
   summarise(
     zero_proportion = mean(miljø_afhængig == 0, na.rm = TRUE)
   ) %>%
   # Sortér fra høj til lav værdi
   arrange(desc(zero_proportion)) %>%
   # Omdanner til faktor med niveauerne i sorteret rækkefølge
   mutate(party_family = factor(party_family, levels = party_family))
 
 ggplot(zero_climate_by_parfam, aes(x = party_family, y = zero_proportion)) +
   geom_bar(stat = "identity", fill = "steelblue") +
   labs(
     title = "Proportion of Zero Climate Position Values by Party Family",
     x = "Party Family",
     y = "Proportion of Zero Values"
   ) +
   theme_minimal() +
   theme(
     panel.grid.major.y = element_blank(),
     panel.grid.minor.y = element_blank(),
     panel.grid.minor.x = element_blank(),
     axis.text.y = element_text(size = 9),
     plot.title = element_text(size = 12, face = "bold"),
     plot.margin = margin(10, 10, 10, 10)
   ) +
   coord_flip() +
   # Bruge decimaler i stedet for procent
   scale_y_continuous(labels = function(x) format(x, decimal.mark = ".", big.mark = ","), 
                     breaks = seq(0, 0.20, by = 0.05),
                     limits = c(0, 0.20))

#------------------------------------------------------------
# 3. Running Variable and Treatment Analysis
#------------------------------------------------------------

# 3.1 Distribution of green party vote share relative to threshold
rv_dist_plot <- ggplot(final_dataset, aes(x = centered_lagged_pervote_samlet)) +
  geom_histogram(binwidth = 0.5, fill = "steelblue", color = "darkblue") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red", size = 1) +
  labs(
    title = "Distribution of Green Party Vote Share (Centered at Threshold)",
    x = "Centered Vote Share",
    y = "Count"
  ) +
  theme_minimal()

# 3.2 Density test around threshold (McCrary test)
# Estimér og test tæthedsdiskontinuitet
rdd_result <- rddensity(final_dataset$centered_lagged_pervote_samlet, c = 0)
density_test_summary <- summary(rdd_result)

# Plot med indbygget funktion (korrekt metode ifølge Cattaneo et al.)
rdplotdensity(rdd_result, 
              X = final_dataset$centered_lagged_pervote_samlet,
              type = "both",
              CItype = "region",
              title = "Density Manipulation Test around Threshold",
              xlabel = "Centered Vote Share",
              ylabel = "Density",
              lcol = c("blue", "red"),
              legendTitle = "Density Estimates",
              legendGroups = c("Below threshold", "Above threshold"))

DCdensity(final_dataset$centered_lagged_pervote_samlet, c = 0, ext.out = TRUE)



# 3.3 Relationship between vote share and seat allocation
seat_allocation_plot <- ggplot(final_dataset, aes(x = centered_lagged_pervote_samlet, y = lagged_i_parlament)) +
  geom_jitter(aes(color = factor(lagged_i_parlament)), width = 0, height = 0.05, alpha = 0.5) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  labs(
    title = "Green Party Parliamentary Representation by Vote Share",
    x = "Vote Share (Centered at Threshold)",
    y = "In Parliament"
  ) +
  scale_color_manual(values = c("0" = "darkblue", "1" = "darkred"), 
                     name = "Parliamentary\nStatus",
                     labels = c("Not in Parliament", "In Parliament")) +
  theme_minimal()

# 3.4 Balance check for covariates around threshold
# Create functions for balance check
balance_check_plot <- function(data, var_name, running_var, cutpoint = 0, bandwidth = 2) {
  # Convert running_var from character to actual variable
  running_var_value <- data[[running_var]]
  
  # Create subset without using dplyr filter to avoid grouping issues
  data_subset <- data[abs(running_var_value) <= bandwidth, ]
  
  formula_str <- as.formula(paste0(var_name, " ~ ", running_var, " * I(", 
                                  running_var, " >= ", cutpoint, ")"))
  
  model <- lm(formula_str, data = data_subset)
  model_summary <- summary(model)
  
  # Make sure to handle potential issues with the interaction term
  interaction_pval <- tryCatch({
    coef(model_summary)[4, 4]
  }, error = function(e) {
    NA
  })
  
  ggplot(data, aes_string(x = running_var, y = var_name)) +
    geom_point(alpha = 0.3) +
    geom_smooth(data = subset(data, data[[running_var]] < cutpoint), 
                method = "lm", formula = y ~ x, color = "blue") +
    geom_smooth(data = subset(data, data[[running_var]] >= cutpoint), 
                method = "lm", formula = y ~ x, color = "red") +
    geom_vline(xintercept = cutpoint, linetype = "dashed") +
    labs(
      title = paste("Balance Check:", var_name),
      subtitle = paste("Interaction p-value:", round(interaction_pval, 4)),
      x = "Running Variable",
      y = var_name
    ) +
    theme_minimal()
}

# Run balance checks for key variables
rile_balance <- balance_check_plot(final_dataset, "rile_lowe", "centered_lagged_pervote_samlet")
gdp_balance <- balance_check_plot(final_dataset, "GDP_per_capita", "centered_lagged_pervote_samlet")
unemp_balance <- balance_check_plot(final_dataset, "Unemployment", "centered_lagged_pervote_samlet")
#gdp_growth_balance <- balance_check_plot(final_dataset, `GDP per capita growth`, "centered_lagged_pervote_samlet")


# 3.5 Green party representation over time
green_time_plot <- final_dataset %>%
  dplyr::group_by(Year) %>%
  summarise(
    prop_in_parl = mean(lagged_i_parlament, na.rm = TRUE),
    avg_vote_share = mean(lagged_pervote_samlet, na.rm = TRUE)
  ) %>%
  ggplot(aes(x = Year)) +
  geom_line(aes(y = prop_in_parl, color = "Proportion in Parliament"), size = 1) +
  geom_line(aes(y = avg_vote_share / 100, color = "Average Vote Share (scaled)"), size = 1) +
  scale_y_continuous(
    name = "Proportion in Parliament",
    sec.axis = sec_axis(~.*100, name = "Average Vote Share (%)")
  ) +
  scale_color_manual(values = c("Proportion in Parliament" = "darkred", 
                               "Average Vote Share (scaled)" = "darkblue")) +
  labs(
    title = "Green Party Representation Over Time",
    x = "Year",
    color = "Measure"
  ) +
  theme_minimal()

#------------------------------------------------------------
# 4. Moderating Variables Analysis
#------------------------------------------------------------

# 4.1 Radical right presence over time
rrp_time_plot <- final_dataset %>%
  dplyr::group_by(Year) %>%
  summarise(
    prop_rrp = mean(rrp_i_p_lag1, na.rm = TRUE)
  ) %>%
  ggplot(aes(x = Year, y = prop_rrp)) +
  geom_line(size = 1, color = "darkred") +
  geom_point(size = 2, color = "darkred") +
  labs(
    title = "Radical Right Party Presence Over Time",
    x = "Year",
    y = "Proportion of Observations with RRP in Parliament"
  ) +
  theme_minimal()

# 4.2 Economic conditions visualization
# Opret de tre individuelle plots
# Plot for GDP growth
p1 <- final_dataset %>%
  dplyr::group_by(Year) %>%
  summarise(gdp_growth = mean(`GDP per capita growth`, na.rm = TRUE)) %>%
  ggplot(aes(x = Year, y = gdp_growth)) +
  geom_line(size = 1, color = "red") +
  geom_point(size = 2, color = "red") +
  labs(title = "GDP Growth", y = "Value") +
  theme_minimal()

# Plot for inflation (med logaritmisk skala)
p2 <- final_dataset %>%
  dplyr::group_by(Year) %>%
  summarise(inflation = mean(`Inflation-consumer prices`, na.rm = TRUE)) %>%
  ggplot(aes(x = Year, y = inflation)) +
  geom_line(size = 1, color = "green") +
  geom_point(size = 2, color = "green") +
  scale_y_log10() +
  labs(title = "Inflation (log scale)", y = "Value") +
  theme_minimal()

# Plot for unemployment
p3 <- final_dataset %>%
  dplyr::group_by(Year) %>%
  summarise(unemployment = mean(Unemployment, na.rm = TRUE)) %>%
  ggplot(aes(x = Year, y = unemployment)) +
  geom_line(size = 1, color = "blue") +
  geom_point(size = 2, color = "blue") +
  labs(title = "Unemployment", y = "Value") +
  theme_minimal()

# Kombiner plots i én række (ligesom i dit eksempel)
econ_indicators_plot <- p1 + p2 + p3 +
  plot_layout(ncol = 3) +
  plot_annotation(
    title = "Economic Indicators Over Time",
    subtitle = "GDP Growth, Inflation (logarithmic scale), and Unemployment",
    theme = theme(plot.title = element_text(size = 14, face = "bold"),
                 plot.subtitle = element_text(size = 10))
  )

# Vis samlet plot
print(econ_indicators_plot)

# Gem plottet hvis nødvendigt
# ggsave("economic_indicators.png", econ_indicators_plot, width = 12, height = 5, dpi = 300)

# 4.3 Left-right party distribution
ideology_dist_plot <- ggplot(final_dataset, aes(x = rile_lowe)) +
  geom_histogram(bins = 30, fill = "steelblue", color = "darkblue", alpha = 0.7) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red") +
  labs(
    title = "Distribution of Party Ideology (Lowe's RILE Score)",
    x = "RILE Score (Negative = Left, Positive = Right)",
    y = "Count"
  ) +
  theme_minimal()

# 4.4 Party size distribution
party_size_plot <- ggplot(final_dataset, aes(x = avg_pervote_main)) +
  geom_histogram(bins = 30, fill = "steelblue", color = "darkblue", alpha = 0.7) +
  geom_vline(xintercept = median(final_dataset$avg_pervote_main, na.rm = TRUE), 
            linetype = "dashed", color = "red") +
  # Create a data frame for the label instead of using annotate
  geom_text(data = data.frame(
      x = median(final_dataset$avg_pervote_main, na.rm = TRUE) + 5,
      y = 50,
      label = "Median"
    ), 
    aes(x = x, y = y, label = label),
    color = "red"
  ) +
  labs(
    title = "Distribution of Party Size (Average Vote Share)",
    x = "Average Vote Share (%)",
    y = "Count"
  ) +
  theme_minimal()

# 4.5 Correlation matrix of moderating variables
correlation_data <- final_dataset %>%
  dplyr::select(
    miljø_afhængig, rile_lowe, avg_pervote_main, 
    rrp_i_p_lag1, `GDP per capita growth`, 
    Unemployment, `Inflation-consumer prices`
  ) %>%
  na.omit()

correlation_matrix <- cor(correlation_data)

# Correlation plot
corrplot(correlation_matrix, method = "color", type = "upper", 
        order = "hclust", tl.col = "black", tl.srt = 45,
        title = "Correlation Matrix of Key Variables",
        mar = c(0,0,2,0))

#------------------------------------------------------------
# 5. Preliminary Relationship Exploration
#------------------------------------------------------------

# 5.1 Bivariate relationship plot
bivariate_plot <- ggplot(final_dataset, aes(x = centered_lagged_pervote_samlet, y = miljø_afhængig)) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "loess") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red") +
  labs(
    title = "Relationship Between Green Party Vote Share and Climate Position",
    x = "Green Party Vote Share (Centered)",
    y = "Climate Position"
  ) +
  theme_minimal()

# 5.2 Conditional means plot
# Funktion til at lave conditional means plot med bin-data og forskellig polynomiegrad
create_conditional_means_plot <- function(data, poly_degree, bin_width = 0.5, x_limit = 10) {
  # Opret bins for data
  data$bin <- cut(data$centered_lagged_pervote_samlet, 
                 breaks = seq(-5, x_limit, by = bin_width),
                 include.lowest = TRUE)
  
  # Beregn gennemsnit for hver bin
  bin_means <- data %>%
    dplyr::group_by(bin, factor_lagged_i_parlament) %>%
    dplyr::summarise(
      mean_miljø = mean(miljø_afhængig, na.rm = TRUE),
      se_miljø = sd(miljø_afhængig, na.rm = TRUE) / sqrt(n()),
      median_bin = median(as.numeric(centered_lagged_pervote_samlet), na.rm = TRUE),
      n = n(),
      .groups = "drop"
    )
  
  # Plot binned means med polynomial fit
  ggplot() +
    # Tilføj punkter for hver bin
    geom_point(data = bin_means, 
              aes(x = median_bin, y = mean_miljø, color = factor_lagged_i_parlament, size = n),
              alpha = 0.7) +
    # Tilføj fejllinjer
    geom_errorbar(data = bin_means,
                 aes(x = median_bin, 
                     ymin = mean_miljø - se_miljø, 
                     ymax = mean_miljø + se_miljø,
                     color = factor_lagged_i_parlament),
                 width = 0.1, alpha = 0.5) +
    # Tilføj polynomial fit til venstre for tærsklen
    geom_smooth(data = subset(bin_means, median_bin < 0),
               aes(x = median_bin, y = mean_miljø),
               method = "lm", formula = paste0("y ~ poly(x, ", poly_degree, ", raw = TRUE)"),
               color = "blue", se = TRUE) +
    # Tilføj polynomial fit til højre for tærsklen
    geom_smooth(data = subset(bin_means, median_bin >= 0),
               aes(x = median_bin, y = mean_miljø),
               method = "lm", formula = paste0("y ~ poly(x, ", poly_degree, ", raw = TRUE)"),
               color = "red", se = TRUE) +
    # Tilføj vertikal linje ved tærsklen
    geom_vline(xintercept = 0, linetype = "dashed") +
    # Juster akser og titler
    coord_cartesian(xlim = c(-5, x_limit)) +
    scale_size_continuous(name = "Antal obs.", range = c(1, 5)) +
    labs(
      title = paste0("Conditional Means Plot (Polynomial Degree ", poly_degree, ")"),
      x = "Green Party Vote Share (Centered)",
      y = "Average Climate Position",
      color = "Parliamentary Status"
    ) +
    theme_minimal()
}

# Opret plots med forskellige polynomiegrader
cm1 <- create_conditional_means_plot(final_dataset, poly_degree = 1)
cm2 <- create_conditional_means_plot(final_dataset, poly_degree = 2)
cm3 <- create_conditional_means_plot(final_dataset, poly_degree = 3)
cm4 <- create_conditional_means_plot(final_dataset, poly_degree = 4)

# Kombiner plots i et 2x2 grid
conditional_means_comparison <- (cm1 + cm2) / (cm3 + cm4) + 
  plot_annotation(
    title = "Conditional Means Visualization: Comparison of Different Polynomial Specifications",
    subtitle = "Effect of Green Party Parliamentary Entry on Climate Position",
    theme = theme(plot.title = element_text(size = 14, face = "bold"),
                 plot.subtitle = element_text(size = 10))
  )

# Vis samlet plot
print(conditional_means_comparison)

# Gem plottet til en fil
ggsave("conditional_means_comparison.png", conditional_means_comparison, width = 12, height = 9, dpi = 300)

# 5.3 Enhanced RDD visualization
# Funktion til at oprette RDD plot med specifik polynomiegrad
create_poly_rdd_plot <- function(data, poly_degree, x_limit = 10) {
  # Beregn y-position for annotationer
  max_y_value <- max(data$miljø_afhængig, na.rm = TRUE)
  annotation_y_position <- max_y_value * 0.9
  
  # Opret plottet
  ggplot(data, aes(x = centered_lagged_pervote_samlet, y = miljø_afhængig)) +
    # Begræns x-aksen til det specificerede interval
    coord_cartesian(xlim = c(-6, x_limit)) +
    # Tilføj punkter
    geom_point(aes(color = factor_lagged_i_parlament), alpha = 0.3, size = 1) +
    # Kurve for data til venstre for tærsklen
    geom_smooth(data = subset(data, centered_lagged_pervote_samlet < 0 & centered_lagged_pervote_samlet > -5),
               method = "lm", 
               formula = paste0("y ~ poly(x, ", poly_degree, ", raw = TRUE)"), 
               color = "blue", se = TRUE) +
    # Kurve for data til højre for tærsklen
    geom_smooth(data = subset(data, centered_lagged_pervote_samlet >= 0 & centered_lagged_pervote_samlet < x_limit),
               method = "lm", 
               formula = paste0("y ~ poly(x, ", poly_degree, ", raw = TRUE)"), 
               color = "red", se = TRUE) +
    # Tilføj vertikal linje ved tærsklen
    geom_vline(xintercept = 0, linetype = "dashed") +
    # Brug geom_text i stedet for annotate for at undgå fejl
    geom_text(aes(x = -3.5, y = annotation_y_position, label = "Green Party Below Threshold"), 
              color = "darkblue", size = 3, inherit.aes = FALSE) +
    geom_text(aes(x = 5, y = annotation_y_position, label = "Green Party Above Threshold"), 
              color = "darkred", size = 3, inherit.aes = FALSE) +
    # Titler og aksenavne
    labs(
      title = paste0("Polynomial Degree ", poly_degree),
      x = "Green Party Vote Share (Centered)",
      y = "Climate Position"
    ) +
    # Fjern farvenøglen da vi har tekstforklaringer
    theme_minimal() +
    theme(legend.position = "none")
}

# Kode til at køre i R med dit faktiske datasæt:
# Antagelse: final_dataset er dit datasæt med de nødvendige kolonner

# Opret individuelle plots med forskellige polynomiegrader
p1 <- create_poly_rdd_plot(final_dataset, poly_degree = 1)  # Lineær
p2 <- create_poly_rdd_plot(final_dataset, poly_degree = 2)  # Kvadratisk
p3 <- create_poly_rdd_plot(final_dataset, poly_degree = 3)  # Kubisk
p4 <- create_poly_rdd_plot(final_dataset, poly_degree = 4)  # Kvartisk

# Kombiner plots i et 2x2 grid
polynomial_comparison <- (p1 + p2) / (p3 + p4) + 
  plot_annotation(
    title = "RDD Visualization: Comparison of Different Polynomial Specifications",
    subtitle = "Effect of Green Party Parliamentary Entry on Climate Position",
    theme = theme(plot.title = element_text(size = 14, face = "bold"),
                 plot.subtitle = element_text(size = 10))
  )

# Vis samlet plot
print(polynomial_comparison)

# Gem plottet til en fil med høj opløsning
ggsave("rdd_polynomial_comparison.png", polynomial_comparison, width = 10, height = 8, dpi = 300)

# Kode til at eksperimentere med forskellige båndbredder
# Dette vil vise, hvordan estimaterne varierer med forskellige båndbredder
create_bandwidth_plot <- function(data, poly_degree = 1, bandwidth) {
  # Filtrér data baseret på båndbredde
  filtered_data <- data[abs(data$centered_lagged_pervote_samlet) <= bandwidth, ]
  
  # Opret plottet
  ggplot(filtered_data, aes(x = centered_lagged_pervote_samlet, y = miljø_afhængig)) +
    geom_point(aes(color = factor_lagged_i_parlament), alpha = 0.3, size = 1) +
    geom_smooth(data = subset(filtered_data, centered_lagged_pervote_samlet < 0),
               method = "lm", 
               formula = paste0("y ~ poly(x, ", poly_degree, ", raw = TRUE)"), 
               color = "blue", se = TRUE) +
    geom_smooth(data = subset(filtered_data, centered_lagged_pervote_samlet >= 0),
               method = "lm", 
               formula = paste0("y ~ poly(x, ", poly_degree, ", raw = TRUE)"), 
               color = "red", se = TRUE) +
    geom_vline(xintercept = 0, linetype = "dashed") +
    labs(
      title = paste0("Bandwidth = ±", bandwidth, ", Polynomial Degree ", poly_degree),
      x = "Green Party Vote Share (Centered)",
      y = "Climate Position"
    ) +
    theme_minimal() +
    theme(legend.position = "none")
}

# Opret plots med forskellige båndbredder (for lineær model)
b1 <- create_bandwidth_plot(final_dataset, poly_degree = 1, bandwidth = 1)
b2 <- create_bandwidth_plot(final_dataset, poly_degree = 1, bandwidth = 2)
b3 <- create_bandwidth_plot(final_dataset, poly_degree = 1, bandwidth = 3)
b4 <- create_bandwidth_plot(final_dataset, poly_degree = 1, bandwidth = 5)

# Kombiner båndbredde-plots
bandwidth_comparison <- (b1 + b2) / (b3 + b4) + 
  plot_annotation(
    title = "RDD Visualization: Comparison of Different Bandwidths",
    subtitle = "Effect of Green Party Parliamentary Entry on Climate Position (Linear Model)",
    theme = theme(plot.title = element_text(size = 14, face = "bold"),
                 plot.subtitle = element_text(size = 10))
  )

# Vis båndbredde-sammenligningsplot
print(bandwidth_comparison)

# Gem båndbredde-plottet
ggsave("rdd_bandwidth_comparison.png", bandwidth_comparison, width = 10, height = 8, dpi = 300)

# 5.4 Faceted RDD plots by moderating variables
# By RRP presence
rrp_facet_plot <- ggplot(final_dataset, aes(x = centered_lagged_pervote_samlet, y = miljø_afhængig)) +
  geom_point(alpha = 0.3) +
  geom_smooth(data = subset(final_dataset, centered_lagged_pervote_samlet < 0),
             method = "lm", formula = y ~ poly(x, 2, raw = TRUE), 
             color = "blue") +
  geom_smooth(data = subset(final_dataset, centered_lagged_pervote_samlet >= 0),
             method = "lm", formula = y ~ poly(x, 2, raw = TRUE), 
             color = "red") +
  geom_vline(xintercept = 0, linetype = "dashed") +
  facet_wrap(~ factor(rrp_i_p_lag1, labels = c("No RRP in Parliament", "RRP in Parliament"))) +
  labs(
    title = "Effect of Green Party Entry by Radical Right Presence",
    x = "Green Party Vote Share (Centered)",
    y = "Climate Position"
  ) +
  theme_minimal()

# By economic conditions
# Filtrer NA-værdierne ud og lav kun plot for good/poor economy
economy_facet_plot <- ggplot(
  # Filtrer NA-værdier fra factor_good_economy
  final_dataset %>% filter(!is.na(factor_good_economy)), 
  aes(x = centered_lagged_pervote_samlet, y = miljø_afhængig)) +
  geom_point(alpha = 0.3) +
  # Opdater subsetting til også at filtrere NA væk
  geom_smooth(data = subset(final_dataset, 
                          !is.na(factor_good_economy) & centered_lagged_pervote_samlet < 0),
             method = "lm", formula = y ~ poly(x, 2, raw = TRUE), 
             color = "blue") +
  geom_smooth(data = subset(final_dataset, 
                          !is.na(factor_good_economy) & centered_lagged_pervote_samlet >= 0),
             method = "lm", formula = y ~ poly(x, 2, raw = TRUE), 
             color = "red") +
  geom_vline(xintercept = 0, linetype = "dashed") +
  facet_wrap(~ factor_good_economy) +
  labs(
    title = "Effect of Green Party Entry by Economic Conditions",
    x = "Green Party Vote Share (Centered)",
    y = "Climate Position"
  ) +
  theme_minimal()

# Vis plottet
print(economy_facet_plot)

# By party ideology
ideology_facet_plot <- ggplot(final_dataset, aes(x = centered_lagged_pervote_samlet, y = miljø_afhængig)) +
  geom_point(alpha = 0.3) +
  geom_smooth(data = subset(final_dataset, centered_lagged_pervote_samlet < 0),
             method = "lm", formula = y ~ poly(x, 2, raw = TRUE), 
             color = "blue") +
  geom_smooth(data = subset(final_dataset, centered_lagged_pervote_samlet >= 0),
             method = "lm", formula = y ~ poly(x, 2, raw = TRUE), 
             color = "red") +
  geom_vline(xintercept = 0, linetype = "dashed") +
  facet_wrap(~ factor(left_party, labels = c("Right-wing Parties", "Left-wing Parties"))) +
  labs(
    title = "Effect of Green Party Entry by Party Ideology",
    x = "Green Party Vote Share (Centered)",
    y = "Climate Position"
  ) +
  theme_minimal()

# By party size
size_facet_plot <- ggplot(final_dataset, aes(x = centered_lagged_pervote_samlet, y = miljø_afhængig)) +
  geom_point(alpha = 0.3) +
  geom_smooth(data = subset(final_dataset, centered_lagged_pervote_samlet < 0),
             method = "lm", formula = y ~ poly(x, 2, raw = TRUE), 
             color = "blue") +
  geom_smooth(data = subset(final_dataset, centered_lagged_pervote_samlet >= 0),
             method = "lm", formula = y ~ poly(x, 2, raw = TRUE), 
             color = "red") +
  geom_vline(xintercept = 0, linetype = "dashed") +
  facet_wrap(~ factor(large_party, labels = c("Small Parties", "Large Parties"))) +
  labs(
    title = "Effect of Green Party Entry by Party Size",
    x = "Green Party Vote Share (Centered)",
    y = "Climate Position"
  ) +
  theme_minimal()

# 5.5 Placebo outcomes check
# Identify placebo outcomes (variables that shouldn't be affected by threshold crossing)
placebo_vars <- c("rile_lowe", "parfam")

# Example for one placebo outcome
placebo_plot <- ggplot(final_dataset, aes(x = centered_lagged_pervote_samlet, y = rile_lowe)) +
  geom_point(alpha = 0.3) +
  geom_smooth(data = subset(final_dataset, centered_lagged_pervote_samlet < 0),
             method = "lm", formula = y ~ poly(x, 2, raw = TRUE), 
             color = "blue") +
  geom_smooth(data = subset(final_dataset, centered_lagged_pervote_samlet >= 0),
             method = "lm", formula = y ~ poly(x, 2, raw = TRUE), 
             color = "red") +
  geom_vline(xintercept = 0, linetype = "dashed") +
  labs(
    title = "Placebo Outcome Check: Party Ideology (RILE)",
    x = "Green Party Vote Share (Centered)",
    y = "Party Ideology (RILE Score)"
  ) +
  theme_minimal()

#------------------------------------------------------------
# 6. Additional Analyses
#------------------------------------------------------------

# 6.1 Missing data analysis
missing_data_overview <- final_dataset %>%
  summarise(across(everything(), ~ sum(is.na(.)) / length(.))) %>%
  pivot_longer(cols = everything(), 
               names_to = "variable", 
               values_to = "missing_proportion") %>%
  filter(missing_proportion > 0) %>%
  arrange(desc(missing_proportion))

# Find columns that have missing values
columns_with_missing <- missing_data_overview$variable

# If no columns have missing values, select a subset of important ones
if(length(columns_with_missing) == 0) {
  columns_with_missing <- c("miljø_afhængig", "pervote_samlet", 
                          "lagged_pervote_samlet", "rrp_i_p_lag1",
                          "GDP per capita growth", "Unemployment")
}

# Create a subset of the data with only these columns
missing_data_subset <- final_dataset %>%
  dplyr::select(all_of(columns_with_missing))

# Try alternative approach with gg_miss_upset
library(naniar)
tryCatch({
  # Attempt to create the upset plot
  missing_patterns_plot <- gg_miss_upset(missing_data_subset)
}, error = function(e) {
  # If error occurs, print message and use a simpler visualization
  cat("Error with gg_miss_upset:", e$message, "\n")
  cat("Using vis_miss instead\n")
  missing_patterns_plot <- vis_miss(missing_data_subset)
})

# 6.2 Zero inflation analysis by party characteristics
zero_inflation_analysis <- final_dataset %>%
  dplyr::mutate(has_zero = miljø_afhængig == 0) %>%
  dplyr::group_by(parfam) %>%
  summarise(
    total = n(),
    n_zero = sum(has_zero, na.rm = TRUE),
    prop_zero = n_zero / total
  ) %>%
  arrange(desc(prop_zero))

zero_by_parfam_plot <- ggplot(zero_inflation_analysis, 
                             aes(x = reorder(parfam, prop_zero), y = prop_zero)) +
  geom_bar(stat = "identity", fill = "darkred") +
  coord_flip() +
  labs(
    title = "Proportion of Zero Climate Position Values by Party Family",
    x = "Party Family",
    y = "Proportion of Zero Values"
  ) +
  theme_minimal()

# 6.3 Temporal evolution of climate position by party family
party_family_time <- final_dataset %>%
  dplyr::mutate(
    party_family = case_when(
      parfam == "10" ~ "Green",
      parfam == "20" ~ "Communist/Socialist",
      parfam == "30" ~ "Social Democratic",
      parfam == "40" ~ "Liberal",
      parfam == "50" ~ "Christian Democratic",
      parfam == "60" ~ "Conservative",
      parfam == "70" ~ "Nationalist",
      parfam == "80" ~ "Agrarian",
      parfam == "90" ~ "Ethnic/Regional",
      parfam == "95" ~ "Special issue parties",
      parfam == "98" ~ "Electoral alliance w/o leader",
      TRUE ~ "Other"
    )
  ) %>%
  dplyr::filter(!is.na(party_family)) %>%
  dplyr::group_by(Year, party_family) %>%
  summarise(
    mean_climate = mean(miljø_afhængig, na.rm = TRUE),
    .groups = "drop"
  )

family_time_plot <- ggplot(party_family_time, aes(x = Year, y = mean_climate, color = party_family)) +
  geom_line(size = 1) +
  geom_point(size = 2) +
  labs(
    title = "Climate Position Over Time by Party Family",
    x = "Year",
    y = "Mean Climate Position",
    color = "Party Family"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")

# 6.4 Climate position by country with time trends
country_time_trends <- final_dataset %>%
  dplyr::group_by(countryname, Year) %>%
  summarise(
    mean_climate = mean(miljø_afhængig, na.rm = TRUE),
    .groups = "drop"
  )

country_trends_plot <- ggplot(country_time_trends, aes(x = Year, y = mean_climate, color = countryname)) +
  geom_line() +
  geom_point(size = 1) +
  labs(
    title = "Climate Position Time Trends by Country",
    x = "Year",
    y = "Mean Climate Position",
    color = "Country"
  ) +
  theme_minimal() +
  theme(legend.position = "right") +
  guides(color = guide_legend(ncol = 2))

# 6.5 Event marker timeline
# Create a dataframe of major climate events
climate_events <- data.frame(
  year = c(1992, 1997, 2005, 2009, 2015, 2016),
  event = c("Rio Earth Summit", "Kyoto Protocol", "Kyoto Protocol Enforcement", 
           "Copenhagen Accord", "Paris Agreement", "Paris Agreement Enforcement")
)

# Forbedret version af climate_events_plot med bedre placering af event labels
climate_events_plot <- climate_time_plot +
  # Tilføj lodrette linjer for klimabegivenheder
  geom_vline(data = climate_events, aes(xintercept = year), 
            linetype = "dotted", color = "darkgreen") +
  # Tilføj labels med forbedret rotation og placering
  geom_text(data = climate_events, 
           aes(x = year, 
               y = 3.3,  # Placer teksten højere oppe for at give mere plads
               label = event), 
           angle = 90,  # Lodret rotation af teksten
           hjust = 1,   # Justér tekstens placering (1 = bunden af teksten er på y-koordinaten)
           size = 3,    # Mindre tekststørrelse
           color = "darkgreen") +
  # Udvid y-aksens grænse for at give plads til labels
  ylim(-1.5, 3.5) +  # Øg den øvre grænse for at give plads til tekstlabels
  # Forbedret tema med mere plads i top og bund
  theme(
    plot.margin = margin(t = 50, r = 10, b = 10, l = 10, unit = "pt"),
    axis.text.x = element_text(angle = 0, hjust = 0.5)  # Vandret x-akse tekst
  )

# 6.6 Distribution of climate position by parliamentary status
parl_status_dist <- ggplot(final_dataset, aes(x = miljø_afhængig, fill = factor_lagged_i_parlament)) +
  geom_density(alpha = 0.5) +
  labs(
    title = "Distribution of Climate Position by Green Party Parliamentary Status",
    x = "Climate Position",
    y = "Density",
    fill = "Green Party Status"
  ) +
  theme_minimal()

# 6.7 Climate position before and after green party entry
before_after_analysis <- final_dataset %>%
  # Focus on observations around the threshold
  filter(abs(centered_lagged_pervote_samlet) <= 2) %>%
  mutate(threshold_status = ifelse(centered_lagged_pervote_samlet >= 0, "Above", "Below"))

before_after_plot <- ggplot(before_after_analysis, aes(x = threshold_status, y = miljø_afhængig, fill = threshold_status)) +
  geom_boxplot() +
  labs(
    title = "Climate Position Below vs. Above Threshold",
    x = "Threshold Status",
    y = "Climate Position",
    fill = "Threshold Status"
  ) +
  theme_minimal()

# 6.8 Climate position vs. economic indicators
economy_scatter <- ggplot(final_dataset, aes(x = `GDP per capita growth`, y = miljø_afhængig)) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "loess") +
  facet_wrap(~ factor_lagged_i_parlament) +
  labs(
    title = "Climate Position vs. GDP Growth by Parliamentary Status",
    x = "GDP Per Capita Growth",
    y = "Climate Position"
  ) +
  theme_minimal()

# 6.9 Ridge plot of climate position by country
ridge_plot <- ggplot(final_dataset, aes(x = miljø_afhængig, y = countryname, fill = countryname)) +
  geom_density_ridges(alpha = 0.6) +
  labs(
    title = "Distribution of Climate Position by Country",
    x = "Climate Position",
    y = "Country"
  ) +
  theme_minimal() +
  theme(legend.position = "none")

#------------------------------------------------------------
# 7. Saving Plots and Tables for EDA Section
#------------------------------------------------------------

# Create a list of plots for the EDA section
eda_plots <- list(
  # Section 1: Descriptive Statistics
  country_coverage_plot = country_coverage_plot,
  time_coverage_plot = time_coverage_plot,
  
  # Section 2: Outcome Variable Analysis
  climate_dist_plot = climate_dist_plot,
  climate_country_plot = climate_country_plot,
  climate_time_plot = climate_time_plot,
  components_plot = components_plot,
  zero_plot = zero_plot,
  family_climate_plot = family_climate_plot,
  
  # Section 3: Running Variable and Treatment Analysis
  rv_dist_plot = rv_dist_plot,
  rdplotdensity = rdplotdensity,
  seat_allocation_plot = seat_allocation_plot,
  rile_balance = rile_balance,
  gdp_balance = gdp_balance,
  unemp_balance = unemp_balance,
  green_time_plot = green_time_plot,
  
  # Section 4: Moderating Variables Analysis
  rrp_time_plot = rrp_time_plot,
  econ_indicators_plot = econ_indicators_plot,
  ideology_dist_plot = ideology_dist_plot,
  party_size_plot = party_size_plot,
  
  # Section 5: Preliminary Relationship Exploration
  bivariate_plot = bivariate_plot,
  conditional_means_comparison = conditional_means_comparison,
  polynomial_comparison = polynomial_comparison,
  bandwidth_comparison = bandwidth_comparison,
  rrp_facet_plot = rrp_facet_plot,
  economy_facet_plot = economy_facet_plot,
  ideology_facet_plot = ideology_facet_plot,
  size_facet_plot = size_facet_plot,
  placebo_plot = placebo_plot,
  
  # Section 6: Additional Analyses
  # Skip missing_patterns_plot if it wasn't created successfully
  # missing_patterns_plot = missing_patterns_plot,
  zero_by_parfam_plot = zero_by_parfam_plot,
  family_time_plot = family_time_plot,
  country_trends_plot = country_trends_plot,
  climate_events_plot = climate_events_plot,
  parl_status_dist = parl_status_dist,
  before_after_plot = before_after_plot,
  economy_scatter = economy_scatter,
  ridge_plot = ridge_plot
)

# Create a list of tables for the EDA section
eda_tables <- list(
  summary_wide = summary_wide,
  country_summary = country_summary,
  threshold_summary = threshold_summary,
  green_success_time = green_success_time,
  green_success_country = green_success_country,
  zero_prop = zero_prop,
  missing_data_overview = missing_data_overview,
  zero_inflation_analysis = zero_inflation_analysis
)

# Save plots to PDF
pdf("eda_plots.pdf", width = 12, height = 8)
for (i in seq_along(eda_plots)) {
  print(eda_plots[[i]])
}
dev.off()

# Save tables to CSV, with better error handling
for (i in seq_along(eda_tables)) {
  # Print what we're trying to save for debugging
  cat("Attempting to save table:", names(eda_tables)[i], "\n")
  
  # Use tryCatch to handle any errors that might occur
  tryCatch({
    # First check if the object is already a data frame
    if (is.data.frame(eda_tables[[i]])) {
      write.csv(eda_tables[[i]], 
               file = paste0("eda_table_", names(eda_tables)[i], ".csv"), 
               row.names = FALSE)
      cat("Successfully saved as data frame\n")
    } 
    # Special handling for correlation matrix
    else if (is.matrix(eda_tables[[i]])) {
      write.csv(as.data.frame(eda_tables[[i]]), 
               file = paste0("eda_table_", names(eda_tables)[i], ".csv"), 
               row.names = TRUE)
      cat("Successfully saved as matrix\n")
    }
    # Try to handle simple lists that could be converted to data frames
    else if (is.list(eda_tables[[i]]) && !is.data.frame(eda_tables[[i]])) {
      # Use capture.output to prevent error messages from printing
      capture.output({
        # Check if the list has equal length elements (could be made into a data frame)
        if (length(unique(sapply(eda_tables[[i]], length))) == 1) {
          df <- as.data.frame(eda_tables[[i]], stringsAsFactors = FALSE)
          write.csv(df, 
                   file = paste0("eda_table_", names(eda_tables)[i], ".csv"), 
                   row.names = FALSE)
          cat("Successfully converted list to data frame\n")
        } else {
          # For more complex lists, try to save as RDS instead
          saveRDS(eda_tables[[i]], 
                 file = paste0("eda_table_", names(eda_tables)[i], ".rds"))
          cat("Saved as RDS file instead of CSV\n")
        }
      }, type = "message")
    }
    # For any other type, save as RDS
    else {
      saveRDS(eda_tables[[i]], 
             file = paste0("eda_table_", names(eda_tables)[i], ".rds"))
      cat("Saved as RDS file (unknown type)\n")
    }
  }, error = function(e) {
    # If any error occurs, print message and continue to next table
    cat("ERROR saving table", names(eda_tables)[i], ":", e$message, "\n")
    # Try to save as RDS as a fallback
    tryCatch({
      saveRDS(eda_tables[[i]], 
             file = paste0("eda_table_", names(eda_tables)[i], ".rds"))
      cat("Saved as RDS file after error\n")
    }, error = function(e2) {
      cat("Could not save in any format:", e2$message, "\n")
    })
  })
}

# Create directory for EDA figures if it doesn't exist
eda_dir <- "C:/Users/Tobias D/OneDrive - Syddansk Universitet/Dokumenter/Speciale/Figurer-EDA"
if (!dir.exists(eda_dir)) {
  dir.create(eda_dir, recursive = TRUE)
}

# Set working directory to the new folder
old_dir <- getwd()  # Save current directory to restore later
setwd(eda_dir)

#------------------------------------------------------------
# 8. Create Individual Files for Each EDA Section
#------------------------------------------------------------

# Section 1: Descriptive Statistics
pdf("eda_section1_descriptive.pdf", width = 12, height = 8)
print(country_coverage_plot)
print(time_coverage_plot)
dev.off()

# Section 2: Outcome Variable Analysis
pdf("eda_section2_outcome.pdf", width = 12, height = 8)
print(climate_dist_plot)
print(climate_country_plot)
print(climate_time_plot)
print(components_plot)
print(zero_plot)
print(family_climate_plot)
dev.off()

# Create a simple histogram as a substitute for the density test
density_test_plot_substitute <- ggplot(final_dataset, aes(x = centered_lagged_pervote_samlet)) +
  geom_histogram(binwidth = 0.25, fill = "steelblue", color = "darkblue", alpha = 0.7) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red") +
  labs(
    title = "Distribution Around Threshold (Simple Histogram)",
    subtitle = "Note: rddensity test failed - showing basic histogram instead",
    x = "Centered Vote Share",
    y = "Count"
  ) +
  theme_minimal()

# Section 3: Running Variable and Treatment Analysis
pdf("eda_section3_running_var.pdf", width = 12, height = 8)
print(rv_dist_plot)
print(rdplotdensity)
print(seat_allocation_plot)
print(rile_balance)
print(gdp_balance)
print(unemp_balance)
print(green_time_plot)
dev.off()

# Section 4: Moderating Variables Analysis
pdf("eda_section4_moderating.pdf", width = 12, height = 8)
print(rrp_time_plot)
print(econ_indicators_plot)
print(ideology_dist_plot)
print(party_size_plot)
dev.off()

# Section 5: Preliminary Relationship Exploration
pdf("eda_section5_relationships.pdf", width = 12, height = 8)
print(bivariate_plot)
print(conditional_means_comparison)
print(polynomial_comparison)
print(bandwidth_comparison)
print(rrp_facet_plot)
print(economy_facet_plot)
print(ideology_facet_plot)
print(size_facet_plot)
print(placebo_plot)
dev.off()

# Create substitute for missing patterns plot if needed
if (!exists("missing_patterns_plot")) {
  # Create simple missing data visualization as substitute
  missing_data_viz <- vis_miss(final_dataset %>% 
                              select(miljø_afhængig, pervote_samlet, 
                                    lagged_pervote_samlet, rrp_i_p_lag1, 
                                    `GDP per capita growth`, Unemployment))
  missing_patterns_plot <- missing_data_viz
}

# Section 6: Additional Analyses
pdf("eda_section6_additional.pdf", width = 12, height = 8)
tryCatch({
  print(missing_patterns_plot)
}, error = function(e) {
  # If there's an error, print a message plot
  grid::grid.text("Missing patterns plot unavailable", 0.5, 0.5)
})
print(zero_by_parfam_plot)
print(family_time_plot)
print(country_trends_plot)
print(climate_events_plot)
print(parl_status_dist)
print(before_after_plot)
print(economy_scatter)
print(ridge_plot)
dev.off()

# Save tables to CSV with better error handling
for (i in seq_along(eda_tables)) {
  # Use tryCatch to handle any errors that might occur
  tryCatch({
    # First check if the object is already a data frame
    if (is.data.frame(eda_tables[[i]])) {
      write.csv(eda_tables[[i]], 
               file = paste0("eda_table_", names(eda_tables)[i], ".csv"), 
               row.names = FALSE)
    } 
    # Special handling for correlation matrix
    else if (is.matrix(eda_tables[[i]])) {
      write.csv(as.data.frame(eda_tables[[i]]), 
               file = paste0("eda_table_", names(eda_tables)[i], ".csv"), 
               row.names = TRUE)
    }
    # Try to handle simple lists that could be converted to data frames
    else if (is.list(eda_tables[[i]]) && !is.data.frame(eda_tables[[i]])) {
      # Use capture.output to prevent error messages from printing
      capture.output({
        # Check if the list has equal length elements (could be made into a data frame)
        if (length(unique(sapply(eda_tables[[i]], length))) == 1) {
          df <- as.data.frame(eda_tables[[i]], stringsAsFactors = FALSE)
          write.csv(df, 
                   file = paste0("eda_table_", names(eda_tables)[i], ".csv"), 
                   row.names = FALSE)
        } else {
          # For more complex lists, try to save as RDS instead
          saveRDS(eda_tables[[i]], 
                 file = paste0("eda_table_", names(eda_tables)[i], ".rds"))
        }
      }, type = "message")
    }
    # For any other type, save as RDS
    else {
      saveRDS(eda_tables[[i]], 
             file = paste0("eda_table_", names(eda_tables)[i], ".rds"))
    }
  }, error = function(e) {
    # If any error occurs, try to save as RDS as a fallback
    tryCatch({
      saveRDS(eda_tables[[i]], 
             file = paste0("eda_table_", names(eda_tables)[i], ".rds"))
    }, error = function(e2) {
      # If that fails too, write the error to a text file
      writeLines(paste("Error saving table", names(eda_tables)[i], ":", e2$message), 
                con = paste0("eda_table_", names(eda_tables)[i], "_error.txt"))
    })
  })
}

# Save all individual plots as PNG files for easier viewing
for (plot_name in names(eda_plots)) {
  if (exists(plot_name)) {
    tryCatch({
      plot_obj <- get(plot_name)
      ggsave(
        filename = paste0(plot_name, ".png"),
        plot = plot_obj,
        width = 10,
        height = 6,
        dpi = 300
      )
    }, error = function(e) {
      # If there's an error, write it to a log file
      writeLines(paste("Error saving plot", plot_name, ":", e$message), 
                con = paste0(plot_name, "_error.txt"))
    })
  }
}

# Create a single combined PDF with all plots
pdf("all_eda_plots.pdf", width = 12, height = 8)
for (plot_name in names(eda_plots)) {
  if (exists(plot_name)) {
    tryCatch({
      plot_obj <- get(plot_name)
      print(plot_obj)
    }, error = function(e) {
      # If there's an error, print a message in the PDF
      grid::grid.text(paste("Error with plot:", plot_name), 0.5, 0.5)
    })
  }
}
dev.off()

# Restore original working directory
setwd(old_dir)

# Print confirmation message
cat("All EDA figures and tables have been saved to:", eda_dir, "\n")
```

#View(final_dataset %>% dplyr::select(countryname, country, edate, party, miljø_afhængig, miljø_afhængig_alt,  per416, per501, per410, lagged_i_parlament, centered_lagged_pervote_samlet))



# 2.1 Robusthedstest af Miljø Afhængig
```{r Robusthedstest af Miljø Afhængig}
# Tilføj KDE til robusthedsanalyse
library(ggplot2)

# 1. KDE for hele datasættet
kde_full <- density(clean_data$miljø_afhængig)
plot(kde_full, main="KDE for hele datasættet", 
     xlab="Miljø Afhængig Variable")

# 2. KDE opdelt efter side af tærsklen
kde_below_threshold <- density(clean_data$miljø_afhængig[clean_data$centered_lagged_pervote_samlet < 0])
kde_above_threshold <- density(clean_data$miljø_afhængig[clean_data$centered_lagged_pervote_samlet >= 0])

# Plot KDE for begge sider af tærsklen
plot(kde_below_threshold, col="blue", main="KDE opdelt efter tærskel", 
     xlab="Miljø Afhængig Variable")
lines(kde_above_threshold, col="red")
legend("topright", legend=c("Under tærskel", "Over tærskel"), 
        col=c("blue", "red"), lty=1)

# 3. Statistisk test for forskel i fordelinger
# Kernal density test (approximate)
library(stats)
ks_test <- ks.test(
  clean_data$miljø_afhængig[clean_data$centered_lagged_pervote_samlet < 0],
  clean_data$miljø_afhængig[clean_data$centered_lagged_pervote_samlet >= 0]
)
print(ks_test)

# 4. ggplot visualisering med facet
ggplot(clean_data, aes(x = miljø_afhængig)) +
  geom_density(aes(fill = centered_lagged_pervote_samlet >= 0), alpha = 0.5) +
  facet_wrap(~ (centered_lagged_pervote_samlet >= 0)) +
  labs(title = "KDE fordeling på begge sider af tærsklen",
       x = "Miljø Afhængig Variable",
       y = "Tæthed") +
  theme_minimal()

# 5. Tilføj bootstrap konfidensintervaller for KDE
library(boot)

# Funktion til at beregne KDE
kde_boot_function <- function(data, indices) {
  d <- density(data[indices])
  return(d$y)
}

# Bootstrap KDE
boot_result <- boot(clean_data$miljø_afhængig, 
                    statistic = kde_boot_function, 
                    R = 1000)

# Plot KDE med bootstrap konfidensintervaller
plot(kde_full, main="KDE med Bootstrap Konfidensintervaller")
lines(kde_full$x, apply(boot_result$t, 2, quantile, probs = 0.025), col = "red", lty = 2)
lines(kde_full$x, apply(boot_result$t, 2, quantile, probs = 0.975), col = "red", lty = 2)
```


# 3. Testing the Five Hypotheses

## 3.1 H1: When green parties enter parliament, climate focus in mainstream parties decreases

```{r h1_analysis}
# ============================================================================
# H1 Analysis: Effect of Green Party Entry on Climate Focus
# ============================================================================


# ============================================================================
# 1. Basic Linear Models with Regular and Clustered Standard Errors
# ============================================================================

# Simple linear model
h1_model_simple <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet + lagged_i_parlament,
                     data = final_dataset)
summary(h1_model_simple)

# Interaction model
h1_model_interaction <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                          data = final_dataset)
summary(h1_model_interaction)

# Clustered standard errors (by party)
if (exists("coeftest.cluster_grøn")) {
  data_used <- na.omit(final_dataset[, c("miljø_afhængig", "centered_lagged_pervote_samlet", 
                                      "lagged_i_parlament", "party", "edate", "country")])
  
  h1_robust <- coeftest.cluster_grøn(
    data = data_used,
    fm = h1_model_interaction,
    cluster1 = data_used$party  # Pass the vector directly
  )
  print(h1_robust)
  
  # Double-clustered standard errors (by party and election date)
  h1_robust_double <- summary.cluster_grøn(
    obj = h1_model_interaction, 
    data = data_used, 
    cluster1 = "party", 
    cluster2 = "edate"
  )
  print(h1_robust_double)
}

# ============================================================================
# 2. Two-Part Model for Zero-Inflated Distribution
# ============================================================================

# Part 1: Logit model for predicting non-zero climate focus
h1_binary <- glm(I(miljø_afhængig != 0) ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                family = binomial, data = final_dataset)
summary(h1_binary)

# Part 2: Linear model on non-zero values only
h1_continuous <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                   data = subset(final_dataset, miljø_afhængig != 0))
summary(h1_continuous)

# ============================================================================
# 3. Quantile Regression Analysis
# ============================================================================

# Median regression (tau = 0.5)
h1_median_rq <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                  tau = 0.5, data = final_dataset)
summary(h1_median_rq)

# Multiple quantiles to examine heterogeneous effects
h1_multi_quantile <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                       tau = c(0.25, 0.5, 0.75), data = final_dataset)
summary(h1_multi_quantile)

# Generate quantile plot to visualize coefficient variation across quantiles
h1_quantile_plot <- plot(summary(rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                                   tau = seq(0.1, 0.9, by = 0.1), data = final_dataset)))

# Save quantile plot
pdf("h1_quantile_coefficients.pdf", width = 10, height = 8)
print(h1_quantile_plot)
dev.off()

# ============================================================================
# 4. Robust Regression (less sensitive to outliers and non-normal distributions)
# ============================================================================

# MM-type robust regression
h1_robust_reg <- rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                    data = final_dataset, method = "MM")
summary(h1_robust_reg)

# ============================================================================
# 5. Enhanced RDD Analysis
# ============================================================================

# Multi-polynomial RDD with custom function
if (exists("rd.base_grøn")) {
  rd.multic_h1 <- rd.base_grøn(
    data = final_dataset,
    force.var = 'centered_lagged_pervote_samlet',
    yvar = 'miljø_afhængig',
    seat.identifier = 'factor_lagged_i_parlament',
    fixed.effects = 'country',
    clust1 = 'party',
    clust2 = 'edate',
    polynomials = c(1, 2, 3, 4),
    bws = NULL
  )
  print(rd.multic_h1)
}

# Robustness analysis with different bandwidths
covariates_to_use <- c("country", "edate")
results_df_h1 <- run_rdd_robustness(
  data = final_dataset,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = c(1, 1.5, 2, 2.5, 3),
  polynomials = c(1, 2, 3, 4),
  covariates = covariates_to_use,
  group_label = "H1 - Grøn parti effekt"
)
print(results_df_h1)

# Gem som CSV-fil i din arbejdsmappe
write.csv(results_df_h1, "results_df_h1.csv", row.names = FALSE)

# Create a nice table with knitr
if (requireNamespace("knitr", quietly = TRUE)) {
  print(knitr::kable(results_df_h1, 
                    caption = "H1: Robusthedstest med forskellige båndbredder og polynomiegrader"))
}

# ============================================================================
# 6. Enhanced rdrobust Analysis (with various specifications)
# ============================================================================

# Standard RDD approach with optimal bandwidth
h1_rdd <- rdrobust(
  y = final_dataset$miljø_afhængig,
  x = final_dataset$centered_lagged_pervote_samlet,
  c = 0,
  p = 1,  # linear polynomial
  kernel = "triangular",
  bwselect = "mserd"  # MSE-optimal bandwidth
)
summary(h1_rdd)

# RDD with bias correction and robust standard errors
h1_rdd_robust <- rdrobust(
  y = final_dataset$miljø_afhængig,
  x = final_dataset$centered_lagged_pervote_samlet,
  c = 0,
  p = 1,  # linear polynomial
  kernel = "triangular",
  bwselect = "mserd"  # MSE-optimal bandwidth
  # Fjernet bias.correction og robust argumenter, da de ikke understøttes korrekt
)
summary(h1_rdd_robust)

# RDD with covariates for increased precision
h1_rdd_covs <- rdrobust(
  y = final_dataset$miljø_afhængig,
  x = final_dataset$centered_lagged_pervote_samlet,
  c = 0,
  covs = model.matrix(~ country + edate, data = final_dataset)[,-1],  # Covariates without intercept
  p = 1,
  kernel = "triangular",
  bwselect = "mserd"
)
summary(h1_rdd_covs)

# Alternative kernel function for robustness check
h1_rdd_uniform <- rdrobust(
  y = final_dataset$miljø_afhængig,
  x = final_dataset$centered_lagged_pervote_samlet,
  c = 0,
  p = 1,
  kernel = "uniform",  # Uniform kernel function
  bwselect = "mserd"
)
summary(h1_rdd_uniform)

# Focused analysis close to threshold
h1_rdd_local <- rdrobust(
  y = final_dataset$miljø_afhængig,
  x = final_dataset$centered_lagged_pervote_samlet,
  c = 0,
  h = 1,  # 1 percentage point around threshold
  p = 1
)
summary(h1_rdd_local)

# Alternative RDD specifications
h1_rdd_alt <- rdrobust(
  y = final_dataset$miljø_afhængig,
  x = final_dataset$centered_lagged_pervote_samlet,
  c = 0,
  p = 2,  # quadratic polynomial
  kernel = "triangular",
  h = 2  # fixed bandwidth
)
summary(h1_rdd_alt)

# ============================================================================
# 7. Instrumental Variables Estimation
# ============================================================================

# IV estimation (treating lagged_i_parlament as endogenous)
h1_iv <- ivreg(miljø_afhængig ~ lagged_i_parlament | centered_lagged_pervote_samlet, 
              data = final_dataset)
summary(h1_iv, diagnostics = TRUE)

# ============================================================================
# 8. Visual Confirmation and RDD Plots
# ============================================================================

# Standard RDD plot
h1_plot_rdd <- plot_rdd(
  data = final_dataset,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position",
  title = "H1: Effect of Green Party Entry on Mainstream Climate Focus"
)
print(h1_plot_rdd)

# Create an RDD plot specifically for zero vs non-zero values
# Alternativ tilgang uden color_by argument

# Først opdel data i to grupper
zero_data <- subset(final_dataset, miljø_afhængig == 0)
nonzero_data <- subset(final_dataset, miljø_afhængig != 0)

# Plot standard RDD for begge grupper separat
h1_plot_zeros <- plot_rdd(
  data = zero_data,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position (Zeros Only)",
  title = "H1: RDD Plot for Zero Climate Positions"
)

h1_plot_nonzeros <- plot_rdd(
  data = nonzero_data,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position (Non-Zeros Only)",
  title = "H1: RDD Plot for Non-Zero Climate Positions"
)

# Vis plottene
print(h1_plot_zeros)
print(h1_plot_nonzeros)

# ============================================================================
# 9. Summary Table of All Models 
# ============================================================================



# Prepare models for comparison
models_list <- list(h1_model_interaction, h1_continuous, h1_median_rq, h1_robust_reg)
  
# Create stargazer output with p-values and custom significance levels
stargazer(models_list,
          type = "text",
          out = "h1_model_comparison_stargazer.html",
          star.cutoffs = c(0.1, 0.05, 0.01),  # Significance thresholds
          star.char = c("*", "**", "***"),  # Corresponding symbols
          column.labels = c("OLS (All)", "OLS (Non-Zero)", "Median Regression", "Robust Regression"),
          title = "Comparison of Different Modeling Approaches for H1",
          report=('vc*p'),
          covariate.labels = c("Grønne stemmer (centeret)", 
                               "Tidligere parlamentstilstand", 
                               "Interaktion: Grønne stemmer x Parlamentstilstand"),
          dep.var.labels = "miljø_afhængig"  # Ændrer også afhængig variabels label
)
  
```

## 3.2 H2: Radical right parties in parliament reduce climate focus in mainstream parties
```{r H2}
# ============================================================================
# 1. Data Preparation with Missing Values Handling
# ============================================================================

# Opdel data baseret på RRP status og fjern NA værdier
data_no_rrp <- na.omit(subset(clean_data, rrp_i_p_lag1 == 0))
data_with_rrp <- na.omit(subset(clean_data, rrp_i_p_lag1 == 1))

# Tjek sample størrelse
cat("Observations without RRP in parliament:", nrow(data_no_rrp), "\n")
cat("Observations with RRP in parliament:", nrow(data_with_rrp), "\n")

# ============================================================================
# 2. Systematisk RDD Analyse med forskellige parametre
# ============================================================================

# Definér kovariater, der skal kontrolleres for
covariates_to_use <- c("country", "edate")

# Kør systematisk robusthedsanalyse for begge grupper
results_df_no_rrp <- run_rdd_robustness(
  data = data_no_rrp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = c(1, 1.5, 2, 2.5, 3),
  polynomials = c(1, 2),  # Fokusér på lineære og kvadratiske modeller
  covariates = covariates_to_use,
  group_label = "Ingen RRP i parlament (lag1)"
)

results_df_with_rrp <- run_rdd_robustness(
  data = data_with_rrp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = c(1, 1.5, 2, 2.5, 3),
  polynomials = c(1, 2),  # Fokusér på lineære og kvadratiske modeller
  covariates = covariates_to_use,
  group_label = "RRP i parlament (lag1)"
)

# Kombinér resultaterne for at sammenligne direkte
combined_results <- rbind(results_df_no_rrp, results_df_with_rrp)
print(combined_results)

# Vis resultaterne i en pæn tabel
if (requireNamespace("knitr", quietly = TRUE)) {
  print(knitr::kable(combined_results, 
                    caption = "H2: Robusthedstest med forskellige båndbredder opdelt efter RRP-status (lag1)"))
}

# ============================================================================
# 3. Sammenligning af koefficienter og visualisering
# ============================================================================

# Sammenlign koefficienter på tværs af grupper visuelt
h2_comparison_plot <- compare_coefficient_stability(
  data_list = list(data_no_rrp, data_with_rrp),
  labels = c("Ingen højreradikale partier", "Højreradikale partier i parlament"),
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomial = 1,  # Lineær model for sammenligning
  covariates = c("country", "edate"),
  title = "H2: Effekt af grønne partier modereret af højreradikale partier"
)

# Vis sammenligningsplottet
print(h2_comparison_plot)

# ============================================================================
# 4. Visuel bekræftelse med standard RDD plots
# ============================================================================

# Plot 1: Standard RDD for No RRP
h2_plot_no_rrp <- plot_rdd(
  data = data_no_rrp,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position",
  title = "H2a: Klimafokus uden højreradikale partier i parlamentet (lag1)"
)
print(h2_plot_no_rrp)

# Plot 2: Standard RDD for With RRP
h2_plot_with_rrp <- plot_rdd(
  data = data_with_rrp,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position",
  title = "H2b: Klimafokus med højreradikale partier i parlamentet (lag1)"
)
print(h2_plot_with_rrp)

# Kombiner plots til sammenligning
if (requireNamespace("gridExtra", quietly = TRUE)) {
  gridExtra::grid.arrange(h2_plot_no_rrp, h2_plot_with_rrp, ncol = 2,
                         top = "Sammenligning af grøn partis effekt med/uden RRP i parlament (lag1)")
}

# Gem data bag de to plots
write.csv(h2_plot_no_rrp$data_no_rrp, "h2_plot_no_rrp_data.csv", row.names = FALSE)
write.csv(h2_plot_with_rrp$data_with_rrp, "h2_plot_with_rrp_data.csv", row.names = FALSE)

# ============================================================================
# 5. Alternativ OLS-tilgang for robusthed og interaktionseffekter
# ============================================================================

# OLS-model med tre-vejs interaktion for at teste moderationseffekten direkte
h2_model_3way <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament * rrp_i_p_lag1, 
                  data = clean_data)
summary(h2_model_3way)

# Udtræk koefficienttabel som data frame
results_df_h2 <- as.data.frame(summary(h2_model_3way)$coefficients)

# Tilføj signifikansstjerner
results_df_h2$Significance <- ""
results_df_h2$Significance[results_df_h2[,4] <= 0.1]  <- "*"
results_df_h2$Significance[results_df_h2[,4] <= 0.05] <- "**"
results_df_h2$Significance[results_df_h2[,4] <= 0.01] <- "***"

# Gem som CSV-fil
write.csv(results_df_h2, "h2_model_3way_results.csv", row.names = TRUE)


# Visuel sammenligning af interaktionseffekter med forudsigelser fra modellen
if (requireNamespace("ggplot2", quietly = TRUE) && requireNamespace("tidyr", quietly = TRUE)) {
  # Lav forudsigelser baseret på modellen
  pred_data <- expand.grid(
    rrp_i_p_lag1 = c(0, 1),
    centered_lagged_pervote_samlet = seq(-5, 5, by = 0.5),
    lagged_i_parlament = c(0, 1)
  )
  
  pred_data$predicted <- predict(h2_model_3way, newdata = pred_data)
  
  # Tilføj faktorer for pænere labels
  pred_data$rrp_status <- factor(pred_data$rrp_i_p_lag1, 
                              levels = c(0, 1),
                              labels = c("Ingen RRP i parlament (lag1)", "RRP i parlament (lag1)"))
  
  pred_data$gp_status <- factor(pred_data$lagged_i_parlament,
                             levels = c(0, 1),
                             labels = c("Grønt parti uden sæde", "Grønt parti med sæde"))
  
  # Plot interaktionen
  h2_interaction_plot <- ggplot2::ggplot(pred_data, ggplot2::aes(x = centered_lagged_pervote_samlet, 
                                                           y = predicted, 
                                                           color = gp_status, 
                                                           linetype = gp_status)) +
    ggplot2::geom_line() +
    ggplot2::facet_wrap(~ rrp_status) +
    ggplot2::geom_vline(xintercept = 0, linetype = "dashed") +
    ggplot2::theme_minimal() +
    ggplot2::labs(
      title = "Forudsagt klimaposition baseret på trevejs-interaktionsmodel (lag1)",
      x = "Grønt partis stemmeandel (centreret ved tærskel)",
      y = "Forudsagt klimaposition",
      color = "Grønt parti status",
      linetype = "Grønt parti status"
    )
  
  print(h2_interaction_plot)
}

# ============================================================================
# 6. Analyse af zero vs non-zero values (Two-part model tilgang)
# ============================================================================

# Split data based on zero/non-zero outcome
zero_data_no_rrp <- subset(data_no_rrp, miljø_afhængig == 0)
nonzero_data_no_rrp <- subset(data_no_rrp, miljø_afhængig != 0)
zero_data_with_rrp <- subset(data_with_rrp, miljø_afhængig == 0)
nonzero_data_with_rrp <- subset(data_with_rrp, miljø_afhængig != 0)

# Summary statistics 
cat("Zero values proportion without RRP:", nrow(zero_data_no_rrp)/nrow(data_no_rrp), "\n")
cat("Zero values proportion with RRP:", nrow(zero_data_with_rrp)/nrow(data_with_rrp), "\n")

# Two-part model - Logit for probability of non-zero
h2_binary_no_rrp <- glm(I(miljø_afhængig != 0) ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                      family = binomial, data = data_no_rrp)
h2_binary_with_rrp <- glm(I(miljø_afhængig != 0) ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                        family = binomial, data = data_with_rrp)

# Two-part model - OLS on non-zero values
h2_continuous_no_rrp <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                        data = nonzero_data_no_rrp)
h2_continuous_with_rrp <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                          data = nonzero_data_with_rrp)

# Sammenfattet tabel af resultater
two_part_summary <- data.frame(
  Model = c("Uden RRP (Probability)", "Med RRP (Probability)", 
           "Uden RRP (Intensity)", "Med RRP (Intensity)"),
  Estimate = c(
    coef(h2_binary_no_rrp)["lagged_i_parlament"],
    coef(h2_binary_with_rrp)["lagged_i_parlament"],
    coef(h2_continuous_no_rrp)["lagged_i_parlament"],
    coef(h2_continuous_with_rrp)["lagged_i_parlament"]
  ),
  SE = c(
    summary(h2_binary_no_rrp)$coefficients["lagged_i_parlament", "Std. Error"],
    summary(h2_binary_with_rrp)$coefficients["lagged_i_parlament", "Std. Error"],
    summary(h2_continuous_no_rrp)$coefficients["lagged_i_parlament", "Std. Error"],
    summary(h2_continuous_with_rrp)$coefficients["lagged_i_parlament", "Std. Error"]
  ),
  P_value = c(
    summary(h2_binary_no_rrp)$coefficients["lagged_i_parlament", "Pr(>|z|)"],
    summary(h2_binary_with_rrp)$coefficients["lagged_i_parlament", "Pr(>|z|)"],
    summary(h2_continuous_no_rrp)$coefficients["lagged_i_parlament", "Pr(>|t|)"],
    summary(h2_continuous_with_rrp)$coefficients["lagged_i_parlament", "Pr(>|t|)"]
  )
)

# Format p-values and add significance stars
two_part_summary$Significance <- ifelse(two_part_summary$P_value < 0.001, "***", 
                                       ifelse(two_part_summary$P_value < 0.01, "**",
                                             ifelse(two_part_summary$P_value < 0.05, "*",
                                                   ifelse(two_part_summary$P_value < 0.1, ".", ""))))

print(two_part_summary)

# ============================================================================
# 7. Robust Regression for robustness check
# ============================================================================

# MASS package for robust regression
h2_robust_reg_no_rrp <- MASS::rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                               data = data_no_rrp, method = "MM")
h2_robust_reg_with_rrp <- MASS::rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                                 data = data_with_rrp, method = "MM")

# Print summaries
summary(h2_robust_reg_no_rrp)
summary(h2_robust_reg_with_rrp)

# ============================================================================
# 8. Sammenligning af resultater fra alle metoder
# ============================================================================

# Create a data frame for key results from all methods
key_results <- data.frame(
  Method = c(
    "RDD (p=1, bw=2) Uden RRP", 
    "RDD (p=1, bw=2) Med RRP",
    "OLS Interaction",
    "Two-part (Probability) Uden RRP",
    "Two-part (Probability) Med RRP",
    "Two-part (Intensity) Uden RRP",
    "Two-part (Intensity) Med RRP",
    "Robust Regression Uden RRP",
    "Robust Regression Med RRP"
  ),
  Estimate = c(
    as.numeric(results_df_no_rrp$LATE[results_df_no_rrp$Polynomial == 1 & results_df_no_rrp$Bandwidth == 2]),
    as.numeric(results_df_with_rrp$LATE[results_df_with_rrp$Polynomial == 1 & results_df_with_rrp$Bandwidth == 2]),
    coef(h2_model_3way)["lagged_i_parlament:rrp_i_p_lag1"],  # Interaktionsleddet
    coef(h2_binary_no_rrp)["lagged_i_parlament"],
    coef(h2_binary_with_rrp)["lagged_i_parlament"],
    coef(h2_continuous_no_rrp)["lagged_i_parlament"],
    coef(h2_continuous_with_rrp)["lagged_i_parlament"],
    coef(h2_robust_reg_no_rrp)["lagged_i_parlament"],
    coef(h2_robust_reg_with_rrp)["lagged_i_parlament"]
  )
)

# Format as nice table
if (requireNamespace("knitr", quietly = TRUE)) {
  print(knitr::kable(key_results, 
                    caption = "H2: Sammenligning af resultater fra forskellige metoder"))
}
```


## 3.3

```{r h3_analysis}
# ============================================================================
# PART 1: ANALYSIS WITH GDP GROWTH AS MODERATOR
# ============================================================================

# Opdel data baseret på BNP-vækst
clean_data_high_gdp <- subset(final_dataset, high_gdp_growth == 1)
clean_data_low_gdp <- subset(final_dataset, high_gdp_growth == 0)

# ============================================================================
# 1.1 Basic Linear Models with GDP Growth
# ============================================================================

# Simple linear model
h3_gdp_model_simple <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet + lagged_i_parlament,
                     data = final_dataset)
summary(h3_gdp_model_simple)

# Interaction model med BNP-vækst
h3_gdp_interaction <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament * high_gdp_growth, 
                      data = final_dataset)
summary(h3_gdp_interaction)

# Clustered standard errors (by party)
if (exists("coeftest.cluster_grøn")) {
  data_used <- na.omit(final_dataset[, c("miljø_afhængig", "centered_lagged_pervote_samlet", 
                                     "lagged_i_parlament", "party", "edate", "country", "high_gdp_growth")])
  
  # Brug data_used i stedet for final_dataset
  h3_gdp_robust <- coeftest.cluster_grøn(
    data = data_used,
    fm = h3_gdp_interaction,
    cluster1 = data_used$party  # Pass the vector directly
  )
  print(h3_gdp_robust)
  
  # Double-clustered standard errors (by party and election date)
  h3_gdp_robust_double <- summary.cluster_grøn(
    obj = h3_gdp_interaction, 
    data = data_used, 
    cluster1 = "party", 
    cluster2 = "edate"
  )
  print(h3_gdp_robust_double)
}

# ============================================================================
# 1.2 Two-Part Model for GDP Growth Subsets
# ============================================================================

# HIGH GDP GROWTH: Two-Part Model
# Part 1: Logit model for predicting non-zero climate focus
h3_binary_high_gdp <- glm(I(miljø_afhængig != 0) ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                       family = binomial, data = clean_data_high_gdp)
summary(h3_binary_high_gdp)

# Part 2: Linear model on non-zero values only
h3_continuous_high_gdp <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                          data = subset(clean_data_high_gdp, miljø_afhængig != 0))
summary(h3_continuous_high_gdp)

# LOW GDP GROWTH: Two-Part Model
# Part 1: Logit model for predicting non-zero climate focus
h3_binary_low_gdp <- glm(I(miljø_afhængig != 0) ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                      family = binomial, data = clean_data_low_gdp)
summary(h3_binary_low_gdp)

# Part 2: Linear model on non-zero values only
h3_continuous_low_gdp <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                         data = subset(clean_data_low_gdp, miljø_afhængig != 0))
summary(h3_continuous_low_gdp)

# ============================================================================
# 1.3 Quantile Regression for GDP Growth Subsets
# ============================================================================

# HIGH GDP GROWTH: Quantile Regression
# Median regression
h3_median_rq_high_gdp <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                         tau = 0.5, data = clean_data_high_gdp)
summary(h3_median_rq_high_gdp)

# Multiple quantiles
h3_multi_quantile_high_gdp <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                              tau = c(0.25, 0.5, 0.75), data = clean_data_high_gdp)
summary(h3_multi_quantile_high_gdp)

# Generate plot for coefficients across quantiles
h3_quantile_plot_high_gdp <- plot(summary(rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                                         tau = seq(0.1, 0.9, by = 0.1), data = clean_data_high_gdp)))

# LOW GDP GROWTH: Quantile Regression
# Median regression
h3_median_rq_low_gdp <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                        tau = 0.5, data = clean_data_low_gdp)
summary(h3_median_rq_low_gdp)

# Multiple quantiles
h3_multi_quantile_low_gdp <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                             tau = c(0.25, 0.5, 0.75), data = clean_data_low_gdp)
summary(h3_multi_quantile_low_gdp)

# Generate plot for coefficients across quantiles
h3_quantile_plot_low_gdp <- plot(summary(rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                                        tau = seq(0.1, 0.9, by = 0.1), data = clean_data_low_gdp)))

# Save quantile plots
pdf("h3_quantile_coefficients_high_gdp.pdf", width = 10, height = 8)
print(h3_quantile_plot_high_gdp)
dev.off()

pdf("h3_quantile_coefficients_low_gdp.pdf", width = 10, height = 8)
print(h3_quantile_plot_low_gdp)
dev.off()

# ============================================================================
# 1.4 Robust Regression for GDP Growth Subsets
# ============================================================================

# Robust regression for full sample with GDP interaction
h3_robust_reg_gdp <- rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament * high_gdp_growth, 
                      data = final_dataset, method = "MM")
summary(h3_robust_reg_gdp)

# HIGH GDP GROWTH: Robust Regression
h3_robust_reg_high_gdp <- rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                           data = clean_data_high_gdp, method = "MM")
summary(h3_robust_reg_high_gdp)

# LOW GDP GROWTH: Robust Regression
h3_robust_reg_low_gdp <- rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                          data = clean_data_low_gdp, method = "MM")
summary(h3_robust_reg_low_gdp)

# ============================================================================
# 1.5 RDD Analysis for GDP Growth Subsets
# ============================================================================

# Multi-polynomial RDD with custom function
if (exists("rd.base_grøn")) {
  # Høj BNP-vækst sample
  rd.multic_h3_high_gdp <- rd.base_grøn(
    data = clean_data_high_gdp,
    force.var = 'centered_lagged_pervote_samlet',
    yvar = 'miljø_afhængig',
    seat.identifier = 'factor_lagged_i_parlament',
    fixed.effects = 'country',
    clust1 = 'party',
    clust2 = 'edate',
    polynomials = c(1, 2, 3, 4),
    bws = NULL
  )
  print(rd.multic_h3_high_gdp)
  
  # Lav BNP-vækst sample
  rd.multic_h3_low_gdp <- rd.base_grøn(
    data = clean_data_low_gdp,
    force.var = 'centered_lagged_pervote_samlet',
    yvar = 'miljø_afhængig',
    seat.identifier = 'factor_lagged_i_parlament',
    fixed.effects = 'country',
    clust1 = 'party',
    clust2 = 'edate',
    polynomials = c(1, 2, 3, 4),
    bws = NULL
  )
  print(rd.multic_h3_low_gdp)
}

# Robustness analysis med forskellige båndbredder
covariates_to_use <- c("country", "edate")

# Kør robusthedsanalysen på høj BNP-vækst data
results_df_h3_high_gdp <- run_rdd_robustness(
  data = clean_data_high_gdp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = c(1, 1.5, 2, 2.5, 3),
  polynomials = c(1, 2, 3, 4),
  covariates = covariates_to_use,
  group_label = "H3 - Høj BNP-vækst"
)

# Kør robusthedsanalysen på lav BNP-vækst data
results_df_h3_low_gdp <- run_rdd_robustness(
  data = clean_data_low_gdp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = c(1, 1.5, 2, 2.5, 3),
  polynomials = c(1, 2, 3, 4),
  covariates = covariates_to_use,
  group_label = "H3 - Lav BNP-vækst"
)

# Vis resultater
print(results_df_h3_high_gdp)
print(results_df_h3_low_gdp)

# Kombiner resultater i en pæn tabel med knitr
if (requireNamespace("knitr", quietly = TRUE)) {
  combined_results_gdp <- rbind(results_df_h3_high_gdp, results_df_h3_low_gdp)
  
  print(knitr::kable(combined_results_gdp, 
                    caption = "H3: Robusthedstest opdelt efter BNP-vækst"))
}

# ============================================================================
# 1.6 Enhanced rdrobust Analysis for GDP Growth Subsets - FIXED
# ============================================================================

# HIGH GDP GROWTH: Standard rdrobust (without covariates)
h3_rdd_high_gdp <- rdrobust(
  y = clean_data_high_gdp$miljø_afhængig,
  x = clean_data_high_gdp$centered_lagged_pervote_samlet,
  c = 0,
  p = 1,  # linear polynomial
  kernel = "triangular",
  bwselect = "mserd"  # MSE-optimal bandwidth
)
summary(h3_rdd_high_gdp)

# HIGH GDP GROWTH: rdrobust with simpler covariates and fixed bandwidth
tryCatch({
  # Try with fixed bandwidth first
  h3_rdd_covs_high_gdp <- rdrobust(
    y = clean_data_high_gdp$miljø_afhængig,
    x = clean_data_high_gdp$centered_lagged_pervote_samlet,
    c = 0,
    covs = model.matrix(~ factor(country), data = clean_data_high_gdp)[,-1],  # Simplified covariate
    p = 1,
    kernel = "triangular",
    h = 2  # Use fixed bandwidth instead of optimal selection
  )
  summary(h3_rdd_covs_high_gdp)
}, error = function(e) {
  cat("Fixed bandwidth with covariates still failed:", e$message, "\n")
  cat("Trying with just country fixed effects and no other covariates...\n")
  
  # Try with even simpler approach - just country FE
  tryCatch({
    h3_rdd_country_high_gdp <- rdrobust(
      y = clean_data_high_gdp$miljø_afhængig,
      x = clean_data_high_gdp$centered_lagged_pervote_samlet,
      c = 0,
      covs = model.matrix(~ factor(country), data = clean_data_high_gdp)[,-1],
      p = 1,
      kernel = "uniform",  # Try different kernel
      h = 3  # Try even wider bandwidth
    )
    summary(h3_rdd_country_high_gdp)
  }, error = function(e2) {
    cat("Even simpler approach failed:", e2$message, "\n")
    cat("Proceeding with analysis without covariates for high GDP growth subset\n")
  })
})

# LOW GDP GROWTH: rdrobust with error handling
tryCatch({
  h3_rdd_low_gdp <- rdrobust(
    y = clean_data_low_gdp$miljø_afhængig,
    x = clean_data_low_gdp$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,
    kernel = "triangular",
    bwselect = "mserd"
  )
  summary(h3_rdd_low_gdp)
}, error = function(e) {
  cat("Note: Kunne ikke beregne RDD for lav BNP-vækst gruppe pga:", e$message, "\n")
  cat("Dette kan skyldes utilstrækkelige data eller høj kollinearitet i subset med lav BNP-vækst.\n")
  
  # Try with fixed bandwidth
  tryCatch({
    cat("Forsøger med fast båndbredde i stedet...\n")
    h3_rdd_low_gdp_alt <- rdrobust(
      y = clean_data_low_gdp$miljø_afhængig,
      x = clean_data_low_gdp$centered_lagged_pervote_samlet,
      c = 0,
      p = 1,
      kernel = "triangular",
      h = 2
    )
    summary(h3_rdd_low_gdp_alt)
  }, error = function(e2) {
    cat("Alternativ specifikation fejlede også:", e2$message, "\n")
  })
})

# ============================================================================
# 1.7 Separate Analysis for Zero and Non-Zero Values by GDP Growth
# ============================================================================

# HIGH GDP GROWTH: Split data into zero and non-zero values
zero_data_high_gdp <- subset(clean_data_high_gdp, miljø_afhængig == 0)
nonzero_data_high_gdp <- subset(clean_data_high_gdp, miljø_afhængig != 0)

# LOW GDP GROWTH: Split data into zero and non-zero values
zero_data_low_gdp <- subset(clean_data_low_gdp, miljø_afhængig == 0)
nonzero_data_low_gdp <- subset(clean_data_low_gdp, miljø_afhængig != 0)

# RDD for non-zero values only (HIGH GDP GROWTH)
tryCatch({
  h3_rdd_nonzero_high_gdp <- rdrobust(
    y = nonzero_data_high_gdp$miljø_afhængig,
    x = nonzero_data_high_gdp$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,
    kernel = "triangular",
    bwselect = "mserd"
  )
  summary(h3_rdd_nonzero_high_gdp)
}, error = function(e) {
  cat("Note: RDD for non-zero values in high GDP group failed:", e$message, "\n")
  # Try with fixed bandwidth
  tryCatch({
    h3_rdd_nonzero_high_gdp_fixed <- rdrobust(
      y = nonzero_data_high_gdp$miljø_afhængig,
      x = nonzero_data_high_gdp$centered_lagged_pervote_samlet,
      c = 0,
      p = 1,
      kernel = "triangular",
      h = 2
    )
    summary(h3_rdd_nonzero_high_gdp_fixed)
  }, error = function(e2) {
    cat("Fixed bandwidth also failed:", e2$message, "\n")
  })
})

# RDD for non-zero values only (LOW GDP GROWTH)
tryCatch({
  h3_rdd_nonzero_low_gdp <- rdrobust(
    y = nonzero_data_low_gdp$miljø_afhængig,
    x = nonzero_data_low_gdp$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,
    kernel = "triangular",
    bwselect = "mserd"
  )
  summary(h3_rdd_nonzero_low_gdp)
}, error = function(e) {
  cat("Note: RDD for non-zero values in low GDP group failed:", e$message, "\n")
  # Try with fixed bandwidth
  tryCatch({
    h3_rdd_nonzero_low_gdp_fixed <- rdrobust(
      y = nonzero_data_low_gdp$miljø_afhængig,
      x = nonzero_data_low_gdp$centered_lagged_pervote_samlet,
      c = 0,
      p = 1,
      kernel = "triangular",
      h = 2
    )
    summary(h3_rdd_nonzero_low_gdp_fixed)
  }, error = function(e2) {
    cat("Fixed bandwidth also failed:", e2$message, "\n")
  })
})

# ============================================================================
# 1.8 Visual Confirmation and RDD Plots for GDP Growth
# ============================================================================

# Visuel bekræftelse - høj BNP-vækst
h3_plot_high_gdp <- plot_rdd(
  data = clean_data_high_gdp,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Grønt partis stemmeandel (centreret)",
  y_label = "Klimaposition",
  title = "H3: Effekt ved høj BNP-vækst"
)
print(h3_plot_high_gdp)

# Visuel bekræftelse - lav BNP-vækst
h3_plot_low_gdp <- plot_rdd(
  data = clean_data_low_gdp,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Grønt partis stemmeandel (centreret)",
  y_label = "Klimaposition",
  title = "H3: Effekt ved lav BNP-vækst"
)
print(h3_plot_low_gdp)

# Plots for non-zero values only - high GDP
h3_plot_nonzero_high_gdp <- plot_rdd(
  data = nonzero_data_high_gdp,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Grønt partis stemmeandel (centreret)",
  y_label = "Klimaposition (kun ikke-nul værdier)",
  title = "H3: Effekt ved høj BNP-vækst (kun ikke-nul værdier)"
)
print(h3_plot_nonzero_high_gdp)

# Plots for non-zero values only - low GDP
h3_plot_nonzero_low_gdp <- plot_rdd(
  data = nonzero_data_low_gdp,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Grønt partis stemmeandel (centreret)",
  y_label = "Klimaposition (kun ikke-nul værdier)",
  title = "H3: Effekt ved lav BNP-vækst (kun ikke-nul værdier)"
)
print(h3_plot_nonzero_low_gdp)

# Kombiner plots hvis gridExtra er tilgængelig
if (requireNamespace("gridExtra", quietly = TRUE)) {
  gridExtra::grid.arrange(h3_plot_high_gdp, h3_plot_low_gdp, ncol = 2,
                         top = "H3: Effekt opdelt efter BNP-vækst")
  
  gridExtra::grid.arrange(h3_plot_nonzero_high_gdp, h3_plot_nonzero_low_gdp, ncol = 2,
                         top = "H3: Effekt opdelt efter BNP-vækst (kun ikke-nul værdier)")
}

# ============================================================================
# PART 2: ANALYSIS WITH COMPOSITE ECONOMIC INDICATOR - UPDATED WITH FIXES
# ============================================================================

# Split data based on economic condition
clean_data_good_economy <- na.omit(subset(final_dataset, good_economy == 1))
clean_data_bad_economy <- na.omit(subset(final_dataset, good_economy == 0))

# ============================================================================
# 2.1 Basic Linear Models with Economic Index
# ============================================================================

# Simple linear model
h3_model_simple <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet + lagged_i_parlament,
                     data = final_dataset)
summary(h3_model_simple)

# Interaction model with economic factors
h3_model_interaction <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament * good_economy, 
                        data = final_dataset)
summary(h3_model_interaction)

# Clustered standard errors (by party)
if (exists("coeftest.cluster_grøn")) {
  data_used <- na.omit(final_dataset[, c("miljø_afhængig", "centered_lagged_pervote_samlet", 
                                     "lagged_i_parlament", "party", "edate", "country", "good_economy")])
  
  h3_robust <- coeftest.cluster_grøn(
    data = data_used,
    fm = h3_model_interaction,
    cluster1 = data_used$party  # Pass the vector directly
  )
  print(h3_robust)
  
  # Double-clustered standard errors (by party and election date)
  h3_robust_double <- summary.cluster_grøn(
    obj = h3_model_interaction, 
    data = data_used, 
    cluster1 = "party", 
    cluster2 = "edate"
  )
  print(h3_robust_double)
}

# ============================================================================
# 2.2 Two-Part Model for Economic Condition Subsets
# ============================================================================

# GOOD ECONOMY: Two-Part Model
# Part 1: Logit model for predicting non-zero climate focus
h3_binary_good_econ <- glm(I(miljø_afhængig != 0) ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                        family = binomial, data = clean_data_good_economy)
summary(h3_binary_good_econ)

# Part 2: Linear model on non-zero values only
h3_continuous_good_econ <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                           data = subset(clean_data_good_economy, miljø_afhængig != 0))
summary(h3_continuous_good_econ)

# BAD ECONOMY: Two-Part Model
# Part 1: Logit model for predicting non-zero climate focus
h3_binary_bad_econ <- glm(I(miljø_afhængig != 0) ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                       family = binomial, data = clean_data_bad_economy)
summary(h3_binary_bad_econ)

# Part 2: Linear model on non-zero values only
h3_continuous_bad_econ <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                          data = subset(clean_data_bad_economy, miljø_afhængig != 0))
summary(h3_continuous_bad_econ)

# ============================================================================
# 2.3 Quantile Regression for Economic Condition Subsets
# ============================================================================

# GOOD ECONOMY: Quantile Regression
# Median regression
h3_median_rq_good_econ <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                          tau = 0.5, data = clean_data_good_economy)
summary(h3_median_rq_good_econ)

# Multiple quantiles
h3_multi_quantile_good_econ <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                               tau = c(0.25, 0.5, 0.75), data = clean_data_good_economy)
summary(h3_multi_quantile_good_econ)

# Generate plot for coefficients across quantiles
h3_quantile_plot_good_econ <- plot(summary(rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                                          tau = seq(0.1, 0.9, by = 0.1), data = clean_data_good_economy)))

# BAD ECONOMY: Quantile Regression
# Median regression
h3_median_rq_bad_econ <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                         tau = 0.5, data = clean_data_bad_economy)
summary(h3_median_rq_bad_econ)

# Multiple quantiles
h3_multi_quantile_bad_econ <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                              tau = c(0.25, 0.5, 0.75), data = clean_data_bad_economy)
summary(h3_multi_quantile_bad_econ)

# Generate plot for coefficients across quantiles
h3_quantile_plot_bad_econ <- plot(summary(rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                                         tau = seq(0.1, 0.9, by = 0.1), data = clean_data_bad_economy)))

# Save quantile plots
pdf("h3_quantile_coefficients_good_econ.pdf", width = 10, height = 8)
print(h3_quantile_plot_good_econ)
dev.off()

pdf("h3_quantile_coefficients_bad_econ.pdf", width = 10, height = 8)
print(h3_quantile_plot_bad_econ)
dev.off()

# ============================================================================
# 2.4 Robust Regression for Economic Condition Subsets
# ============================================================================

# Robust regression for full sample with economic interaction
h3_robust_reg_econ <- rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament * good_economy, 
                       data = final_dataset, method = "MM")
summary(h3_robust_reg_econ)

# GOOD ECONOMY: Robust Regression
h3_robust_reg_good_econ <- rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                            data = clean_data_good_economy, method = "MM")
summary(h3_robust_reg_good_econ)

# BAD ECONOMY: Robust Regression
h3_robust_reg_bad_econ <- rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                           data = clean_data_bad_economy, method = "MM")
summary(h3_robust_reg_bad_econ)

# ============================================================================
# 2.5 RDD Analysis for Economic Condition Subsets - FIXED
# ============================================================================

# Multi-polynomial RDD with custom function
if (exists("rd.base_grøn")) {
  # Good economy sample
  rd.multic_h3_good <- rd.base_grøn(
    data = clean_data_good_economy,
    force.var = 'centered_lagged_pervote_samlet',
    yvar = 'miljø_afhængig',
    seat.identifier = 'factor_lagged_i_parlament',
    fixed.effects = 'country',
    clust1 = 'party',
    clust2 = 'edate',
    polynomials = c(1, 2, 3, 4),
    bws = NULL
  )
  print(rd.multic_h3_good)
  
  # Bad economy sample
  rd.multic_h3_bad <- rd.base_grøn(
    data = clean_data_bad_economy,
    force.var = 'centered_lagged_pervote_samlet',
    yvar = 'miljø_afhængig',
    seat.identifier = 'factor_lagged_i_parlament',
    fixed.effects = 'country',
    clust1 = 'party',
    clust2 = 'edate',
    polynomials = c(1, 2, 3, 4),
    bws = NULL
  )
  print(rd.multic_h3_bad)
}

# Robustness analysis with different bandwidths
# Define covariates to control for
covariates_to_use <- c("country", "edate")

# Run the robustness analysis on good economy data
results_df_h3_good <- run_rdd_robustness(
  data = clean_data_good_economy,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = c(1, 1.5, 2, 2.5, 3),
  polynomials = c(1, 2, 3, 4),
  covariates = covariates_to_use,
  group_label = "H3 - Good Economy"
)

# Run the robustness analysis on bad economy data
results_df_h3_bad <- run_rdd_robustness(
  data = clean_data_bad_economy,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = c(1, 1.5, 2, 2.5, 3),
  polynomials = c(1, 2, 3, 4),
  covariates = covariates_to_use,
  group_label = "H3 - Bad Economy"
)

# Show results
print(results_df_h3_good)
print(results_df_h3_bad)

# Create a nice table with knitr
if (requireNamespace("knitr", quietly = TRUE)) {
  # Combine results
  combined_results_economy <- rbind(results_df_h3_good, results_df_h3_bad)
  
  print(knitr::kable(combined_results_economy, 
                    caption = "H3: Robustness Test Across Economic Conditions"))
}

# ============================================================================
# 2.6 Enhanced rdrobust Analysis for Economic Condition Subsets - FIXED
# ============================================================================

# GOOD ECONOMY: Standard rdrobust (without covariates)
h3_rdd_good <- rdrobust(
  y = clean_data_good_economy$miljø_afhængig,
  x = clean_data_good_economy$centered_lagged_pervote_samlet,
  c = 0,
  p = 1,  # linear polynomial
  kernel = "triangular",
  bwselect = "mserd"  # MSE-optimal bandwidth
)
summary(h3_rdd_good)

# GOOD ECONOMY: rdrobust with simpler approach and fixed bandwidth
tryCatch({
  # Try with fixed bandwidth and minimal covariates
  h3_rdd_covs_good_simple <- rdrobust(
    y = clean_data_good_economy$miljø_afhængig,
    x = clean_data_good_economy$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,
    kernel = "triangular",
    h = 2  # Fixed bandwidth
  )
  summary(h3_rdd_covs_good_simple)
}, error = function(e) {
  cat("Note: Even simplified rdrobust for good economy failed:", e$message, "\n")
})

# BAD ECONOMY: rdrobust with error handling
tryCatch({
  h3_rdd_bad <- rdrobust(
    y = clean_data_bad_economy$miljø_afhængig,
    x = clean_data_bad_economy$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,  # linear polynomial
    kernel = "triangular",
    bwselect = "mserd"  # MSE-optimal bandwidth
  )
  summary(h3_rdd_bad)
}, error = function(e) {
  cat("Note: Could not compute RDD for bad economy group due to:", e$message, "\n")
  
  # Try with fixed bandwidth
  tryCatch({
    cat("Attempting with fixed bandwidth instead...\n")
    h3_rdd_bad_alt <- rdrobust(
      y = clean_data_bad_economy$miljø_afhængig,
      x = clean_data_bad_economy$centered_lagged_pervote_samlet,
      c = 0,
      p = 1,  # linear polynomial
      kernel = "triangular",
      h = 2  # fixed bandwidth
    )
    summary(h3_rdd_bad_alt)
  }, error = function(e2) {
    cat("Alternative specification also failed:", e2$message, "\n")
  })
})

# ============================================================================
# 2.7 Separate Analysis for Zero and Non-Zero Values by Economic Condition
# ============================================================================

# GOOD ECONOMY: Split data into zero and non-zero values
zero_data_good_econ <- subset(clean_data_good_economy, miljø_afhængig == 0)
nonzero_data_good_econ <- subset(clean_data_good_economy, miljø_afhængig != 0)

# BAD ECONOMY: Split data into zero and non-zero values
zero_data_bad_econ <- subset(clean_data_bad_economy, miljø_afhængig == 0)
nonzero_data_bad_econ <- subset(clean_data_bad_economy, miljø_afhængig != 0)

# RDD for non-zero values only (GOOD ECONOMY)
tryCatch({
  h3_rdd_nonzero_good_econ <- rdrobust(
    y = nonzero_data_good_econ$miljø_afhængig,
    x = nonzero_data_good_econ$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,
    kernel = "triangular",
    bwselect = "mserd"
  )
  summary(h3_rdd_nonzero_good_econ)
}, error = function(e) {
  cat("Note: RDD for non-zero values in good economy group failed:", e$message, "\n")
  # Try with fixed bandwidth
  tryCatch({
    h3_rdd_nonzero_good_econ_fixed <- rdrobust(
      y = nonzero_data_good_econ$miljø_afhængig,
      x = nonzero_data_good_econ$centered_lagged_pervote_samlet,
      c = 0,
      p = 1,
      kernel = "triangular",
      h = 2
    )
    summary(h3_rdd_nonzero_good_econ_fixed)
  }, error = function(e2) {
    cat("Fixed bandwidth also failed:", e2$message, "\n")
  })
})

# RDD for non-zero values only (BAD ECONOMY)
tryCatch({
  h3_rdd_nonzero_bad_econ <- rdrobust(
    y = nonzero_data_bad_econ$miljø_afhængig,
    x = nonzero_data_bad_econ$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,
    kernel = "triangular",
    bwselect = "mserd"
  )
  summary(h3_rdd_nonzero_bad_econ)
}, error = function(e) {
  cat("Note: RDD for non-zero values in bad economy group failed:", e$message, "\n")
  # Try with fixed bandwidth
  tryCatch({
    h3_rdd_nonzero_bad_econ_fixed <- rdrobust(
      y = nonzero_data_bad_econ$miljø_afhængig,
      x = nonzero_data_bad_econ$centered_lagged_pervote_samlet,
      c = 0,
      p = 1,
      kernel = "triangular",
      h = 2
    )
    summary(h3_rdd_nonzero_bad_econ_fixed)
  }, error = function(e2) {
    cat("Fixed bandwidth also failed:", e2$message, "\n")
  })
})

# ============================================================================
# 2.8 Visual Confirmation and RDD Plots for Economic Condition
# ============================================================================

# Visual confirmation - good economy
h3_plot_good <- plot_rdd(
  data = clean_data_good_economy,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position",
  title = "H3: Effect Under Good Economic Conditions"
)
print(h3_plot_good)

# Visual confirmation - bad economy
h3_plot_bad <- plot_rdd(
  data = clean_data_bad_economy,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position",
  title = "H3: Effect Under Poor Economic Conditions"
)
print(h3_plot_bad)

# Plots for non-zero values only - good economy
h3_plot_nonzero_good_econ <- plot_rdd(
  data = nonzero_data_good_econ,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position (Non-Zeros Only)",
  title = "H3: Effect Under Good Economy (Non-Zero Values Only)"
)
print(h3_plot_nonzero_good_econ)

# Plots for non-zero values only - bad economy
h3_plot_nonzero_bad_econ <- plot_rdd(
  data = nonzero_data_bad_econ,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position (Non-Zeros Only)",
  title = "H3: Effect Under Poor Economy (Non-Zero Values Only)"
)
print(h3_plot_nonzero_bad_econ)

# Combine plots if gridExtra is available
if (requireNamespace("gridExtra", quietly = TRUE)) {
  # Economic condition
  gridExtra::grid.arrange(h3_plot_good, h3_plot_bad, ncol = 2,
                         top = "H3: Effect Split by Economic Condition")
  
  gridExtra::grid.arrange(h3_plot_nonzero_good_econ, h3_plot_nonzero_bad_econ, ncol = 2,
                         top = "H3: Effect Split by Economic Condition (Non-Zero Values Only)")
}

# ============================================================================
# 3. Additional Models and Interaction Analysis
# ============================================================================

# Simpler interaction model for GDP growth
h3_gdp_simple_int <- lm(
  miljø_afhængig ~ lagged_i_parlament * high_gdp_growth + centered_lagged_pervote_samlet,
  data = final_dataset
)
summary(h3_gdp_simple_int)

# Simpler interaction model for economic condition
h3_econ_simple_int <- lm(
  miljø_afhængig ~ lagged_i_parlament * good_economy + centered_lagged_pervote_samlet,
  data = final_dataset
)
summary(h3_econ_simple_int)

# Triple interaction with GDP
h3_gdp_triple <- lm(
  miljø_afhængig ~ lagged_i_parlament * high_gdp_growth * centered_lagged_pervote_samlet,
  data = final_dataset
)
summary(h3_gdp_triple)

# Triple interaction with economic condition
h3_econ_triple <- lm(
  miljø_afhængig ~ lagged_i_parlament * good_economy * centered_lagged_pervote_samlet,
  data = final_dataset
)
summary(h3_econ_triple)

# IV estimation with interaction with GDP growth
h3_iv_gdp <- ivreg(miljø_afhængig ~ lagged_i_parlament * high_gdp_growth | 
                  centered_lagged_pervote_samlet * high_gdp_growth, 
                 data = final_dataset)
summary(h3_iv_gdp, diagnostics = TRUE)

# IV estimation with interaction with economic condition
h3_iv_econ <- ivreg(miljø_afhængig ~ lagged_i_parlament * good_economy | 
                   centered_lagged_pervote_samlet * good_economy, 
                  data = final_dataset)
summary(h3_iv_econ, diagnostics = TRUE)

# ============================================================================
# 4. Visual Interaction Effects and Predictions
# ============================================================================

# Visual comparison of GDP growth interaction effects
if (requireNamespace("ggplot2", quietly = TRUE) && requireNamespace("tidyr", quietly = TRUE)) {
  # Make predictions based on the model
  pred_data_gdp <- expand.grid(
    high_gdp_growth = c(0, 1),
    centered_lagged_pervote_samlet = seq(-5, 5, by = 0.5),
    lagged_i_parlament = c(0, 1)
  )
  
  pred_data_gdp$predicted <- predict(h3_gdp_triple, newdata = pred_data_gdp)
  
  # Add factors for nicer labels
  pred_data_gdp$gdp_status <- factor(pred_data_gdp$high_gdp_growth, 
                                   levels = c(0, 1),
                                   labels = c("Lav BNP-vækst", "Høj BNP-vækst"))
  
  pred_data_gdp$gp_status <- factor(pred_data_gdp$lagged_i_parlament,
                                  levels = c(0, 1),
                                  labels = c("Grønt parti uden sæde", "Grønt parti med sæde"))
  
  # Plot the interaction
  ggplot2::ggplot(pred_data_gdp, ggplot2::aes(x = centered_lagged_pervote_samlet, 
                                            y = predicted, 
                                            color = gp_status, 
                                            linetype = gp_status)) +
    ggplot2::geom_line() +
    ggplot2::facet_wrap(~ gdp_status) +
    ggplot2::geom_vline(xintercept = 0, linetype = "dashed") +
    ggplot2::theme_minimal() +
    ggplot2::labs(
      title = "H3: Forudsagt klimaposition baseret på BNP-vækst",
      x = "Grønt partis stemmeandel (centreret ved tærskel)",
      y = "Forudsagt klimaposition",
      color = "Grønt parti status",
      linetype = "Grønt parti status"
    )
}

# Visual comparison of economic index interaction effects
if (requireNamespace("ggplot2", quietly = TRUE) && requireNamespace("tidyr", quietly = TRUE)) {
  # Make predictions based on the model
  pred_data_econ <- expand.grid(
    good_economy = c(0, 1),
    centered_lagged_pervote_samlet = seq(-5, 5, by = 0.5),
    lagged_i_parlament = c(0, 1)
  )
  
  pred_data_econ$predicted <- predict(h3_econ_triple, newdata = pred_data_econ)
  
  # Add factors for nicer labels
  pred_data_econ$economy_status <- factor(pred_data_econ$good_economy, 
                                        levels = c(0, 1),
                                        labels = c("Poor Economic Conditions", "Good Economic Conditions"))
  
  pred_data_econ$gp_status <- factor(pred_data_econ$lagged_i_parlament,
                                   levels = c(0, 1),
                                   labels = c("Green Party w/o Seats", "Green Party w/ Seats"))
  
  # Plot the interaction
  ggplot2::ggplot(pred_data_econ, ggplot2::aes(x = centered_lagged_pervote_samlet, 
                                             y = predicted, 
                                             color = gp_status, 
                                             linetype = gp_status)) +
    ggplot2::geom_line() +
    ggplot2::facet_wrap(~ economy_status) +
    ggplot2::geom_vline(xintercept = 0, linetype = "dashed") +
    ggplot2::theme_minimal() +
    ggplot2::labs(
      title = "H3: Predicted Climate Position Based on Economic Conditions",
      x = "Green Party Vote Share (centered at threshold)",
      y = "Predicted Climate Position",
      color = "Green Party Status",
      linetype = "Green Party Status"
    )
}

# ============================================================================
# 5. Comparison Summary Tables
# ============================================================================

# Create tables to compare coefficients across different model specifications
if (requireNamespace("texreg", quietly = TRUE)) {
  library(texreg)
  
  # GDP Growth comparison
  htmlreg(list(h3_continuous_high_gdp, h3_continuous_low_gdp, 
              h3_median_rq_high_gdp, h3_median_rq_low_gdp,
              h3_robust_reg_high_gdp, h3_robust_reg_low_gdp),
         file = "h3_gdp_model_comparison.html",
         custom.model.names = c("OLS High GDP", "OLS Low GDP", 
                               "Median High GDP", "Median Low GDP", 
                               "Robust High GDP", "Robust Low GDP"),
         custom.coef.names = c("Intercept", "Vote Share", "Parliament", "Vote Share × Parliament"),
         caption = "Comparison of Different Modeling Approaches for H3 by GDP Growth")
  
  # Economic Condition comparison
  htmlreg(list(h3_continuous_good_econ, h3_continuous_bad_econ, 
              h3_median_rq_good_econ, h3_median_rq_bad_econ,
              h3_robust_reg_good_econ, h3_robust_reg_bad_econ),
         file = "h3_econ_model_comparison.html",
         custom.model.names = c("OLS Good Econ", "OLS Bad Econ", 
                               "Median Good Econ", "Median Bad Econ", 
                               "Robust Good Econ", "Robust Bad Econ"),
         custom.coef.names = c("Intercept", "Vote Share", "Parliament", "Vote Share × Parliament"),
         caption = "Comparison of Different Modeling Approaches for H3 by Economic Conditions")
}

# Lav comparison plot for økonomiske forhold
economy_comparison_plot <- compare_coefficient_stability(
  data_list = list(clean_data_good_economy, clean_data_bad_economy),
  labels = c("God økonomisk tilstand", "Dårlig økonomisk tilstand"),
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomial = 1,  # Lineær model for enkelhed
  covariates = c("country", "edate"),
  title = "H3: Effekt af grønne partier modereret af økonomiske forhold"
)

# Vis plottet
print(economy_comparison_plot)

# Sammenligning med forskellige polynomiske grader
economy_comparison_plot_p1 <- compare_coefficient_stability(
  data_list = list(clean_data_good_economy, clean_data_bad_economy),
  labels = c("God økonomisk tilstand", "Dårlig økonomisk tilstand"),
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomial = 1,
  covariates = c("country", "edate"),
  title = "H3: Effekt af grønne partier (polynomisk grad 1)"
)

economy_comparison_plot_p2 <- compare_coefficient_stability(
  data_list = list(clean_data_good_economy, clean_data_bad_economy),
  labels = c("God økonomisk tilstand", "Dårlig økonomisk tilstand"),
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomial = 2,
  covariates = c("country", "edate"),
  title = "H3: Effekt af grønne partier (polynomisk grad 2)"
)

# Kombiner plots i grid
if (requireNamespace("gridExtra", quietly = TRUE)) {
  economy_poly_comparison <- gridExtra::grid.arrange(
    economy_comparison_plot_p1, economy_comparison_plot_p2,
    ncol = 2,
    top = "H3: Effekt af grønne partier modereret af økonomiske forhold"
  )
  
  # Gem det kombinerede plot
  ggsave("h3_economy_polynomial_comparison.png", economy_poly_comparison, width = 12, height = 6, dpi = 300)
}

# Alternativt plot med GDP vækst som moderator (hvis du vil have begge indikatorer)
# Opdel data baseret på BNP-vækst
data_high_gdp <- subset(clean_data, high_gdp_growth == 1)
data_low_gdp <- subset(clean_data, high_gdp_growth == 0)

# Lav comparison plot for BNP-vækst
gdp_comparison_plot <- compare_coefficient_stability(
  data_list = list(data_high_gdp, data_low_gdp),
  labels = c("Høj BNP-vækst", "Lav BNP-vækst"),
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomial = 1,
  covariates = c("country", "edate"),
  title = "H3: Effekt af grønne partier modereret af BNP-vækst"
)

# Kombiner begge økonomiske moderatorer i ét samlet plot for sammenligning
if (requireNamespace("gridExtra", quietly = TRUE)) {
  economic_indicators_comparison <- gridExtra::grid.arrange(
    economy_comparison_plot, gdp_comparison_plot,
    ncol = 2,
    top = "H3: Sammenligning af forskellige økonomiske moderatorer"
  )
  
  # Gem sammenligningen
  ggsave("h3_economic_indicators_comparison.png", economic_indicators_comparison, width = 12, height = 6, dpi = 300)
}
```



## 3.2 H4: When green parties enter parliament, left-wing mainstream parties increase climate focus

```{r h4_analysis}
# ============================================================================
# 1. Basic Linear Models
# ============================================================================

# Simple linear model
h4_model_simple <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet + lagged_i_parlament,
                     data = final_dataset)
summary(h4_model_simple)

# Interaction model
h4_model_interaction <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                          data = final_dataset)
summary(h4_model_interaction)

# Interaction model with party ideology
h4_model_left_interaction <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament * left_party, 
                               data = final_dataset)
summary(h4_model_left_interaction)

# Clustered standard errors (by party)
if (exists("coeftest.cluster_grøn")) {
  data_used <- na.omit(final_dataset[, c("miljø_afhængig", "centered_lagged_pervote_samlet", 
                                      "lagged_i_parlament", "party", "edate", "country", "left_party")])
  
  h4_robust <- coeftest.cluster_grøn(
    data = data_used,
    fm = h4_model_interaction,
    cluster1 = data_used$party  # Pass the vector directly
  )
  print(h4_robust)
  
  # Double-clustered standard errors (by party and election date)
  h4_robust_double <- summary.cluster_grøn(
    obj = h4_model_interaction, 
    data = data_used, 
    cluster1 = "party", 
    cluster2 = "edate"
  )
  print(h4_robust_double)
  
  # Clustered SEs for ideology interaction model
  h4_ideology_robust <- coeftest.cluster_grøn(
    data = data_used,
    fm = h4_model_left_interaction,
    cluster1 = data_used$party
  )
  print(h4_ideology_robust)
}

# ============================================================================
# 2. Data Preparation for Subgroup Analysis
# ============================================================================

# Undersøg om effekten varierer baseret på partiideologi (H4)
# Opdel baseret på om partiet er venstre- eller højreorienteret
clean_data_right_party <- subset(clean_data, left_party == 0)
clean_data_left_party <- subset(clean_data, left_party == 1)

# ============================================================================
# 3. Two-Part Model for Party Ideology Subsets
# ============================================================================

# RIGHT PARTIES: Two-Part Model
# Part 1: Logit model for predicting non-zero climate focus
h4_binary_right <- glm(I(miljø_afhængig != 0) ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                     family = binomial, data = clean_data_right_party)
summary(h4_binary_right)

# Part 2: Linear model on non-zero values only
h4_continuous_right <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                        data = subset(clean_data_right_party, miljø_afhængig != 0))
summary(h4_continuous_right)

# LEFT PARTIES: Two-Part Model
# Part 1: Logit model for predicting non-zero climate focus
h4_binary_left <- glm(I(miljø_afhængig != 0) ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                    family = binomial, data = clean_data_left_party)
summary(h4_binary_left)

# Part 2: Linear model on non-zero values only
h4_continuous_left <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                       data = subset(clean_data_left_party, miljø_afhængig != 0))
summary(h4_continuous_left)

# ============================================================================
# 4. Quantile Regression for Party Ideology Subsets
# ============================================================================

# RIGHT PARTIES: Quantile Regression
# Median regression
h4_median_rq_right <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                       tau = 0.5, data = clean_data_right_party)
summary(h4_median_rq_right)

# Multiple quantiles
h4_multi_quantile_right <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                            tau = c(0.25, 0.5, 0.75), data = clean_data_right_party)
summary(h4_multi_quantile_right)

# Generate plot for coefficients across quantiles
h4_quantile_plot_right <- plot(summary(rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                                       tau = seq(0.1, 0.9, by = 0.1), data = clean_data_right_party)))

# LEFT PARTIES: Quantile Regression
# Median regression
h4_median_rq_left <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                      tau = 0.5, data = clean_data_left_party)
summary(h4_median_rq_left)

# Multiple quantiles
h4_multi_quantile_left <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                           tau = c(0.25, 0.5, 0.75), data = clean_data_left_party)
summary(h4_multi_quantile_left)

# Generate plot for coefficients across quantiles
h4_quantile_plot_left <- plot(summary(rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                                      tau = seq(0.1, 0.9, by = 0.1), data = clean_data_left_party)))

# Save quantile plots
pdf("h4_quantile_coefficients_right.pdf", width = 10, height = 8)
print(h4_quantile_plot_right)
dev.off()

pdf("h4_quantile_coefficients_left.pdf", width = 10, height = 8)
print(h4_quantile_plot_left)
dev.off()

# ============================================================================
# 5. Robust Regression for Party Ideology Subsets
# ============================================================================

# Robust regression for full sample with party ideology interaction
h4_robust_reg_ideology <- rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament * left_party, 
                           data = final_dataset, method = "MM")
summary(h4_robust_reg_ideology)

# RIGHT PARTIES: Robust Regression
h4_robust_reg_right <- rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                         data = clean_data_right_party, method = "MM")
summary(h4_robust_reg_right)

# LEFT PARTIES: Robust Regression
h4_robust_reg_left <- rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                        data = clean_data_left_party, method = "MM")
summary(h4_robust_reg_left)

# ============================================================================
# 6. RDD Analysis for Party Ideology Subsets
# ============================================================================

# Multi-polynomial RDD with custom function
if (exists("rd.base_grøn")) {
  # Multi-polynomial RDD with custom function
  rd.multic_h4 <- rd.base_grøn(
    data = final_dataset,
    force.var = 'centered_lagged_pervote_samlet',
    yvar = 'miljø_afhængig',
    seat.identifier = 'factor_lagged_i_parlament',
    fixed.effects = 'country',
    clust1 = 'party',
    clust2 = 'edate',
    polynomials = c(1, 2, 3, 4),
    bws = NULL
  )
  print(rd.multic_h4)
  
  # Right parties sample
  rd.multic_h4_right <- rd.base_grøn(
    data = clean_data_right_party,
    force.var = 'centered_lagged_pervote_samlet',
    yvar = 'miljø_afhængig',
    seat.identifier = 'factor_lagged_i_parlament',
    fixed.effects = 'country',
    clust1 = 'party',
    clust2 = 'edate',
    polynomials = c(1, 2, 3, 4),
    bws = NULL
  )
  print(rd.multic_h4_right)
  
  # Left parties sample
  rd.multic_h4_left <- rd.base_grøn(
    data = clean_data_left_party,
    force.var = 'centered_lagged_pervote_samlet',
    yvar = 'miljø_afhængig',
    seat.identifier = 'factor_lagged_i_parlament',
    fixed.effects = 'country',
    clust1 = 'party',
    clust2 = 'edate',
    polynomials = c(1, 2, 3, 4),
    bws = NULL
  )
  print(rd.multic_h4_left)
}

# Robustness analysis med forskellige båndbredder
covariates_to_use <- c("country", "edate")

# Kør robusthedsanalysen på alle data
results_df_h4 <- run_rdd_robustness(
  data = clean_data,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = c(1, 1.5, 2, 2.5, 3),
  polynomials = c(1, 2, 3, 4),
  covariates = covariates_to_use,
  group_label = "H4 - Fuld sample"
)

# Kør robusthedsanalysen for højreorienterede partier
results_df_h4_right <- run_rdd_robustness(
  data = clean_data_right_party,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = c(1, 1.5, 2, 2.5, 3),
  polynomials = c(1, 2),  # Begrænset til p=1,2 for at holde det enkelt
  covariates = covariates_to_use,
  group_label = "Højreorienterede partier"
)

# Kør robusthedsanalysen for venstreorienterede partier
results_df_h4_left <- run_rdd_robustness(
  data = clean_data_left_party,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = c(1, 1.5, 2, 2.5, 3),
  polynomials = c(1, 2),  # Begrænset til p=1,2 for at holde det enkelt
  covariates = covariates_to_use,
  group_label = "Venstreorienterede partier"
)

# Vis resultaterne
print(results_df_h4)

# Kombinér resultaterne for at sammenligne direkte
combined_results_ideology <- rbind(results_df_h4_right, results_df_h4_left)
print(combined_results_ideology)

# Vis kombinerede resultater i pæne tabeller
if (requireNamespace("knitr", quietly = TRUE)) {
  print(knitr::kable(results_df_h4, 
                    caption = "H4: Robusthedstest med forskellige båndbredder og polynomiegrader"))
  
  print(knitr::kable(combined_results_ideology, 
                    caption = "H4: Effekten opdelt efter partiideologi"))
}

# ============================================================================
# 7. Enhanced rdrobust Analysis for Party Ideology Subsets
# ============================================================================

# Standard RDD approach
h4_rdd <- rdrobust(
  y = clean_data$miljø_afhængig,
  x = clean_data$centered_lagged_pervote_samlet,
  c = 0,
  p = 1,  # linear polynomial
  kernel = "triangular",
  bwselect = "mserd"  # MSE-optimal bandwidth
)
summary(h4_rdd)

# Alternative RDD specifications
h4_rdd_alt <- rdrobust(
  y = clean_data$miljø_afhængig,
  x = clean_data$centered_lagged_pervote_samlet,
  c = 0,
  p = 2,  # quadratic polynomial
  kernel = "triangular",
  h = 2  # fixed bandwidth
)
summary(h4_rdd_alt)

# RIGHT PARTIES: Standard rdrobust (with error handling)
tryCatch({
  h4_rdd_right <- rdrobust(
    y = clean_data_right_party$miljø_afhængig,
    x = clean_data_right_party$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,
    kernel = "triangular",
    bwselect = "mserd"
  )
  summary(h4_rdd_right)
}, error = function(e) {
  cat("Standard rdrobust for right parties failed:", e$message, "\n")
  # Try with fixed bandwidth
  tryCatch({
    h4_rdd_right_fixed <- rdrobust(
      y = clean_data_right_party$miljø_afhængig,
      x = clean_data_right_party$centered_lagged_pervote_samlet,
      c = 0,
      p = 1,
      kernel = "triangular",
      h = 2  # fixed bandwidth
    )
    summary(h4_rdd_right_fixed)
  }, error = function(e2) {
    cat("Fixed bandwidth also failed for right parties:", e2$message, "\n")
  })
})

# LEFT PARTIES: Standard rdrobust (with error handling)
tryCatch({
  h4_rdd_left <- rdrobust(
    y = clean_data_left_party$miljø_afhængig,
    x = clean_data_left_party$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,
    kernel = "triangular",
    bwselect = "mserd"
  )
  summary(h4_rdd_left)
}, error = function(e) {
  cat("Standard rdrobust for left parties failed:", e$message, "\n")
  # Try with fixed bandwidth
  tryCatch({
    h4_rdd_left_fixed <- rdrobust(
      y = clean_data_left_party$miljø_afhængig,
      x = clean_data_left_party$centered_lagged_pervote_samlet,
      c = 0,
      p = 1,
      kernel = "triangular",
      h = 2  # fixed bandwidth
    )
    summary(h4_rdd_left_fixed)
  }, error = function(e2) {
    cat("Fixed bandwidth also failed for left parties:", e2$message, "\n")
  })
})

# ============================================================================
# 8. Separate Analysis for Zero and Non-Zero Values by Party Ideology
# ============================================================================

# RIGHT PARTIES: Split data into zero and non-zero values
zero_data_right <- subset(clean_data_right_party, miljø_afhængig == 0)
nonzero_data_right <- subset(clean_data_right_party, miljø_afhængig != 0)

# LEFT PARTIES: Split data into zero and non-zero values
zero_data_left <- subset(clean_data_left_party, miljø_afhængig == 0)
nonzero_data_left <- subset(clean_data_left_party, miljø_afhængig != 0)

# RDD for non-zero values only (RIGHT PARTIES)
tryCatch({
  h4_rdd_nonzero_right <- rdrobust(
    y = nonzero_data_right$miljø_afhængig,
    x = nonzero_data_right$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,
    kernel = "triangular",
    bwselect = "mserd"
  )
  summary(h4_rdd_nonzero_right)
}, error = function(e) {
  cat("RDD for non-zero values in right parties failed:", e$message, "\n")
  # Try with fixed bandwidth
  tryCatch({
    h4_rdd_nonzero_right_fixed <- rdrobust(
      y = nonzero_data_right$miljø_afhængig,
      x = nonzero_data_right$centered_lagged_pervote_samlet,
      c = 0,
      p = 1,
      kernel = "triangular",
      h = 2
    )
    summary(h4_rdd_nonzero_right_fixed)
  }, error = function(e2) {
    cat("Fixed bandwidth also failed:", e2$message, "\n")
  })
})

# RDD for non-zero values only (LEFT PARTIES)
tryCatch({
  h4_rdd_nonzero_left <- rdrobust(
    y = nonzero_data_left$miljø_afhængig,
    x = nonzero_data_left$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,
    kernel = "triangular",
    bwselect = "mserd"
  )
  summary(h4_rdd_nonzero_left)
}, error = function(e) {
  cat("RDD for non-zero values in left parties failed:", e$message, "\n")
  # Try with fixed bandwidth
  tryCatch({
    h4_rdd_nonzero_left_fixed <- rdrobust(
      y = nonzero_data_left$miljø_afhængig,
      x = nonzero_data_left$centered_lagged_pervote_samlet,
      c = 0,
      p = 1,
      kernel = "triangular",
      h = 2
    )
    summary(h4_rdd_nonzero_left_fixed)
  }, error = function(e2) {
    cat("Fixed bandwidth also failed:", e2$message, "\n")
  })
})

# ============================================================================
# 9. IV Estimation with Party Ideology Interaction
# ============================================================================

# IV estimation med interaktion med left_party
h4_iv <- ivreg(miljø_afhængig ~ lagged_i_parlament * left_party | 
               centered_lagged_pervote_samlet * left_party, 
              data = clean_data)
summary(h4_iv, diagnostics = TRUE)

# IV estimation for each subgroup
h4_iv_right <- ivreg(miljø_afhængig ~ lagged_i_parlament | centered_lagged_pervote_samlet, 
                    data = clean_data_right_party)
summary(h4_iv_right, diagnostics = TRUE)

h4_iv_left <- ivreg(miljø_afhængig ~ lagged_i_parlament | centered_lagged_pervote_samlet, 
                   data = clean_data_left_party)
summary(h4_iv_left, diagnostics = TRUE)

# ============================================================================
# 10. Visual Confirmation and RDD Plots
# ============================================================================

# Visual confirmation for full sample
h4_plot <- plot_rdd(
  data = clean_data,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position",
  title = "H4: Effect of Green Party Entry on Mainstream Climate Focus"
)
print(h4_plot)

# Plots for right parties
h4_plot_right <- plot_rdd(
  data = clean_data_right_party,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position",
  title = "H4: Effekt på højreorienterede partier"
)
print(h4_plot_right)

# Plots for left parties
h4_plot_left <- plot_rdd(
  data = clean_data_left_party,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position",
  title = "H4: Effekt på venstreorienterede partier"
)
print(h4_plot_left)

# Plots for non-zero values only - right parties
h4_plot_nonzero_right <- plot_rdd(
  data = nonzero_data_right,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position (Non-Zeros Only)",
  title = "H4: Effekt på højreorienterede partier (kun ikke-nul værdier)"
)
print(h4_plot_nonzero_right)

# Plots for non-zero values only - left parties
h4_plot_nonzero_left <- plot_rdd(
  data = nonzero_data_left,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position (Non-Zeros Only)",
  title = "H4: Effekt på venstreorienterede partier (kun ikke-nul værdier)"
)
print(h4_plot_nonzero_left)

# Kombiner plots hvis gridExtra er tilgængelig
if (requireNamespace("gridExtra", quietly = TRUE)) {
  # Partiideologi
  gridExtra::grid.arrange(h4_plot_right, h4_plot_left, ncol = 2,
                         top = "H4: Effekt opdelt efter partiideologi")
  
  # Partiideologi (kun ikke-nul værdier)
  gridExtra::grid.arrange(h4_plot_nonzero_right, h4_plot_nonzero_left, ncol = 2,
                         top = "H4: Effekt opdelt efter partiideologi (kun ikke-nul værdier)")
}

# ============================================================================
# 11. Visual Interaction Effects and Predictions
# ============================================================================

# Visuel sammenligning af interaktionseffekter
if (requireNamespace("ggplot2", quietly = TRUE) && requireNamespace("tidyr", quietly = TRUE)) {
  # Lav forudsigelser baseret på modellen
  pred_data <- expand.grid(
    left_party = c(0, 1),
    centered_lagged_pervote_samlet = seq(-5, 5, by = 0.5),
    lagged_i_parlament = c(0, 1)
  )
  
  pred_data$predicted <- predict(h4_model_left_interaction, newdata = pred_data)
  
  # Tilføj faktorer for pænere labels
  pred_data$ideology <- factor(pred_data$left_party, 
                             levels = c(0, 1),
                             labels = c("Højreorienteret parti", "Venstreorienteret parti"))
  
  pred_data$gp_status <- factor(pred_data$lagged_i_parlament,
                              levels = c(0, 1),
                              labels = c("Grønt parti uden sæde", "Grønt parti med sæde"))
  
  # Plot interaktionen
  ggplot2::ggplot(pred_data, ggplot2::aes(x = centered_lagged_pervote_samlet, 
                                         y = predicted, 
                                         color = gp_status, 
                                         linetype = gp_status)) +
    ggplot2::geom_line() +
    ggplot2::facet_wrap(~ ideology) +
    ggplot2::geom_vline(xintercept = 0, linetype = "dashed") +
    ggplot2::theme_minimal() +
    ggplot2::labs(
      title = "Forudsagt klimaposition baseret på H4 interaktionsmodel",
      x = "Grønt partis stemmeandel (centreret ved tærskel)",
      y = "Forudsagt klimaposition",
      color = "Grønt parti status",
      linetype = "Grønt parti status"
    )
}

# ============================================================================
# 12. Comparison Summary Tables
# ============================================================================

# Create tables to compare coefficients across different model specifications
if (requireNamespace("texreg", quietly = TRUE)) {
  library(texreg)
  
  # Party ideology comparison
  htmlreg(list(h4_continuous_right, h4_continuous_left, 
              h4_median_rq_right, h4_median_rq_left,
              h4_robust_reg_right, h4_robust_reg_left),
         file = "h4_ideology_model_comparison.html",
         custom.model.names = c("OLS Right", "OLS Left", 
                               "Median Right", "Median Left", 
                               "Robust Right", "Robust Left"),
         custom.coef.names = c("Intercept", "Vote Share", "Parliament", "Vote Share × Parliament"),
         caption = "Comparison of Different Modeling Approaches for H4 by Party Ideology")
}
```

## 3.3 H5: Larger mainstream parties respond less to green parties in parliament

```{r h5_analysis}
# ============================================================================
# 1. Basic Linear Models
# ============================================================================

# Simple linear model for H5
h5_model_simple <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet + lagged_i_parlament + large_party,
                     data = final_dataset)
summary(h5_model_simple)

# Interaction model with binary party size
h5_model_interaction <- lm(miljø_afhængig ~ lagged_i_parlament * large_party + centered_lagged_pervote_samlet, 
                          data = final_dataset)
summary(h5_model_interaction)

# Full interaction model with binary party size
h5_model_full_interaction <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament * large_party, 
                               data = final_dataset)
summary(h5_model_full_interaction)

# Alternative specification with avg_pervote_main as continuous variable
h5_interaction_cont <- lm(
  miljø_afhængig ~ lagged_i_parlament * avg_pervote_main + centered_lagged_pervote_samlet,
  data = clean_data
)
summary(h5_interaction_cont)

# Three-way interaction with continuous party size
h5_triple <- lm(
  miljø_afhængig ~ lagged_i_parlament * avg_pervote_main * centered_lagged_pervote_samlet,
  data = clean_data
)
summary(h5_triple)

# Clustered standard errors (by party)
if (exists("coeftest.cluster_grøn")) {
  data_used <- na.omit(final_dataset[, c("miljø_afhængig", "centered_lagged_pervote_samlet", 
                                      "lagged_i_parlament", "large_party", "party", "edate", "country")])
  
  h5_robust <- coeftest.cluster_grøn(
    data = data_used,
    fm = h5_model_interaction,
    cluster1 = data_used$party  # Pass the vector directly
  )
  print(h5_robust)
  
  # Double-clustered standard errors (by party and election date)
  h5_robust_double <- summary.cluster_grøn(
    obj = h5_model_interaction, 
    data = data_used, 
    cluster1 = "party", 
    cluster2 = "edate"
  )
  print(h5_robust_double)
  
  # For the full interaction model
  h5_full_robust <- coeftest.cluster_grøn(
    data = data_used,
    fm = h5_model_full_interaction,
    cluster1 = data_used$party
  )
  print(h5_full_robust)
  
  # For the continuous specification
  data_used_cont <- na.omit(clean_data[, c("miljø_afhængig", "centered_lagged_pervote_samlet", 
                                     "lagged_i_parlament", "avg_pervote_main", "party", "edate", "country")])
  
  h5_robust_cont <- coeftest.cluster_grøn(
    data = data_used_cont,
    fm = h5_interaction_cont,
    cluster1 = data_used_cont$party
  )
  print(h5_robust_cont)
}

# ============================================================================
# 2. Data Preparation for Subgroup Analysis
# ============================================================================

# Split data based on party size
large_parties <- subset(clean_data, large_party == 1)
small_parties <- subset(clean_data, large_party == 0)

# ============================================================================
# 3. Two-Part Model for Party Size Subsets
# ============================================================================

# LARGE PARTIES: Two-Part Model
# Part 1: Logit model for predicting non-zero climate focus
h5_binary_large <- glm(I(miljø_afhængig != 0) ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                     family = binomial, data = large_parties)
summary(h5_binary_large)

# Part 2: Linear model on non-zero values only
h5_continuous_large <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                        data = subset(large_parties, miljø_afhængig != 0))
summary(h5_continuous_large)

# SMALL PARTIES: Two-Part Model
# Part 1: Logit model for predicting non-zero climate focus
h5_binary_small <- glm(I(miljø_afhængig != 0) ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                    family = binomial, data = small_parties)
summary(h5_binary_small)

# Part 2: Linear model on non-zero values only
h5_continuous_small <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                       data = subset(small_parties, miljø_afhængig != 0))
summary(h5_continuous_small)

# ============================================================================
# 4. Quantile Regression for Party Size Subsets
# ============================================================================

# LARGE PARTIES: Quantile Regression
# Median regression
h5_median_rq_large <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                       tau = 0.5, data = large_parties)
summary(h5_median_rq_large)

# Multiple quantiles
h5_multi_quantile_large <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                            tau = c(0.25, 0.5, 0.75), data = large_parties)
summary(h5_multi_quantile_large)

# Generate plot for coefficients across quantiles
h5_quantile_plot_large <- plot(summary(rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                                       tau = seq(0.1, 0.9, by = 0.1), data = large_parties)))

# SMALL PARTIES: Quantile Regression
# Median regression
h5_median_rq_small <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                      tau = 0.5, data = small_parties)
summary(h5_median_rq_small)

# Multiple quantiles
h5_multi_quantile_small <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                           tau = c(0.25, 0.5, 0.75), data = small_parties)
summary(h5_multi_quantile_small)

# Generate plot for coefficients across quantiles
h5_quantile_plot_small <- plot(summary(rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                                      tau = seq(0.1, 0.9, by = 0.1), data = small_parties)))

# Save quantile plots
pdf("h5_quantile_coefficients_large.pdf", width = 10, height = 8)
print(h5_quantile_plot_large)
dev.off()

pdf("h5_quantile_coefficients_small.pdf", width = 10, height = 8)
print(h5_quantile_plot_small)
dev.off()

# ============================================================================
# 5. Robust Regression for Party Size Subsets
# ============================================================================

# Robust regression for full sample with party size interaction
h5_robust_reg_size <- rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament * large_party, 
                       data = final_dataset, method = "MM")
summary(h5_robust_reg_size)

# Robust regression with continuous party size
h5_robust_reg_cont <- rlm(miljø_afhængig ~ lagged_i_parlament * avg_pervote_main * centered_lagged_pervote_samlet, 
                        data = clean_data, method = "MM")
summary(h5_robust_reg_cont)

# LARGE PARTIES: Robust Regression
h5_robust_reg_large <- rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                         data = large_parties, method = "MM")
summary(h5_robust_reg_large)

# SMALL PARTIES: Robust Regression
h5_robust_reg_small <- rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                        data = small_parties, method = "MM")
summary(h5_robust_reg_small)

# ============================================================================
# 6. RDD Analysis for Party Size Subsets
# ============================================================================

# Robustness analysis with different bandwidths
covariates_to_use <- c("country", "edate")

# Run the robustness analysis for large parties
results_df_h5_large <- run_rdd_robustness(
  data = large_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = c(1, 1.5, 2, 2.5, 3),
  polynomials = c(1, 2, 3, 4),
  covariates = covariates_to_use,
  group_label = "Store partier"
)

# Run the robustness analysis for small parties
results_df_h5_small <- run_rdd_robustness(
  data = small_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = c(1, 1.5, 2, 2.5, 3),
  polynomials = c(1, 2, 3, 4),
  covariates = covariates_to_use,
  group_label = "Små partier"
)

# Combine results for direct comparison
combined_results_size <- rbind(results_df_h5_large, results_df_h5_small)
print(combined_results_size)

# Display results in a nice table
if (requireNamespace("knitr", quietly = TRUE)) {
  print(knitr::kable(combined_results_size, 
                    caption = "H5: Robusthedstest med forskellige båndbredder opdelt efter partistørrelse"))
}

# ============================================================================
# 7. Enhanced rdrobust Analysis for Party Size Subsets
# ============================================================================

# LARGE PARTIES: Standard rdrobust (with error handling)
tryCatch({
  h5_large_rdd <- rdrobust(
    y = large_parties$miljø_afhængig,
    x = large_parties$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,
    kernel = "triangular",
    bwselect = "mserd"
  )
  summary(h5_large_rdd)
}, error = function(e) {
  cat("Standard rdrobust for large parties failed:", e$message, "\n")
  # Try with fixed bandwidth
  tryCatch({
    h5_large_rdd_fixed <- rdrobust(
      y = large_parties$miljø_afhængig,
      x = large_parties$centered_lagged_pervote_samlet,
      c = 0,
      p = 1,
      kernel = "triangular",
      h = 2  # fixed bandwidth
    )
    summary(h5_large_rdd_fixed)
  }, error = function(e2) {
    cat("Fixed bandwidth also failed for large parties:", e2$message, "\n")
  })
})

# SMALL PARTIES: Standard rdrobust (with error handling)
tryCatch({
  h5_small_rdd <- rdrobust(
    y = small_parties$miljø_afhængig,
    x = small_parties$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,
    kernel = "triangular",
    bwselect = "mserd"
  )
  summary(h5_small_rdd)
}, error = function(e) {
  cat("Standard rdrobust for small parties failed:", e$message, "\n")
  # Try with fixed bandwidth
  tryCatch({
    h5_small_rdd_fixed <- rdrobust(
      y = small_parties$miljø_afhængig,
      x = small_parties$centered_lagged_pervote_samlet,
      c = 0,
      p = 1,
      kernel = "triangular",
      h = 2  # fixed bandwidth
    )
    summary(h5_small_rdd_fixed)
  }, error = function(e2) {
    cat("Fixed bandwidth also failed for small parties:", e2$message, "\n")
  })
})

# Alternative specifications with fixed bandwidth (if previous attempts succeeded)
tryCatch({
  h5_large_rdd_alt <- rdrobust(
    y = large_parties$miljø_afhængig,
    x = large_parties$centered_lagged_pervote_samlet,
    c = 0,
    p = 2,  # quadratic polynomial
    kernel = "triangular",
    h = 2  # fixed bandwidth
  )
  summary(h5_large_rdd_alt)
}, error = function(e) {
  cat("Alternative specification for large parties failed:", e$message, "\n")
})

tryCatch({
  h5_small_rdd_alt <- rdrobust(
    y = small_parties$miljø_afhængig,
    x = small_parties$centered_lagged_pervote_samlet,
    c = 0,
    p = 2,  # quadratic polynomial
    kernel = "triangular",
    h = 2  # fixed bandwidth
  )
  summary(h5_small_rdd_alt)
}, error = function(e) {
  cat("Alternative specification for small parties failed:", e$message, "\n")
})

# ============================================================================
# 8. Separate Analysis for Zero and Non-Zero Values by Party Size
# ============================================================================

# LARGE PARTIES: Split data into zero and non-zero values
zero_data_large <- subset(large_parties, miljø_afhængig == 0)
nonzero_data_large <- subset(large_parties, miljø_afhængig != 0)

# SMALL PARTIES: Split data into zero and non-zero values
zero_data_small <- subset(small_parties, miljø_afhængig == 0)
nonzero_data_small <- subset(small_parties, miljø_afhængig != 0)

# RDD for non-zero values only (LARGE PARTIES)
tryCatch({
  h5_rdd_nonzero_large <- rdrobust(
    y = nonzero_data_large$miljø_afhængig,
    x = nonzero_data_large$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,
    kernel = "triangular",
    bwselect = "mserd"
  )
  summary(h5_rdd_nonzero_large)
}, error = function(e) {
  cat("RDD for non-zero values in large parties failed:", e$message, "\n")
  # Try with fixed bandwidth
  tryCatch({
    h5_rdd_nonzero_large_fixed <- rdrobust(
      y = nonzero_data_large$miljø_afhængig,
      x = nonzero_data_large$centered_lagged_pervote_samlet,
      c = 0,
      p = 1,
      kernel = "triangular",
      h = 2
    )
    summary(h5_rdd_nonzero_large_fixed)
  }, error = function(e2) {
    cat("Fixed bandwidth also failed:", e2$message, "\n")
  })
})

# RDD for non-zero values only (SMALL PARTIES)
tryCatch({
  h5_rdd_nonzero_small <- rdrobust(
    y = nonzero_data_small$miljø_afhængig,
    x = nonzero_data_small$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,
    kernel = "triangular",
    bwselect = "mserd"
  )
  summary(h5_rdd_nonzero_small)
}, error = function(e) {
  cat("RDD for non-zero values in small parties failed:", e$message, "\n")
  # Try with fixed bandwidth
  tryCatch({
    h5_rdd_nonzero_small_fixed <- rdrobust(
      y = nonzero_data_small$miljø_afhængig,
      x = nonzero_data_small$centered_lagged_pervote_samlet,
      c = 0,
      p = 1,
      kernel = "triangular",
      h = 2
    )
    summary(h5_rdd_nonzero_small_fixed)
  }, error = function(e2) {
    cat("Fixed bandwidth also failed:", e2$message, "\n")
  })
})

# ============================================================================
# 9. IV Estimation for Party Size Subsets
# ============================================================================

# IV estimation split by party size
h5_large_iv <- ivreg(miljø_afhængig ~ lagged_i_parlament | centered_lagged_pervote_samlet, 
              data = large_parties)
summary(h5_large_iv, diagnostics = TRUE)

h5_small_iv <- ivreg(miljø_afhængig ~ lagged_i_parlament | centered_lagged_pervote_samlet, 
              data = small_parties)
summary(h5_small_iv, diagnostics = TRUE)

# IV estimation with interaction for full sample
h5_iv_interact <- ivreg(miljø_afhængig ~ lagged_i_parlament * large_party | 
                       centered_lagged_pervote_samlet * large_party, 
                      data = clean_data)
summary(h5_iv_interact, diagnostics = TRUE)

# IV with continuous party size
h5_iv_cont <- ivreg(miljø_afhængig ~ lagged_i_parlament * avg_pervote_main | 
                   centered_lagged_pervote_samlet * avg_pervote_main, 
                  data = clean_data)
summary(h5_iv_cont, diagnostics = TRUE)

# ============================================================================
# 10. Visual Confirmation and RDD Plots
# ============================================================================

# Visual confirmation for large parties
h5_large_plot <- plot_rdd(
  data = large_parties,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position",
  title = "H5: Effect on Large Mainstream Parties"
)
print(h5_large_plot)

# Visual confirmation for small parties
h5_small_plot <- plot_rdd(
  data = small_parties,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position",
  title = "H5: Effect on Small Mainstream Parties"
)
print(h5_small_plot)

# Plots for non-zero values only - large parties
h5_plot_nonzero_large <- plot_rdd(
  data = nonzero_data_large,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position (Non-Zeros Only)",
  title = "H5: Effect on Large Parties (Non-Zero Values Only)"
)
print(h5_plot_nonzero_large)

# Plots for non-zero values only - small parties
h5_plot_nonzero_small <- plot_rdd(
  data = nonzero_data_small,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position (Non-Zeros Only)",
  title = "H5: Effect on Small Parties (Non-Zero Values Only)"
)
print(h5_plot_nonzero_small)

# Combine plots if gridExtra is available
if (requireNamespace("gridExtra", quietly = TRUE)) {
  # Party size
  gridExtra::grid.arrange(h5_large_plot, h5_small_plot, ncol = 2,
                         top = "H5: Effekt opdelt efter partistørrelse")
  
  # Party size (non-zero values only)
  gridExtra::grid.arrange(h5_plot_nonzero_large, h5_plot_nonzero_small, ncol = 2,
                         top = "H5: Effekt opdelt efter partistørrelse (kun ikke-nul værdier)")
}

# ============================================================================
# 11. Advanced Visualizations with Continuous Party Size
# ============================================================================

# Advanced visualization with continuous party size
if (requireNamespace("ggplot2", quietly = TRUE)) {
  # Interaction plot with continuous party size
  ggplot2::ggplot(clean_data, ggplot2::aes(x = centered_lagged_pervote_samlet, 
                                         y = miljø_afhængig)) +
    ggplot2::geom_point(ggplot2::aes(color = factor_lagged_i_parlament, 
                                   size = avg_pervote_main), 
                       alpha = 0.5) +
    ggplot2::geom_smooth(data = subset(clean_data, centered_lagged_pervote_samlet < 0),
                       method = "lm", formula = y ~ x, se = TRUE) +
    ggplot2::geom_smooth(data = subset(clean_data, centered_lagged_pervote_samlet >= 0),
                       method = "lm", formula = y ~ x, se = TRUE) +
    ggplot2::geom_vline(xintercept = 0, linetype = "dashed", color = "red") +
    ggplot2::labs(title = "Climate Position by Green Party Vote Share and Mainstream Party Size",
                x = "Green Party Vote Share (centered)",
                y = "Climate Position",
                color = "Green Party in Parliament",
                size = "Mainstream Party Size") +
    ggplot2::theme_minimal()
    
  # Visual comparison of interaction effects
  # Make predictions based on the model with continuous party size
  pred_data <- expand.grid(
    avg_pervote_main = c(10, 20, 30),  # Small, medium and large parties
    centered_lagged_pervote_samlet = seq(-5, 5, by = 0.5),
    lagged_i_parlament = c(0, 1)
  )
  
  pred_data$predicted <- predict(h5_interaction_cont, newdata = pred_data)
  
  # Add factors for nicer labels
  pred_data$party_size <- factor(pred_data$avg_pervote_main, 
                              levels = c(10, 20, 30),
                              labels = c("Lille parti (10%)", 
                                        "Mellemstort parti (20%)", 
                                        "Stort parti (30%)"))
  
  pred_data$gp_status <- factor(pred_data$lagged_i_parlament,
                              levels = c(0, 1),
                              labels = c("Grønt parti uden sæde", 
                                        "Grønt parti med sæde"))
  
  # Plot the interaction
  ggplot2::ggplot(pred_data, ggplot2::aes(x = centered_lagged_pervote_samlet, 
                                         y = predicted, 
                                         color = gp_status, 
                                         linetype = gp_status)) +
    ggplot2::geom_line() +
    ggplot2::facet_wrap(~ party_size) +
    ggplot2::geom_vline(xintercept = 0, linetype = "dashed") +
    ggplot2::theme_minimal() +
    ggplot2::labs(
      title = "Forudsagt klimaposition baseret på H5 interaktionsmodel",
      x = "Grønt partis stemmeandel (centreret ved tærskel)",
      y = "Forudsagt klimaposition",
      color = "Grønt parti status",
      linetype = "Grønt parti status"
    )
}

# ============================================================================
# 12. Comparison Summary Tables
# ============================================================================

# Create tables to compare coefficients across different model specifications
if (requireNamespace("texreg", quietly = TRUE)) {
  library(texreg)
  
  # Party size comparison
  htmlreg(list(h5_continuous_large, h5_continuous_small, 
              h5_median_rq_large, h5_median_rq_small,
              h5_robust_reg_large, h5_robust_reg_small),
         file = "h5_size_model_comparison.html",
         custom.model.names = c("OLS Large", "OLS Small", 
                               "Median Large", "Median Small", 
                               "Robust Large", "Robust Small"),
         custom.coef.names = c("Intercept", "Vote Share", "Parliament", "Vote Share × Parliament"),
         caption = "Comparison of Different Modeling Approaches for H5 by Party Size")
  
  # Comparison of binary versus continuous party size specifications
  htmlreg(list(h5_model_interaction, h5_interaction_cont, 
              h5_model_full_interaction, h5_triple),
         file = "h5_binary_continuous_comparison.html",
         custom.model.names = c("Binary Size", "Continuous Size", 
                               "Full Binary", "Full Continuous"),
         caption = "Comparison of Binary versus Continuous Party Size Specifications")
}
```


```{r Implementation af coefficient stability plots og placebo-tests}
# Definer nye funktioner for zero-inflation og kvantil regression
# Funktion til at visualisere two-part model resultater
create_two_part_model_visualization <- function(data, outcome_var, running_var, treatment_var, polynomial, bandwidth, covariates) {
  # Del 1: Sandsynlighed for ikke-nul værdier
  binary_formula <- as.formula(paste0("I(", outcome_var, " != 0) ~ ", 
                                     running_var, " * ", treatment_var, " + ", 
                                     paste0(covariates, collapse = " + ")))
  binary_model <- glm(binary_formula, family = binomial, data = data)
  
  # Del 2: Model for ikke-nul værdier
  nonzero_data <- subset(data, data[[outcome_var]] != 0)
  continuous_formula <- as.formula(paste0(outcome_var, " ~ ", 
                                        running_var, " * ", treatment_var, " + ", 
                                        paste0(covariates, collapse = " + ")))
  continuous_model <- lm(continuous_formula, data = nonzero_data)
  
  # Generer prædiktioner for visualisering
  pred_data <- expand.grid(
    temp_running = seq(min(data[[running_var]]), max(data[[running_var]]), length.out = 100),
    temp_treatment = c(0, 1)
  )
  names(pred_data) <- c(running_var, treatment_var)
  
  # Tilføj kovariater med gennemsnitsværdier
  for (cov in covariates) {
    if (is.factor(data[[cov]]) || is.character(data[[cov]])) {
      # For kategoriske variable, brug den hyppigste værdi
      pred_data[[cov]] <- names(sort(table(data[[cov]]), decreasing = TRUE)[1])
    } else {
      # For numeriske variable, brug gennemsnit
      pred_data[[cov]] <- mean(data[[cov]], na.rm = TRUE)
    }
  }
  
  # Beregn prædikterede værdier
  pred_data$binary_pred <- predict(binary_model, newdata = pred_data, type = "response")
  
  # For continuous_model, skal vi håndtere at det kun er for ikke-nul værdier
  # Vi bruger en dummy værdi for kontinuert model prædiktioner
  pred_data$continuous_pred <- 0
  try({
    pred_data$continuous_pred <- predict(continuous_model, newdata = pred_data)
  }, silent = TRUE)
  
  # Beregn samlet effekt (sandsynlighed for ikke-nul * værdi givet ikke-nul)
  pred_data$combined_effect <- pred_data$binary_pred * pred_data$continuous_pred
  
  # Forbered data til plot
  pred_data$treatment_label <- factor(pred_data[[treatment_var]], 
                                    levels = c(0, 1), 
                                    labels = c("Uden behandling", "Med behandling"))
  
  # Lav plot
  library(ggplot2)
  p1 <- ggplot(pred_data, aes(x = .data[[running_var]], y = binary_pred, color = treatment_label)) +
    geom_line() +
    geom_vline(xintercept = 0, linetype = "dashed") +
    labs(title = "Sandsynlighed for ikke-nul klimaposition",
         x = paste0(running_var, " (centreret)"),
         y = "Sandsynlighed",
         color = "Behandlingsstatus") +
    theme_minimal()
  
  p2 <- ggplot(pred_data, aes(x = .data[[running_var]], y = continuous_pred, color = treatment_label)) +
    geom_line() +
    geom_vline(xintercept = 0, linetype = "dashed") +
    labs(title = "Værdi af klimaposition givet ikke-nul",
         x = paste0(running_var, " (centreret)"),
         y = "Værdi",
         color = "Behandlingsstatus") +
    theme_minimal()
  
  p3 <- ggplot(pred_data, aes(x = .data[[running_var]], y = combined_effect, color = treatment_label)) +
    geom_line() +
    geom_vline(xintercept = 0, linetype = "dashed") +
    labs(title = "Samlet effekt: Sandsynlighed * Værdi",
         x = paste0(running_var, " (centreret)"),
         y = "Forventet værdi",
         color = "Behandlingsstatus") +
    theme_minimal()
  
  # Kombiner plots
  if (requireNamespace("gridExtra", quietly = TRUE)) {
    combined_plot <- gridExtra::grid.arrange(p1, p2, p3, ncol = 1,
                                           top = "Two-part model resultater")
    return(combined_plot)
  } else {
    # Returner det vigtigste plot hvis gridExtra ikke er tilgængelig
    return(p3)
  }
}

# Funktion til at visualisere kvantil regressionseffekter
create_quantile_effect_plot <- function(data, outcome_var, running_var, treatment_var, quantiles, covariates, title) {
  library(quantreg)
  library(ggplot2)
  
  # Forbered resultater
  results <- data.frame(
    Quantile = numeric(),
    Estimate = numeric(),
    StdError = numeric(),
    Lower = numeric(),
    Upper = numeric()
  )
  
  # Kør kvantil regression for hver kvantil
  for (q in quantiles) {
    formula_str <- paste0(outcome_var, " ~ ", running_var, " * ", treatment_var)
    if (length(covariates) > 0) {
      formula_str <- paste0(formula_str, " + ", paste0(covariates, collapse = " + "))
    }
    
    rq_model <- rq(as.formula(formula_str), tau = q, data = data)
    coef_summary <- summary(rq_model)
    
    # Få koefficienten for treatment
    coef_idx <- which(rownames(coef_summary$coefficients) == treatment_var)
    if (length(coef_idx) > 0) {
      estimate <- coef_summary$coefficients[coef_idx, 1]
      std_error <- coef_summary$coefficients[coef_idx, 2]
      
      # Beregn konfidensinterval
      lower <- estimate - 1.96 * std_error
      upper <- estimate + 1.96 * std_error
      
      results <- rbind(results, data.frame(
        Quantile = q,
        Estimate = estimate,
        StdError = std_error,
        Lower = lower,
        Upper = upper
      ))
    }
  }
  
  # Lav plot
  p <- ggplot(results, aes(x = Quantile, y = Estimate)) +
    geom_line() +
    geom_ribbon(aes(ymin = Lower, ymax = Upper), alpha = 0.2) +
    geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
    labs(title = title,
         x = "Kvantil",
         y = "Estimeret effekt af behandling") +
    theme_minimal()
  
  return(p)
}

# 1. Coefficient Stability Plots

## 1.1 For H1 (hovedmodellen)
h1_stability_plot <- create_coefficient_stability_plot(
  data = clean_data,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomials = c(1, 2, 3),
  covariates = c("country", "edate"),
  title = "H1: Når grønne partier kommer ind i parlamentet, falder klimafokus"
)

# Gem plottet
ggsave("h1_stability_plot.png", plot = h1_stability_plot$plot, width = 10, height = 6, dpi = 300)

## 1.2 For H2 (RRP effekt) opdelt efter RRP status
# Opdel data baseret på RRP status
data_no_rrp <- na.omit(subset(clean_data, rrp_i_p_lag1 == 0))
data_with_rrp <- na.omit(subset(clean_data, rrp_i_p_lag1 == 1))


# Lav sammenligning af koefficienter for forskellige polynomiske grader
h2_comparison_plot_p1 <- compare_coefficient_stability(
  data_list = list(data_no_rrp, data_with_rrp),
  labels = c("Ingen højreradikale partier", "Højreradikale partier i parlament"),
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomial = 1,
  covariates = c("country", "edate"),
  title = "H2: Effekt af grønne partier (polynomisk grad 1)"
)

h2_comparison_plot_p2 <- compare_coefficient_stability(
  data_list = list(data_no_rrp, data_with_rrp),
  labels = c("Ingen højreradikale partier", "Højreradikale partier i parlament"),
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomial = 2,
  covariates = c("country", "edate"),
  title = "H2: Effekt af grønne partier (polynomisk grad 2)"
)

h2_comparison_plot_p3 <- compare_coefficient_stability(
  data_list = list(data_no_rrp, data_with_rrp),
  labels = c("Ingen højreradikale partier", "Højreradikale partier i parlament"),
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomial = 3,
  covariates = c("country", "edate"),
  title = "H2: Effekt af grønne partier (polynomisk grad 3)"
)

h2_comparison_plot_p4 <- compare_coefficient_stability(
  data_list = list(data_no_rrp, data_with_rrp),
  labels = c("Ingen højreradikale partier", "Højreradikale partier i parlament"),
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomial = 4,
  covariates = c("country", "edate"),
  title = "H2: Effekt af grønne partier (polynomisk grad 4)"
)

# Kombinér alle fire plots i ét grid
if (requireNamespace("gridExtra", quietly = TRUE)) {
  h2_all_poly_comparison <- gridExtra::grid.arrange(
    h2_comparison_plot_p1, h2_comparison_plot_p2,
    h2_comparison_plot_p3, h2_comparison_plot_p4,
    ncol = 2, nrow = 2,
    top = "H2: Effekt af grønne partier modereret af højreradikale partier"
  )
  
  # Gem det kombinerede plot
  ggsave("h2_all_polynomial_comparison.png", h2_all_poly_comparison, width = 12, height = 10, dpi = 300)
}

## 1.3 For H3 (økonomiske betingelser)
# H3 implementeringen har to varianter:
# 1. BNP-vækst som moderator
# 2. Sammensat økonomisk indikator som moderator

# Opdel data baseret på BNP-vækst
high_gdp_stability_plot <- create_coefficient_stability_plot(
  data = clean_data_high_gdp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomials = c(1, 2, 3),
  covariates = c("country", "edate"),
  title = "H3: Effekt ved høj BNP-vækst"
)

low_gdp_stability_plot <- create_coefficient_stability_plot(
  data = clean_data_low_gdp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomials = c(1, 2, 3),
  covariates = c("country", "edate"),
  title = "H3: Effekt ved lav BNP-vækst"
)

# Gem plottene
pdf("h3_high_gdp_stability.pdf", width = 10, height = 6)
print(high_gdp_stability_plot)
dev.off()

pdf("h3_low_gdp_stability.pdf", width = 10, height = 6)
print(low_gdp_stability_plot)
dev.off()
## 1.2 Sammensat økonomisk indikator
good_economy_stability_plot <- create_coefficient_stability_plot(
  data = clean_data_good_economy,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomials = c(1, 2, 3),
  covariates = c("country", "edate"),
  title = "H3: Effekt under gode økonomiske forhold"
)

bad_economy_stability_plot <- create_coefficient_stability_plot(
  data = clean_data_bad_economy,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomials = c(1, 2, 3),
  covariates = c("country", "edate"),
  title = "H3: Effekt under dårlige økonomiske forhold"
)

# Gem plottene
pdf("h3_good_economy_stability.pdf", width = 10, height = 6)
print(good_economy_stability_plot)
dev.off()

pdf("h3_bad_economy_stability.pdf", width = 10, height = 6)
print(bad_economy_stability_plot)
dev.off()

## 1.4 For H4 (partiideologi)
# Opdel data baseret på partiideologi
left_parties <- subset(clean_data, left_party == 1)
right_parties <- subset(clean_data, left_party == 0)

h4_comparison_plot <- compare_coefficient_stability(
  data_list = list(left_parties, right_parties),
  labels = c("Venstreorienterede partier", "Højreorienterede partier"),
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomial = 1,
  covariates = c("country", "edate"),
  title = "H4: Effekt af grønne partier opdelt efter partiideologi"
)

# Gem plottet
ggsave("h4_comparison_plot.png", plot = h4_comparison_plot, width = 10, height = 6, dpi = 300)

## 1.4 For H5 (partistørrelse)
# Opdel data baseret på partistørrelse
large_parties <- subset(clean_data, large_party == 1)
small_parties <- subset(clean_data, large_party == 0)

h5_comparison_plot <- compare_coefficient_stability(
  data_list = list(large_parties, small_parties),
  labels = c("Store partier", "Små partier"),
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomial = 1,
  covariates = c("country", "edate"),
  title = "H5: Effekt af grønne partier opdelt efter partistørrelse"
)

# Gem plottet
ggsave("h5_comparison_plot.png",plot = h5_comparison_plot, width = 10, height = 6, dpi = 300)

## 1.5 Dot-whisker plot for alle modeller
# Lav en kompakt sammenligning af alle modeller
all_models_dot_whisker <- create_dotwhisker_plot(
  data_list = list(
    clean_data,
    left_parties,
    right_parties,
    large_parties,
    small_parties,
    data_no_rrp,
    data_with_rrp,
    clean_data_high_gdp,
    clean_data_low_gdp,
    clean_data_good_economy,
    clean_data_bad_economy   
  ),
  labels = c(
    "Fuld sample",
    "Venstreorienterede",
    "Højreorienterede",
    "Store partier",
    "Små partier",
    "Uden højreradikale",
    "Med højreradikale",
    "Høj BNP-vækst",        
    "Lav BNP-vækst",         
    "God økonomi (indeks)",   
    "Dårlig økonomi (indeks)" 
  ),
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_values = c(1, 2, 3),
  polynomial = 1,
  covariates = c("country", "edate"),
  title = "Sammenligning af effekter på tværs af alle modeller og moderatorer"
)

# Gem plottet
ggsave("all_models_dot_whisker.png", plot = all_models_dot_whisker, width = 12, height = 8, dpi = 300)

## 1.6 Kvantil regression effektplot
# NY TILFØJELSE: Visualiser heterogene effekter på tværs af kvantiler
quantile_effect_plot <- create_quantile_effect_plot(
  data = clean_data,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  quantiles = seq(0.1, 0.9, by = 0.1),
  covariates = c("country", "edate"),
  title = "Heterogene effekter på tværs af kvantiler i fordelingen"
)

# Gem plottet
ggsave("h1_quantile_effects.png", plot = quantile_effect_plot, width = 10, height = 6, dpi = 300)

# 2. Placebo Tests

## 2.1 Placebo-tærskel test for H1 (hovedmodellen)
h1_placebo_threshold <- run_placebo_threshold_test(
  data = clean_data,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  true_cutpoint = 0,
  placebo_range = c(-4, 4),
  placebo_step = 0.5,
  polynomial = 1,
  bandwidth = 2,  # Fast båndbredde for konsistens
  covariates = c("country", "edate")
)

# Plot resultaterne
h1_placebo_plot <- plot_placebo_threshold_test(
  h1_placebo_threshold,
  title = "H1: Placebo-tærskel test for hovedmodellen"
)

# Gem plottet
ggsave("h1_placebo_plot.png", plot = h1_placebo_plot, width = 10, height = 6, dpi = 300)

## 2.2 Outcome placebo test for H1
# Vælg placebo variables som ikke burde påvirkes af grønne partiers indtrædelse
# For eksempel: andre politiske positioner eller non-relaterede manifesto-kategorier
placebo_vars <- c("rile_lowe")  # Erstatter med relevante placebo variables

# Kør outcome placebo test
h1_outcome_placebo <- run_outcome_placebo_test(
  data = clean_data,
  real_outcome_var = "miljø_afhængig",
  placebo_outcome_vars = placebo_vars,
  running_var = "centered_lagged_pervote_samlet",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

# Plot resultaterne
h1_outcome_placebo_plot <- plot_outcome_placebo_test(
  h1_outcome_placebo,
  title = "H1: Outcome placebo test"
)

# Gem plottet
ggsave("h1_outcome_placebo_plot.png", plot = h1_outcome_placebo_plot, width = 10, height = 6, dpi = 300)

## 2.3 Permutationstest for H1
h1_permutation <- run_permutation_test(
  data = clean_data,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  n_permutations = 500,  # Antal permutationer (kan øges for mere præcision)
  covariates = c("country", "edate")
)

# Plot resultaterne
h1_permutation_plot <- plot_permutation_test(
  h1_permutation,
  title = "H1: Permutationstest"
)

# Gem plottet
ggsave("h1_permutation_plot.png", plot = h1_permutation_plot, width = 10, height = 6, dpi = 300)

## 2.4 Visualisering af two-part model resultater
# NY TILFØJELSE: Visualisering af two-part model
two_part_plot <- create_two_part_model_visualization(
  data = clean_data,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

# Gem plottet
ggsave("h1_two_part_model.png", plot = two_part_plot, width = 10, height = 8, dpi = 300)

# 3. For inclusion in appendix - Coefficient stability plots for all hypotheses
# Generér individuelle coefficient stability plots for hver model som skal i appendix

## 3.1 H2 individuelle plots
h2_no_rrp_plot <- create_coefficient_stability_plot(
  data = data_no_rrp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomials = c(1, 2, 3),
  covariates = c("country", "edate"),
  title = "H2: Ingen højreradikale partier"
)

h2_with_rrp_plot <- create_coefficient_stability_plot(
  data = data_with_rrp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomials = c(1, 2, 3),
  covariates = c("country", "edate"),
  title = "H2: Med højreradikale partier"
)

# Gem plottene
# For h2_no_rrp_plot
pdf("h2_no_rrp_plot.pdf", width = 10, height = 6)
print(h2_no_rrp_plot)
dev.off()

# For h2_with_rrp_plot
pdf("h2_with_rrp_plot.pdf", width = 10, height = 6)
print(h2_with_rrp_plot)
dev.off()

## 3.2 Placebo-tærskel tests (bnp-vækst)
# Høj BNP-vækst
h3_high_gdp_placebo <- run_placebo_threshold_test(
  data = clean_data_high_gdp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  true_cutpoint = 0,
  placebo_range = c(-4, 4),
  placebo_step = 0.5,
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

h3_high_gdp_placebo_plot <- plot_placebo_threshold_test(
  h3_high_gdp_placebo,
  title = "H3: Placebo test (høj BNP-vækst)"
)

# Lav BNP-vækst
h3_low_gdp_placebo <- run_placebo_threshold_test(
  data = clean_data_low_gdp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  true_cutpoint = 0,
  placebo_range = c(-4, 4),
  placebo_step = 0.5,
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

h3_low_gdp_placebo_plot <- plot_placebo_threshold_test(
  h3_low_gdp_placebo,
  title = "H3: Placebo test (lav BNP-vækst)"
)

# Gem placebo plots for BNP-vækst
ggsave("h3_high_gdp_placebo.png", plot = h3_high_gdp_placebo_plot, width = 10, height = 10, dpi = 300)
ggsave("h3_low_gdp_placebo.png", plot = h3_low_gdp_placebo_plot, width = 10, height = 10, dpi = 300)

## Placebo-tærskel tests (sammensat økonomisk indikator)
# God økonomi
h3_good_economy_placebo <- run_placebo_threshold_test(
  data = clean_data_good_economy,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  true_cutpoint = 0,
  placebo_range = c(-4, 4),
  placebo_step = 0.5,
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

h3_good_economy_placebo_plot <- plot_placebo_threshold_test(
  h3_good_economy_placebo,
  title = "H3: Placebo test (god økonomi)"
)

# Dårlig økonomi
h3_bad_economy_placebo <- run_placebo_threshold_test(
  data = clean_data_bad_economy,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  true_cutpoint = 0,
  placebo_range = c(-4, 4),
  placebo_step = 0.5,
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

h3_bad_economy_placebo_plot <- plot_placebo_threshold_test(
  h3_bad_economy_placebo,
  title = "H3: Placebo test (dårlig økonomi)"
)

# Gem placebo plots for sammensat økonomisk indikator
ggsave("h3_good_economy_placebo.png", plot = h3_good_economy_placebo_plot, width = 10, height = 10, dpi = 300)
ggsave("h3_bad_economy_placebo.png", plot = h3_bad_economy_placebo_plot, width = 10, height = 10, dpi = 300)

## Outcome placebo tests
# For høj BNP-vækst
placebo_vars <- c("rile_lowe", "per410")  # Placebo variabler der ikke burde påvirkes

h3_high_gdp_outcome_placebo <- run_outcome_placebo_test(
  data = clean_data_high_gdp,
  real_outcome_var = "miljø_afhængig",
  placebo_outcome_vars = placebo_vars,
  running_var = "centered_lagged_pervote_samlet",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

h3_high_gdp_outcome_placebo_plot <- plot_outcome_placebo_test(
  h3_high_gdp_outcome_placebo,
  title = "H3: Outcome placebo test (høj BNP-vækst)"
)

# For lav BNP-vækst
h3_low_gdp_outcome_placebo <- run_outcome_placebo_test(
  data = clean_data_low_gdp,
  real_outcome_var = "miljø_afhængig",
  placebo_outcome_vars = placebo_vars,
  running_var = "centered_lagged_pervote_samlet",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

h3_low_gdp_outcome_placebo_plot <- plot_outcome_placebo_test(
  h3_low_gdp_outcome_placebo,
  title = "H3: Outcome placebo test (lav BNP-vækst)"
)

# Gem outcome placebo plots
ggsave("h3_high_gdp_outcome_placebo.png", plot = h3_high_gdp_outcome_placebo_plot, width = 8, height = 6, dpi = 300)
ggsave("h3_low_gdp_outcome_placebo.png", plot = h3_low_gdp_outcome_placebo_plot, width = 8, height = 6, dpi = 300)

## Permutations tests
# For høj BNP-vækst
h3_high_gdp_permutation <- run_permutation_test(
  data = clean_data_high_gdp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  n_permutations = 500,
  covariates = c("country", "edate")
)

h3_high_gdp_permutation_plot <- plot_permutation_test(
  h3_high_gdp_permutation,
  title = "H3: Permutationstest (høj BNP-vækst)"
)

# For lav BNP-vækst
h3_low_gdp_permutation <- run_permutation_test(
  data = clean_data_low_gdp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  n_permutations = 500,
  covariates = c("country", "edate")
)

h3_low_gdp_permutation_plot <- plot_permutation_test(
  h3_low_gdp_permutation,
  title = "H3: Permutationstest (lav BNP-vækst)"
)

# Gem permutation plots
ggsave("h3_high_gdp_permutation.png", plot = h3_high_gdp_permutation_plot, width = 8, height = 10, dpi = 300)
ggsave("h3_low_gdp_permutation.png", plot = h3_low_gdp_permutation_plot, width = 8, height = 10, dpi = 300)

## Permutationstest for H2 (RRP-effekt)
# For H2 uden højreradikale partier
h2_no_rrp_permutation <- run_permutation_test(
  data = data_no_rrp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  n_permutations = 500,
  covariates = c("country", "edate")
)

h2_no_rrp_permutation_plot <- plot_permutation_test(
  h2_no_rrp_permutation,
  title = "H2: Permutationstest (uden højreradikale partier)"
)

# For H2 med højreradikale partier
h2_with_rrp_permutation <- run_permutation_test(
  data = data_with_rrp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  n_permutations = 500,
  covariates = c("country", "edate")
)

h2_with_rrp_permutation_plot <- plot_permutation_test(
  h2_with_rrp_permutation,
  title = "H2: Permutationstest (med højreradikale partier)"
)

# Gem permutation plots for H2
ggsave("h2_no_rrp_permutation.png", plot = h2_no_rrp_permutation_plot, width = 8, height = 10, dpi = 300)
ggsave("h2_with_rrp_permutation.png", plot = h2_with_rrp_permutation_plot, width = 8, height = 10, dpi = 300)

## Permutationstest for H4 (partiideologi)
# For H4 venstreorienterede partier
h4_left_permutation <- run_permutation_test(
  data = left_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  n_permutations = 500,
  covariates = c("country", "edate")
)

h4_left_permutation_plot <- plot_permutation_test(
  h4_left_permutation,
  title = "H4: Permutationstest (venstreorienterede partier)"
)

# For H4 højreorienterede partier
h4_right_permutation <- run_permutation_test(
  data = right_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  n_permutations = 500,
  covariates = c("country", "edate")
)

h4_right_permutation_plot <- plot_permutation_test(
  h4_right_permutation,
  title = "H4: Permutationstest (højreorienterede partier)"
)

# Gem permutation plots for H4
ggsave("h4_left_permutation.png", plot = h4_left_permutation_plot, width = 8, height = 10, dpi = 300)
ggsave("h4_right_permutation.png", plot = h4_right_permutation_plot, width = 8, height = 10, dpi = 300)

## Permutationstest for H5 (partistørrelse)
# For H5 store partier
h5_large_permutation <- run_permutation_test(
  data = large_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  n_permutations = 500,
  covariates = c("country", "edate")
)

h5_large_permutation_plot <- plot_permutation_test(
  h5_large_permutation,
  title = "H5: Permutationstest (store partier)"
)

# For H5 små partier
h5_small_permutation <- run_permutation_test(
  data = small_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  n_permutations = 500,
  covariates = c("country", "edate")
)

h5_small_permutation_plot <- plot_permutation_test(
  h5_small_permutation,
  title = "H5: Permutationstest (små partier)"
)

# Gem permutation plots for H5
ggsave("h5_large_permutation.png", plot = h5_large_permutation_plot, width = 8, height = 10, dpi = 300)
ggsave("h5_small_permutation.png", plot = h5_small_permutation_plot, width = 8, height = 10, dpi = 300)

# Opsummering af resultater for metodeafsnittet
# Tilføj H3 resultater til den samlede oversigt over placebo p-værdier
h3_placebo_summary <- data.frame(
  Model = c(
    "H3: Høj BNP-vækst",
    "H3: Lav BNP-vækst",
    "H3: God økonomi (sammensat)",
    "H3: Dårlig økonomi (sammensat)"
  ),
  Placebo_p_value = c(
    h3_high_gdp_placebo$empirical_p_value,
    h3_low_gdp_placebo$empirical_p_value,
    h3_good_economy_placebo$empirical_p_value,
    h3_bad_economy_placebo$empirical_p_value
  )
)

## 3.2 H4 individuelle plots
h4_left_plot <- create_coefficient_stability_plot(
  data = left_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomials = c(1, 2, 3),
  covariates = c("country", "edate"),
  title = "H4: Venstreorienterede partier"
)

h4_right_plot <- create_coefficient_stability_plot(
  data = right_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomials = c(1, 2, 3),
  covariates = c("country", "edate"),
  title = "H4: Højreorienterede partier"
)

# Gem plottene
pdf("h4_left_plot.pdf", width = 10, height = 6)
print(h4_left_plot)
dev.off()

pdf("h4_right_plot.pdf", width = 10, height = 6)
print(h4_right_plot)
dev.off()

## 3.3 H5 individuelle plots
h5_large_plot <- create_coefficient_stability_plot(
  data = large_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomials = c(1, 2, 3),
  covariates = c("country", "edate"),
  title = "H5: Store partier"
)

h5_small_plot <- create_coefficient_stability_plot(
  data = small_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomials = c(1, 2, 3),
  covariates = c("country", "edate"),
  title = "H5: Små partier"
)

# Gem plottene
pdf("h5_large_plot.pdf", width = 10, height = 6)
print(h5_large_plot)
dev.off()

pdf("h5_small_plot.pdf", width = 10, height = 6)
print(h5_small_plot)
dev.off()

# 4. Placebo tests i appendix
# Kør placebo tests for alle modeller (for appendix)

## 4.1 Placebo-tærskel tests for alle modeller
# For H2 opdelt efter RRP status
h2_no_rrp_placebo <- run_placebo_threshold_test(
  data = data_no_rrp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

h2_with_rrp_placebo <- run_placebo_threshold_test(
  data = data_with_rrp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

# Plot og gem
h2_no_rrp_placebo_plot <- plot_placebo_threshold_test(
  h2_no_rrp_placebo,
  title = "H2: Placebo test (uden højreradikale partier)"
)

h2_with_rrp_placebo_plot <- plot_placebo_threshold_test(
  h2_with_rrp_placebo,
  title = "H2: Placebo test (med højreradikale partier)"
)

ggsave("h2_no_rrp_placebo.png", plot = h2_no_rrp_placebo_plot, width = 10, height = 6, dpi = 300)
ggsave("h2_with_rrp_placebo.png", plot = h2_with_rrp_placebo_plot, width = 10, height = 6, dpi = 300)

# For H4 opdelt efter partiideologi
h4_left_placebo <- run_placebo_threshold_test(
  data = left_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

h4_right_placebo <- run_placebo_threshold_test(
  data = right_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

# Plot og gem
h4_left_placebo_plot <- plot_placebo_threshold_test(
  h4_left_placebo,
  title = "H4: Placebo test (venstreorienterede partier)"
)

h4_right_placebo_plot <- plot_placebo_threshold_test(
  h4_right_placebo,
  title = "H4: Placebo test (højreorienterede partier)"
)

ggsave("h4_left_placebo.png", plot = h4_left_placebo_plot, width = 10, height = 10, dpi = 300)
ggsave("h4_right_placebo.png", plot = h4_right_placebo_plot, width = 10, height = 10, dpi = 300)

# For H5 opdelt efter partistørrelse
h5_large_placebo <- run_placebo_threshold_test(
  data = large_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

h5_small_placebo <- run_placebo_threshold_test(
  data = small_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

# Plot og gem
h5_large_placebo_plot <- plot_placebo_threshold_test(
  h5_large_placebo,
  title = "H5: Placebo test (store partier)"
)

h5_small_placebo_plot <- plot_placebo_threshold_test(
  h5_small_placebo,
  title = "H5: Placebo test (små partier)"
)

ggsave("h5_large_placebo.png", plot = h5_large_placebo_plot, width = 10, height = 10, dpi = 300)
ggsave("h5_small_placebo.png", plot = h5_small_placebo_plot, width = 10, height = 10, dpi = 300)

# 5. Opsummering af resultater i tabelform
# Lav tabel til metodeafsnittet med resultater fra alle modeller

# Sammenfat empiriske p-værdier fra placebo tests
placebo_summary <- data.frame(
  Model = c(
    "H1: Alle partier",
    "H2: Uden højreradikale partier",
    "H2: Med højreradikale partier",
    "H3: Høj BNP-vækst",
    "H3: Lav BNP-vækst",
    "H3: God økonomi (sammensat)",
    "H3: Dårlig økonomi (sammensat)",
    "H4: Venstreorienterede partier",
    "H4: Højreorienterede partier",
    "H5: Store partier",
    "H5: Små partier"
  ),
  Placebo_p_value = c(
    h1_placebo_threshold$empirical_p_value,
    h2_no_rrp_placebo$empirical_p_value,
    h2_with_rrp_placebo$empirical_p_value,
    h3_high_gdp_placebo$empirical_p_value,
    h3_low_gdp_placebo$empirical_p_value,
    h3_good_economy_placebo$empirical_p_value,
    h3_bad_economy_placebo$empirical_p_value,
    h4_left_placebo$empirical_p_value,
    h4_right_placebo$empirical_p_value,
    h5_large_placebo$empirical_p_value,
    h5_small_placebo$empirical_p_value
  )
)

# Print tabellen
print(placebo_summary)

permutation_summary <- data.frame(
  Model = c(
    "H1: Alle partier",
    "H2: Uden højreradikale partier",
    "H2: Med højreradikale partier",
    "H3: Høj BNP-vækst",
    "H3: Lav BNP-vækst",
    "H4: Venstreorienterede partier",
    "H4: Højreorienterede partier",
    "H5: Store partier",
    "H5: Små partier"
  ),
  Permutation_p_value = c(
    h1_permutation$p_value_effect,
    h2_no_rrp_permutation$p_value_effect,
    h2_with_rrp_permutation$p_value_effect,
    h3_high_gdp_permutation$p_value_effect,
    h3_low_gdp_permutation$p_value_effect,
    h4_left_permutation$p_value_effect,
    h4_right_permutation$p_value_effect,
    h5_large_permutation$p_value_effect,
    h5_small_permutation$p_value_effect
  )
)

print(permutation_summary)

# Gem som fil
write.csv(placebo_summary, "placebo_summary.csv", row.names = FALSE)

# 6. Sammenligning af forskellige robuste estimationsmetoder (NY TILFØJELSE)
# Denne tabel sammenligner resultaterne fra forskellige robuste estimationsmetoder
# Bemærk: Dette kræver at modellerne fra H1-analysen er tilgængelige i environment

# Prøv at hente modellerne, hvis de findes
tryCatch({
  robust_methods_comparison <- data.frame(
    Model = c(
      "H1: OLS (alle observationer)",
      "H1: OLS (kun non-zero)",
      "H1: Quantile (median)",
      "H1: Robust regression (MM)",
      "H1: rdrobust (optimal bw)",
      "H1: rdrobust (fixed bw)"
    ),
    Estimate = c(
      # Indsæt de faktiske estimater fra dine modeller her
      coef(h1_model_interaction)["lagged_i_parlament"],
      coef(h1_continuous)["lagged_i_parlament"],
      coef(h1_median_rq)["lagged_i_parlament"],
      coef(h1_robust_reg)["lagged_i_parlament"],
      summary(h1_rdd)$coef[1],
      summary(h1_rdd_alt)$coef[1]
    ),
    SE = c(
      # Indsæt standardfejl her
      summary(h1_model_interaction)$coefficients["lagged_i_parlament", "Std. Error"],
      summary(h1_continuous)$coefficients["lagged_i_parlament", "Std. Error"],
      summary(h1_median_rq)$coefficients["lagged_i_parlament", "Std. Error"],
      summary(h1_robust_reg)$coefficients["lagged_i_parlament", "Std. Error"],
      summary(h1_rdd)$se[1],
      summary(h1_rdd_alt)$se[1]
    ),
    P_value = c(
      # Indsæt p-værdier her
      summary(h1_model_interaction)$coefficients["lagged_i_parlament", "Pr(>|t|)"],
      summary(h1_continuous)$coefficients["lagged_i_parlament", "Pr(>|t|)"],
      summary(h1_median_rq)$coefficients["lagged_i_parlament", 4],
      # Beregn p-værdi for robust regression
      2 * pt(abs(coef(h1_robust_reg)["lagged_i_parlament"] / 
                 summary(h1_robust_reg)$coefficients["lagged_i_parlament", "Std. Error"]), 
             df = nrow(clean_data) - ncol(model.matrix(h1_robust_reg)), lower.tail = FALSE),
      summary(h1_rdd)$pv[1],
      summary(h1_rdd_alt)$pv[1]
    )
  )
  
  # Tilføj signifikansstjerner
  robust_methods_comparison$Significance <- ""
  robust_methods_comparison$Significance[robust_methods_comparison$P_value < 0.1] <- "."
  robust_methods_comparison$Significance[robust_methods_comparison$P_value < 0.05] <- "*"
  robust_methods_comparison$Significance[robust_methods_comparison$P_value < 0.01] <- "**"
  robust_methods_comparison$Significance[robust_methods_comparison$P_value < 0.001] <- "***"
  
  # Formater tal
  robust_methods_comparison$Estimate <- sprintf("%.3f", robust_methods_comparison$Estimate)
  robust_methods_comparison$SE <- sprintf("%.3f", robust_methods_comparison$SE)
  robust_methods_comparison$P_value <- sprintf("%.4f", robust_methods_comparison$P_value)
  
  # Kombiner estimat og signifikans
  robust_methods_comparison$Estimate_with_stars <- paste0(
    robust_methods_comparison$Estimate, 
    robust_methods_comparison$Significance
  )
  
  # Print tabellen
  print(robust_methods_comparison)
  
  # Gem som fil
  write.csv(robust_methods_comparison, "robust_methods_comparison.csv", row.names = FALSE)
  
  # Gem som pæn tabel
  if (requireNamespace("knitr", quietly = TRUE)) {
    print(knitr::kable(robust_methods_comparison[, c("Model", "Estimate_with_stars", "SE", "P_value")], 
                      caption = "Sammenligning af forskellige robuste estimationsmetoder"))
  }
}, error = function(e) {
  cat("Kunne ikke generere robust methods comparison tabel: ", e$message, "\n")
  cat("Dette kræver at h1_model_interaction, h1_continuous, h1_median_rq, h1_robust_reg, h1_rdd og h1_rdd_alt er i dit environment.\n")
})

# 7. Two-part model tests for alle undergrupper (NY TILFØJELSE)
# Generer two-part model visualiseringer for hver undergruppe

# For H2 opdelt efter RRP status
h2_no_rrp_two_part <- create_two_part_model_visualization(
  data = data_no_rrp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

h2_with_rrp_two_part <- create_two_part_model_visualization(
  data = data_with_rrp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

# Gem plottene
ggsave("h2_no_rrp_two_part.png", plot = h2_no_rrp_two_part, width = 10, height = 8, dpi = 300)
ggsave("h2_with_rrp_two_part.png", plot = h2_with_rrp_two_part, width = 10, height = 8, dpi = 300)

# For H4 opdelt efter partiideologi
h4_left_two_part <- create_two_part_model_visualization(
  data = left_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

h4_right_two_part <- create_two_part_model_visualization(
  data = right_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

# Gem plottene
ggsave("h4_left_two_part.png", plot = h4_left_two_part, width = 10, height = 8, dpi = 300)
ggsave("h4_right_two_part.png", plot = h4_right_two_part, width = 10, height = 8, dpi = 300)

# For H5 opdelt efter partistørrelse
h5_large_two_part <- create_two_part_model_visualization(
  data = large_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

h5_small_two_part <- create_two_part_model_visualization(
  data = small_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

# Gem plottene
ggsave("h5_large_two_part.png", plot = h5_large_two_part, width = 10, height = 8, dpi = 300)
ggsave("h5_small_two_part.png", plot = h5_small_two_part, width = 10, height = 8, dpi = 300)

# 8. Sammenligning af zero vs. non-zero effekter på tværs af alle undergrupper (NY TILFØJELSE)
# Denne tabel sammenligner effekten på sandsynligheden for ikke-nul værdier mod intensiteten af ikke-nul værdier

# For hver undergruppe, kør en binær model og en kontinuert model
# H1
h1_binary <- glm(I(miljø_afhængig != 0) ~ centered_lagged_pervote_samlet * lagged_i_parlament,
               family = binomial, data = clean_data)
h1_continuous <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                  data = subset(clean_data, miljø_afhængig != 0))

# H2
h2_no_rrp_binary <- glm(I(miljø_afhængig != 0) ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                      family = binomial, data = data_no_rrp)
h2_no_rrp_continuous <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                         data = subset(data_no_rrp, miljø_afhængig != 0))

h2_with_rrp_binary <- glm(I(miljø_afhængig != 0) ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                        family = binomial, data = data_with_rrp)
h2_with_rrp_continuous <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                           data = subset(data_with_rrp, miljø_afhængig != 0))

# Skab en sammenligningssabel
zero_nonzero_comparison <- data.frame(
  Model = c(
    "H1: Alle partier",
    "H2: Uden højreradikale partier",
    "H2: Med højreradikale partier",
    "H4: Venstreorienterede partier",
    "H4: Højreorienterede partier",
    "H5: Store partier",
    "H5: Små partier"
  ),
  Binary_Estimate = c(
    coef(h1_binary)["lagged_i_parlament"],
    coef(h2_no_rrp_binary)["lagged_i_parlament"],
    coef(h2_with_rrp_binary)["lagged_i_parlament"],
    coef(h4_binary_left)["lagged_i_parlament"],
    coef(h4_binary_right)["lagged_i_parlament"],
    coef(h5_binary_large)["lagged_i_parlament"],
    coef(h5_binary_small)["lagged_i_parlament"]
  ),
  Binary_SE = c(
    summary(h1_binary)$coefficients["lagged_i_parlament", "Std. Error"],
    summary(h2_no_rrp_binary)$coefficients["lagged_i_parlament", "Std. Error"],
    summary(h2_with_rrp_binary)$coefficients["lagged_i_parlament", "Std. Error"],
    summary(h4_binary_left)$coefficients["lagged_i_parlament", "Std. Error"],
    summary(h4_binary_right)$coefficients["lagged_i_parlament", "Std. Error"],
    summary(h5_binary_large)$coefficients["lagged_i_parlament", "Std. Error"],
    summary(h5_binary_small)$coefficients["lagged_i_parlament", "Std. Error"]
  ),
  Binary_P = c(
    summary(h1_binary)$coefficients["lagged_i_parlament", "Pr(>|z|)"],
    summary(h2_no_rrp_binary)$coefficients["lagged_i_parlament", "Pr(>|z|)"],
    summary(h2_with_rrp_binary)$coefficients["lagged_i_parlament", "Pr(>|z|)"],
    summary(h4_binary_left)$coefficients["lagged_i_parlament", "Pr(>|z|)"],
    summary(h4_binary_right)$coefficients["lagged_i_parlament", "Pr(>|z|)"],
    summary(h5_binary_large)$coefficients["lagged_i_parlament", "Pr(>|z|)"],
    summary(h5_binary_small)$coefficients["lagged_i_parlament", "Pr(>|z|)"]
  ),
  Continuous_Estimate = c(
    coef(h1_continuous)["lagged_i_parlament"],
    coef(h2_no_rrp_continuous)["lagged_i_parlament"],
    coef(h2_with_rrp_continuous)["lagged_i_parlament"],
    coef(h4_continuous_left)["lagged_i_parlament"],
    coef(h4_continuous_right)["lagged_i_parlament"],
    coef(h5_continuous_large)["lagged_i_parlament"],
    coef(h5_continuous_small)["lagged_i_parlament"]
  ),
  Continuous_SE = c(
    summary(h1_continuous)$coefficients["lagged_i_parlament", "Std. Error"],
    summary(h2_no_rrp_continuous)$coefficients["lagged_i_parlament", "Std. Error"],
    summary(h2_with_rrp_continuous)$coefficients["lagged_i_parlament", "Std. Error"],
    summary(h4_continuous_left)$coefficients["lagged_i_parlament", "Std. Error"],
    summary(h4_continuous_right)$coefficients["lagged_i_parlament", "Std. Error"],
    summary(h5_continuous_large)$coefficients["lagged_i_parlament", "Std. Error"],
    summary(h5_continuous_small)$coefficients["lagged_i_parlament", "Std. Error"]
  ),
  Continuous_P = c(
    summary(h1_continuous)$coefficients["lagged_i_parlament", "Pr(>|t|)"],
    summary(h2_no_rrp_continuous)$coefficients["lagged_i_parlament", "Pr(>|t|)"],
    summary(h2_with_rrp_continuous)$coefficients["lagged_i_parlament", "Pr(>|t|)"],
    summary(h4_continuous_left)$coefficients["lagged_i_parlament", "Pr(>|t|)"],
    summary(h4_continuous_right)$coefficients["lagged_i_parlament", "Pr(>|t|)"],
    summary(h5_continuous_large)$coefficients["lagged_i_parlament", "Pr(>|t|)"],
    summary(h5_continuous_small)$coefficients["lagged_i_parlament", "Pr(>|t|)"]
  )
)

# Tilføj signifikansstjerner
add_stars <- function(p_values) {
  stars <- rep("", length(p_values))
  stars[p_values < 0.1] <- "."
  stars[p_values < 0.05] <- "*"
  stars[p_values < 0.01] <- "**"
  stars[p_values < 0.001] <- "***"
  return(stars)
}

zero_nonzero_comparison$Binary_Stars <- add_stars(zero_nonzero_comparison$Binary_P)
zero_nonzero_comparison$Continuous_Stars <- add_stars(zero_nonzero_comparison$Continuous_P)

# Formater tal
zero_nonzero_comparison$Binary_Estimate <- sprintf("%.3f%s", 
                                                 zero_nonzero_comparison$Binary_Estimate,
                                                 zero_nonzero_comparison$Binary_Stars)
zero_nonzero_comparison$Continuous_Estimate <- sprintf("%.3f%s", 
                                                     zero_nonzero_comparison$Continuous_Estimate,
                                                     zero_nonzero_comparison$Continuous_Stars)

# Vis tabel
if (requireNamespace("knitr", quietly = TRUE)) {
  print(knitr::kable(zero_nonzero_comparison[, c("Model", "Binary_Estimate", "Continuous_Estimate")], 
                    col.names = c("Model", "Effekt på sandsynlighed for miljøposition", 
                                 "Effekt på intensitet af miljøposition"),
                    caption = "To-delt model: Effekter opdelt på sandsynlighed vs. intensitet"))
}

# Gem som fil
write.csv(zero_nonzero_comparison, "zero_nonzero_comparison.csv", row.names = FALSE)

# Afsluttende besked
cat("Alle plots og tabeller er nu genereret og gemt.\n")
cat("Denne analyse inkluderer nye robuste metoder, to-delt model, og kvantil regression.\n")
```




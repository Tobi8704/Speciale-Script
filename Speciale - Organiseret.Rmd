---
title: "Green Party Parliamentary Representation and Climate Policy"
author: "Tobias"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# 1. Setup and Data Preparation

## 1.1 Package Installation and Loading

```{r package_installation}
# Install pacman if not already installed
if (!require("pacman")) install.packages("pacman")

# Use pacman to load all required packages
pacman::p_load(
  # Data manipulation
  dplyr, tidyr, magrittr, purrr, data.table, readr, lubridate, quantreg, MASS,
  
  # Visualization
  ggplot2,
  
  # Statistical analysis
  rdd, rddtools, rddensity, rdrobust, rdlocrand, AER, ivreg,
  lmtest, sandwich, stargazer, broom, memisc, strucchange, plm,
  
  # Specific data sources
  manifestoR
)

# Load custom RDD functions if available
if (file.exists("gp_rdd_funktioner.R")) {
  source("gp_rdd_funktioner.R")
}
```

## 1.2 Helper Functions

```{r helper_functions}
# Function to filter European countries
filter_european_countries <- function(data, country_col = "country_name") {
  european_countries <- c(
    "Austria", "Bulgaria", "Croatia", "Czech Republic", "Denmark", 
    "Estonia", "Finland", "Germany", "Greece", "Ireland", "Italy", 
    "Latvia", "Luxembourg", "Netherlands", "Norway", "Poland", 
    "Portugal", "Romania", "Slovakia", "Slovenia", "Spain", 
    "Sweden", "Switzerland"
  )
  
  filter(data, !!sym(country_col) %in% european_countries)
}

# Funktion til at udføre robusthedstest med forskellige båndbredder
run_rdd_robustness <- function(data, 
                              outcome_var = "miljø_afhængig",
                              running_var = "centered_lagged_pervote_samlet", 
                              bw_list = c(1, 1.5, 2, 2.5, 3),
                              polynomials = c(1, 2, 3, 4),
                              cutpoint = 0,
                              covariates = NULL,
                              group_label = "") {
  
  # Tom liste til resultater
  all_results <- list()
  
  # Håndtering af kovariater
  if (!is.null(covariates)) {
    # Opret kovariat-matrix på forhånd
    covs_matrix <- NULL
    if (length(covariates) > 0) {
      # Forsøg at bygge kovariat-matrix manuelt
      covs_list <- list()
      for (i in 1:length(covariates)) {
        col_name <- covariates[i]
        if (col_name %in% names(data)) {
          covs_list[[i]] <- data[[col_name]]
        } else {
          warning(paste("Kolonne", col_name, "findes ikke i datasættet."))
          covs_list[[i]] <- NULL
        }
      }
      # Fjern NULL værdier
      covs_list <- covs_list[!sapply(covs_list, is.null)]
      
      # Hvis der er nogen kovariater tilbage, lav en matrix
      if (length(covs_list) > 0) {
        covs_matrix <- do.call(cbind, covs_list)
      }
    }
  } else {
    covs_matrix <- NULL
  }
  
  # Loop over polynomier
  for (p in polynomials) {
    
    # HVIS p <= 2, laver vi 'ikke-parametrisk' med faste båndbredder
    if (p <= 2) {
      
      # Loop over båndbredder
      for (bw in bw_list) {
        # Prøv at køre rdrobust med fejlhåndtering
        tryCatch({
          # Kør rdrobust uden kovariater
          if (is.null(covs_matrix)) {
            rd <- rdrobust(
              y = data[[outcome_var]],
              x = data[[running_var]],
              c = cutpoint,
              p = p,
              h = bw
            )
          } else {
            # Kør rdrobust med kovariater
            rd <- rdrobust(
              y = data[[outcome_var]],
              x = data[[running_var]],
              c = cutpoint,
              p = p,
              h = bw,
              covs = covs_matrix
            )
          }
          
          # Gem KUN conventional-estimatet: [1]
          tmp <- data.frame(
            Bandwidth    = bw,
            Polynomial   = p,
            LATE         = formatC(rd$Estimate[1], format = "f", digits = 4),
            StdErr       = formatC(rd$se[1], format = "f", digits = 4),
            p_value      = formatC(rd$pv[1], format = "f", digits = 4),
            N_left_of_c  = rd$N_h[1],
            N_right_of_c = rd$N_h[2]
          )
          
          # Tilføj en kolonne med p-værdi-stjerner
          tmp$p_value_star <- paste0(
            tmp$p_value,
            ifelse(as.numeric(tmp$p_value) < 0.01, "***",
                   ifelse(as.numeric(tmp$p_value) < 0.05, "**",
                          ifelse(as.numeric(tmp$p_value) < 0.1, "*", "")))
          )
          
          # Læg i listen over resultater
          all_results[[paste0("p", p, "_bw", bw)]] <- tmp
          
        }, error = function(e) {
          warning(paste("Fejl ved kørsel af rdrobust med p =", p, "og bw =", bw, ":", e$message))
        })
      }
      
    } else {
      # HVIS p > 2, laver vi "global" og sætter h = NULL (eller en meget stor værdi)
      tryCatch({
        # Kør rdrobust uden kovariater
        if (is.null(covs_matrix)) {
          rd <- rdrobust(
            y = data[[outcome_var]],
            x = data[[running_var]],
            c = cutpoint,
            p = p,
            h = NULL   # lader rdrobust selv vælge båndbredde
          )
        } else {
          # Kør rdrobust med kovariater
          rd <- rdrobust(
            y = data[[outcome_var]],
            x = data[[running_var]],
            c = cutpoint,
            p = p,
            h = NULL,   # lader rdrobust selv vælge båndbredde
            covs = covs_matrix
          )
        }
        
        # Gem KUN conventional-estimatet: [1]
        tmp <- data.frame(
          Bandwidth    = NA,  # "Global" => ingen fastsat h
          Polynomial   = p,
          LATE         = formatC(rd$Estimate[1], format = "f", digits = 4),
          StdErr       = formatC(rd$se[1], format = "f", digits = 4),
          p_value      = formatC(rd$pv[1], format = "f", digits = 4),
          N_left_of_c  = rd$N_h[1],
          N_right_of_c = rd$N_h[2]
        )
        
        # Tilføj en kolonne med p-værdi-stjerner
        tmp$p_value_star <- paste0(
          tmp$p_value,
          ifelse(as.numeric(tmp$p_value) < 0.01, "***",
                 ifelse(as.numeric(tmp$p_value) < 0.05, "**",
                        ifelse(as.numeric(tmp$p_value) < 0.1, "*", "")))
        )
        
        # Læg i listen
        all_results[[paste0("p", p, "_global")]] <- tmp
        
      }, error = function(e) {
        warning(paste("Fejl ved kørsel af rdrobust med p =", p, "og global båndbredde:", e$message))
      })
    }
  }
  
  # Bind alle resultaterne sammen, men tjek at vi har nogle resultater
  if (length(all_results) > 0) {
    results_df <- do.call(rbind, all_results)
    
    # Tilføj en kolonne med gruppelabel, hvis angivet
    if (group_label != "") {
      results_df$Group <- group_label
    }
    
    return(results_df)
  } else {
    warning("Ingen resultater produceret. Tjek data og parametre.")
    return(NULL)
  }
}



# Function to calculate Lowe's RILE score
calculate_rile_lowe <- function(data) {
  right_cols <- c("per104", "per201", "per203", "per305", "per401", "per402", "per407", 
                 "per414", "per505", "per601", "per603", "per605", "per606")
  left_cols <- c("per103", "per105", "per106", "per107", "per202", "per403", "per404", 
                "per406", "per412", "per413", "per504", "per506", "per701")
  
  # Debug: Identify missing columns
  missing_right <- right_cols[!right_cols %in% names(data)]
  missing_left <- left_cols[!left_cols %in% names(data)]
  print(paste("Missing right columns:", paste(missing_right, collapse=", ")))
  print(paste("Missing left columns:", paste(missing_left, collapse=", ")))
  
  # Filter to only include columns that exist in the dataset
  right_cols_exist <- right_cols[right_cols %in% names(data)]
  left_cols_exist <- left_cols[left_cols %in% names(data)]
  
  # Calculate RILE score
  data %>%
    mutate(rile_lowe = log((rowSums(dplyr::select(., dplyr::all_of(right_cols_exist)) + 0.5)) / 
                          (rowSums(dplyr::select(., dplyr::all_of(left_cols_exist)) + 0.5))))
}

# Function to calculate environmental position
calculate_env_position <- function(data) {
  data %>%
    mutate(
      miljø_afhængig = log((per416 + per501 + 0.5) / (per410 + 0.5))
    )
}

# Function to remove duplicates based on specific columns
remove_duplicates <- function(data, group_cols, value_col) {
  data %>%
    dplyr::group_by(dplyr::across(dplyr::all_of(group_cols))) %>%
    dplyr::mutate(max_value = max({{value_col}}, na.rm = TRUE)) %>%
    dplyr::filter({{value_col}} == max_value) %>%
    dplyr::distinct(dplyr::across(dplyr::all_of(group_cols)), .keep_all = TRUE) %>%
    dplyr::ungroup() %>%
    dplyr::select(-"max_value")  # Change to this or the alternate option below
}

# Function to create standard RDD plot
plot_rdd <- function(data, x_var, y_var, group_var, 
                    x_limit = 10, 
                    x_label = "Running Variable", 
                    y_label = "Outcome", 
                    title = "RDD Plot") {
  # Ensure x_var, y_var, and group_var are treated as strings (column names)
  ggplot(data = subset(data, data[[x_var]] <= x_limit)) +
    geom_point(aes(x = .data[[x_var]], y = .data[[y_var]], shape = .data[[group_var]]), size = 2) +
    geom_smooth(data = subset(data, data[[x_var]] < 0),
                aes(x = .data[[x_var]], y = .data[[y_var]]),
                method = 'lm', formula = y ~ poly(x, 3, raw = TRUE), 
                linetype = 1, color = 'black', size = 1) +
    geom_smooth(data = subset(data, data[[x_var]] >= 0),
                aes(x = .data[[x_var]], y = .data[[y_var]]),
                method = 'lm', formula = y ~ poly(x, 3, raw = TRUE), 
                linetype = 1, color = 'black', size = 1) +
    scale_shape_manual(values = c(1, 16)) +  # 1 = tom cirkel, 16 = fyldt cirkel
    geom_vline(xintercept = 0, linetype = 2, size = .6) +
    xlim(-5, x_limit) +  # Sætter x-aksens grænser
    theme_minimal() +
    labs(title = title, x = x_label, y = y_label) +
    theme(legend.position = 'bottom', legend.title = element_blank())
}

# Run RDD analysis with multiple specifications
run_rdrobust_analysis <- function(data, p, bw = NULL, interaction_var = NULL) {
  # Base covariates
  base_covs <- cbind(
    as.numeric(factor(data$country)),
    as.numeric(factor(data$edate))
  )
  
  # Add interaction term if provided
  if(!is.null(interaction_var)) {
    covs <- cbind(
      base_covs,
      data[[interaction_var]],
      data[[interaction_var]] * data$lagged_i_parlament
    )
  } else {
    covs <- base_covs
  }
  
  # Run RD analysis
  rd <- rdrobust(
    y = data$miljø_afhængig,
    x = data$centered_lagged_pervote_samlet,
    c = 0,
    p = p,
    h = bw,
    covs = covs
  )
  
  return(rd)
}

# Function for zoomed-in RDD plots
jump_plot_cutoff <- function(data, force_var, y_var, group_var, polynomial=1, window=2) {
  # Select data within window
  plot_data <- subset(data, abs(data[[force_var]]) <= window)
  
  # Create plot
  p <- ggplot() +
    geom_point(data = plot_data,
              aes_string(x = force_var, y = y_var, shape = group_var),
              size = 2) +
    geom_smooth(data = subset(plot_data, plot_data[[force_var]] < 0),
                aes_string(x = force_var, y = y_var),
                method = 'lm',
                formula = y ~ poly(x, polynomial, raw = TRUE),
                linetype = 1,
                color = 'black',
                size = 1) +
    geom_smooth(data = subset(plot_data, plot_data[[force_var]] >= 0),
                aes_string(x = force_var, y = y_var),
                method = 'lm',
                formula = y ~ poly(x, polynomial, raw = TRUE),
                linetype = 1,
                color = 'black',
                size = 1) +
    scale_x_continuous(name = 'Green Party Vote Share (centered)',
                     limits = c(-window, window),
                     breaks = seq(-window, window, window/2)) +
    geom_vline(xintercept = 0, linetype = 2, size = 0.6) +
    theme_minimal() +
    theme(legend.position = 'bottom', legend.title = element_blank()) +
    labs(title = paste0("RDD Plot (Window = ±", window, ")"),
         y = "Climate Position")
  
  return(p)
}
```

## 1.3 Data Acquisition

```{r data_acquisition, warning=FALSE}
# Load Manifesto Project Dataset
mp_setapikey(key = "c1f14c8fb84af448bfdb511afd7f415e")
mpds <- mp_maindataset(version = "MPDS2024a")

# Load election and party data
view_election <- read_csv("view_election.csv")
view_party <- read_csv("view_party.csv")

# GDP Per Capita
gdp_per_capita <- read_delim("gdp_per_capita.csv", 
     delim = ";", escape_double = FALSE, col_types = cols(GDP_per_capita = col_number()), 
     locale = locale(decimal_mark = ",", grouping_mark = "."), 
     trim_ws = TRUE)
#View(gdp_per_capita)

gdp_per_capita_growth <- read_delim("gdp_per_capita_growth.csv", 
    delim = ";", escape_double = FALSE, col_types = cols(`GDP per capita growth` = col_number()), 
    locale = locale(decimal_mark = ",", grouping_mark = "."), 
    trim_ws = TRUE)

inflation_consumer_prices <- read_delim("inflation-consumer_prices.csv", 
    delim = ";", escape_double = FALSE, col_types = cols(`Inflation-consumer prices` = col_number()), 
    locale = locale(decimal_mark = ",", grouping_mark = "."), 
    trim_ws = TRUE)

unemployment <- read_delim("unemployment.csv", 
    delim = ";", escape_double = FALSE, col_types = cols(Unemployment = col_number()), 
    locale = locale(decimal_mark = ",", grouping_mark = "."), 
    trim_ws = TRUE)

# Filter for European countries
election_european <- filter_european_countries(view_election)
party_european <- filter_european_countries(view_party)
mpds_european <- filter_european_countries(mpds, "countryname")

# Subsetting to post-1960 data
mpds_european_1960 <- filter(mpds_european, date > 196000)
pg_election_all <- filter(election_european, election_date > "1960-01-01")
pg_parties_all <- party_european  # No date filtering needed
```

## 1.4 Data Integration and Preprocessing

```{r data_processing}
# Merge party and election data
pg_election_parties_europa <- merge(
  pg_election_all, 
  pg_parties_all[, c("party_id", "cmp", "family_id", "family_name", "family_name_short")], 
  by = "party_id", 
  all.x = FALSE, 
  all.y = FALSE
)

# Filter to ecology/green parties (family_id = 19) in parliamentary elections
pg_election_parties_europa_eco <- filter(
  pg_election_parties_europa, 
  family_id == 19 & election_type == "parliament"
)

# Filter to ecological parties in Manifesto data
mpds_european_1960_eco <- filter(mpds_european_1960, parfam == "10")

# Create a correction lookup table for Green parties
party_corrections <- tribble(
  ~party_id, ~country_name, ~cmp,
  308,  "Switzerland",    43120,
  1781, "Portugal",       35120,
  2254, "Norway",         12110,
  2651, "Austria",        42120,
  196,  "Czech Republic", 82110,
  219,  "Estonia",        83110
)

# Apply corrections to green party data
pg_election_parties_europa_eco <- pg_election_parties_europa_eco %>%
  rows_update(party_corrections, by = c("party_id", "country_name"))

# Merge manifesto data with party-election data for green parties
mpds_pg_1960_eco <- merge(
  mpds_european_1960_eco,
  pg_election_parties_europa_eco,
  by.x = c("countryname", "edate", "party"),
  by.y = c("country_name", "election_date", "cmp"),
  all = TRUE
)
```

## 1.5 Electoral Thresholds and Party Size

```{r thresholds_and_party_size}
# Import electoral threshold data
samlede_thresholds <- read_delim("Samlede Thresholds.csv", 
    delim = ";", 
    escape_double = FALSE, 
    locale = locale(decimal_mark = ",", grouping_mark = "."), 
    trim_ws = TRUE) %>%
  mutate(edate = dmy(edate))  # Convert to date format
#View(samlede_thresholds)
print(names(samlede_thresholds))

# Select relevant threshold columns
samlede_thresholds_sub <- samlede_thresholds %>%
  dplyr::select(country, edate, threshold, threshold_lagged)

# Merge thresholds with main manifesto dataset
mpds_european_1960 <- merge(
  mpds_european_1960,
  samlede_thresholds_sub,
  by = c("country", "edate"),
  all.x = FALSE
)

# Calculate average vote share and filter to mainstream parties (>=10% avg)
mpds_european_1960 <- mpds_european_1960 %>% 
  group_by(party) %>% 
  mutate(avg_pervote_main = mean(pervote, na.rm = TRUE)) %>% 
  ungroup() %>%
  filter(avg_pervote_main >= 10)
```

## 1.6 Green Party Parliament Presence and Vote Share

```{r green_party_data}
# Import green party vote share and parliament data
green_party_data <- read_delim(
  "mpds_pg_1960_eco_færdig_tilføjelse_af_ekstra_votes.csv", 
  delim = ";", 
  escape_double = FALSE, 
  col_types = cols(avg_vote_share = col_double()), 
  locale = locale(decimal_mark = ",", grouping_mark = "."), 
  trim_ws = TRUE
) %>%
  mutate(
    edate = as.Date(edate, format = "%d-%m-%Y"),
    edate = format(edate, "%Y/%m/%d")
  )


# Select relevant green party columns
green_party_data_sub <- green_party_data[
  , c("countryname", "edate", "pervote_samlet", "lagged_pervote_samlet", "i_parlament", "lagged_i_parlament")
]

# Merge with mainstream party data
full_dataset <- merge(
  mpds_european_1960,
  green_party_data_sub,
  by = c("countryname", "edate"),
  all.x = FALSE
)


#View(full_dataset)

# Calculate Lowe's RILE score
full_dataset <- calculate_rile_lowe(full_dataset)

# Select final columns and remove duplicates
final_dataset <- full_dataset %>%
  dplyr::select(
    countryname, edate, country, party, oecdmember, eumember, date, 
    partyname, partyabbrev, parfam, absseat, per410, per416, per501, 
    threshold, threshold_lagged, pervote_samlet, lagged_pervote_samlet, 
    i_parlament, lagged_i_parlament, avg_pervote_main, rile, rile_lowe
  ) %>%
  remove_duplicates(
    c("countryname", "edate", "party"),
    pervote_samlet
  )
```

## 1.7 Final Variable Creation og Radical Right Parti Presence

```{r create_final_variables}
# Create all derived variables needed for analysis
final_dataset <- final_dataset %>%
  mutate(
    # Convert to numeric
    pervote_samlet = as.numeric(pervote_samlet),
    lagged_pervote_samlet = as.numeric(lagged_pervote_samlet),
    
    # Create centered variables (running variables for RDD)
    centered_pervote_samlet = pervote_samlet - threshold,
    centered_lagged_pervote_samlet = lagged_pervote_samlet - threshold_lagged,
    
    # Create dependent variable: environmental position
    miljø_afhængig = log((per416 + per501 + 0.5) / (per410 + 0.5)),
    
    miljø_afhængig_alt = log(per416 + per501 + 0.5) - log(per410 + 0.5),
    
    # Create factor variables for parliament presence
    factor_lagged_i_parlament = factor(
      lagged_i_parlament, 
      levels = c(0, 1), 
      labels = c("Green parties w/o seats", "Green parties w seat(s)")
    ),
    factor_i_parlament = factor(
      i_parlament, 
      levels = c(0, 1), 
      labels = c("Green parties w/o seats", "Green parties w seat(s)")
    ),
    
    # Create variables for party size (for H5)
    large_party = ifelse(avg_pervote_main > median(avg_pervote_main, na.rm = TRUE), 1, 0),
    
    # Create variables for left-right orientation (for H4)
    left_party = ifelse(rile_lowe < 0, 1, 0)
  )

# Sortér data efter parti og dato
final_dataset <- final_dataset %>% dplyr::arrange(party, edate)

# Beregn first difference inden for hvert parti
final_dataset <- final_dataset %>% 
  dplyr::group_by(party) %>% 
  dplyr::mutate(miljø_afhængig_fd = miljø_afhængig - dplyr::lag(miljø_afhængig)) %>% 
  dplyr::ungroup()

# Identificer første forekomst af højreradikale partier (parfam == 70)
rrp_parties <- MPDataset_MPDS2024a %>%
  filter(parfam == 70) %>%
  dplyr::select(country, date, absseat) %>%
  group_by(country) %>%
  # Vælg den første forekomst for hvert land
  slice(1) %>%
  ungroup()

# Funktion til at tilføje rrp_i_p variablen
add_rrp_variable <- function(row) {
  # Sikre at country matcher
  match <- rrp_parties %>%
    filter(
      country == row[["country"]],
      date <= row[["date"]]
    )
  
  # Returner 1 hvis der er et match, ellers 0
  return(ifelse(nrow(match) > 0, 1, 0))
}

# Tilføj rrp_i_p variablen til final_dataset
final_dataset <- final_dataset %>%
  rowwise() %>%
  mutate(rrp_i_p = add_rrp_variable(pick(country, date))) %>%
  ungroup()

# Print information om den nye variabel
print(paste("Antal rækker med rrp_i_p = 1:", sum(full_dataset$rrp_i_p == 1)))
print(paste("Antal rækker med rrp_i_p = 0:", sum(full_dataset$rrp_i_p == 0)))

# Se nærmere på fordelingen
print("Fordeling af rrp_i_p:")
print(table(full_dataset$rrp_i_p))

ggplot(final_dataset, aes(x = factor(rrp_i_p))) +
  geom_bar(fill = c("skyblue", "salmon")) +
  labs(
    title = "Fordeling af Højreradikale Partier",
    x = "RRP i Parlament (0 = Nej, 1 = Ja)",
    y = "Antal Observationer"
  ) +
  theme_minimal()

#Lagged rrp_i_p
final_dataset <- final_dataset %>%
  dplyr::arrange(party, edate) %>%
  dplyr::group_by(party) %>%
  dplyr::mutate(rrp_i_p_lag1 = dplyr::lag(rrp_i_p, n = 1, order_by = edate))

#GDP Per Capita
# Forbered datasættene ved at ekstrahere årstallet fra edate
final_dataset <- dplyr::mutate(final_dataset, 
                                Year = as.numeric(substr(edate, 1, 4)))

# Match datasættene ved hjælp af left_join
# Dette kopierer GDP_per_capita over i final_dataset
final_dataset <- dplyr::left_join(final_dataset, 
                                   gdp_per_capita, 
                                   by = c("countryname" = "countryname", 
                                          "Year" = "Year"))

# Lagged gdp_per_capita
#final_dataset <- final_dataset %>%
 # dplyr::arrange(party, edate) %>%
#  dplyr::group_by(party) %>%
 # dplyr::mutate(GDP_per_capita_lag1 = dplyr::lag(GDP_per_capita, n = 1, order_by = edate))

#GDP Per Capita Growth
# Match datasættene ved hjælp af left_join
# Dette kopierer GDP_per_capita over i final_dataset
final_dataset <- dplyr::left_join(final_dataset, 
                                   gdp_per_capita_growth, 
                                   by = c("countryname" = "countryname", 
                                          "Year" = "Year"))


#Unemployment
# Dette kopierer GDP_per_capita over i final_dataset
final_dataset <- dplyr::left_join(final_dataset, 
                                   unemployment, 
                                   by = c("countryname" = "countryname", 
                                          "Year" = "Year"))


#Inflation
# Dette kopierer GDP_per_capita over i final_dataset
final_dataset <- dplyr::left_join(final_dataset, 
                                   inflation_consumer_prices, 
                                   by = c("countryname" = "countryname", 
                                          "Year" = "Year"))

# Create clean dataset for analysis (remove missing values)
clean_data <- na.omit(final_dataset)

#View(final_dataset)

```


# 2. Exploratory Data Analysis

```{r exploratory_plots}
# Initial RDD visualization
initial_rdd_plot <- ggplot(final_dataset, 
                          aes(x = centered_lagged_pervote_samlet, 
                              y = miljø_afhængig, 
                              color = factor_lagged_i_parlament)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "loess", se = FALSE) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red") +
  labs(title = "RDD Plot: Green Party Parliamentary Entry and Climate Focus",
       x = "Green Party Vote Share (centered at threshold)",
       y = "Climate Position") +
  theme_minimal()
print(initial_rdd_plot)

# Polynomial fit visualization
poly_rdd_plot <- plot_rdd(
  data = final_dataset,
  x_var = "centered_lagged_pervote_samlet",  # Bemærk anførselstegn
  y_var = "miljø_afhængig",  # Bemærk anførselstegn
  group_var = "factor_lagged_i_parlament",  # Bemærk anførselstegn
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position",
  title = "Climate Position Around Parliamentary Threshold"
)
print(poly_rdd_plot)

# Distribution of outcome variable
outcome_dist <- ggplot(final_dataset, aes(x = miljø_afhængig)) +
  geom_histogram(binwidth = 0.1, fill = "steelblue", color = "black") +
  labs(title = "Distribution of Climate Position Variable", 
       x = "Climate Position (miljø_afhængig)", 
       y = "Count") +
  theme_minimal()
print(outcome_dist)

# Distribution of running variable by parliamentary status
running_var_dist <- ggplot(final_dataset, 
                          aes(x = centered_lagged_pervote_samlet, 
                              fill = factor_lagged_i_parlament)) +
  geom_histogram(position = "dodge", bins = 30, alpha = 0.7) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red") +
  labs(title = "Distribution of Green Party Vote Shares",
       x = "Vote Share (centered around threshold)",
       y = "Count",
       fill = "Parliament Status") +
  theme_minimal()
print(running_var_dist)

# Basal KDE med R's indbyggede density() funktion
kde_result <- density(final_dataset$miljø_afhængig)

# Plot KDE kurven
plot(kde_result, main="KDE af Klima Position", xlab="Klima Position (miljø_afhængig)")

# Fyld området under kurven
polygon(c(kde_result$x, rev(kde_result$x)), 
        c(kde_result$y, rep(0, length(kde_result$y))),
        col=rgb(0.1, 0.4, 0.7, 0.5), border=NA)

# Plot med ggplot2
ggplot(data.frame(x = final_dataset$miljø_afhængig), aes(x = x)) +
  geom_histogram(aes(y = ..density..), bins = 30, fill = "lightblue", color = "blue", alpha = 0.7) +
  geom_density(color = "darkblue", size = 1) +
  labs(title = "Histogram med KDE af Klima Position",
       x = "Klima Position (miljø_afhængig)",
       y = "Tæthed") +
  theme_minimal()

# Standardbåndbredde
kde_standard <- density(final_dataset$miljø_afhængig)

# Mindre båndbredde (mindre udglatning)
kde_small <- density(final_dataset$miljø_afhængig, bw = kde_standard$bw * 0.5)

# Større båndbredde (mere udglatning)
kde_large <- density(final_dataset$miljø_afhængig, bw = kde_standard$bw * 2)

# Plot alle tre kurver for sammenligning
plot(kde_standard, main="KDE med forskellige båndbredder", xlab="Klima Position", col="black")
lines(kde_small, col="blue")  # Mindre udglatning
lines(kde_large, col="red")   # Mere udglatning
legend("topright", legend=c("Standard", "Mindre udglatning", "Mere udglatning"), 
       col=c("black", "blue", "red"), lty=1)

# Antager en modificeret version af variablen (f.eks. uden nul-værdier)
miljø_modificeret <- final_dataset$miljø_afhængig[final_dataset$miljø_afhængig != 0]

# KDE for begge datasæt
kde_original <- density(final_dataset$miljø_afhængig)
kde_modificeret <- density(miljø_modificeret)

# Plot sammenligning
plot(kde_original, main="Sammenligning af fordelinger", xlab="Klima Position", col="blue", 
     ylim=c(0, max(c(kde_original$y, kde_modificeret$y))))
lines(kde_modificeret, col="red")
legend("topright", legend=c("Original", "Modificeret"), col=c("blue", "red"), lty=1)
```

#View(final_dataset %>% dplyr::select(countryname, country, edate, party, miljø_afhængig, miljø_afhængig_alt,  per416, per501, per410, lagged_i_parlament, centered_lagged_pervote_samlet))



# 2.1 Robusthedstest af Miljø Afhængig
```{r Robusthedstest af Miljø Afhængig}
# Tilføj KDE til robusthedsanalyse
library(ggplot2)

# 1. KDE for hele datasættet
kde_full <- density(clean_data$miljø_afhængig)
plot(kde_full, main="KDE for hele datasættet", 
     xlab="Miljø Afhængig Variable")

# 2. KDE opdelt efter side af tærsklen
kde_below_threshold <- density(clean_data$miljø_afhængig[clean_data$centered_lagged_pervote_samlet < 0])
kde_above_threshold <- density(clean_data$miljø_afhængig[clean_data$centered_lagged_pervote_samlet >= 0])

# Plot KDE for begge sider af tærsklen
plot(kde_below_threshold, col="blue", main="KDE opdelt efter tærskel", 
     xlab="Miljø Afhængig Variable")
lines(kde_above_threshold, col="red")
legend("topright", legend=c("Under tærskel", "Over tærskel"), 
        col=c("blue", "red"), lty=1)

# 3. Statistisk test for forskel i fordelinger
# Kernal density test (approximate)
library(stats)
ks_test <- ks.test(
  clean_data$miljø_afhængig[clean_data$centered_lagged_pervote_samlet < 0],
  clean_data$miljø_afhængig[clean_data$centered_lagged_pervote_samlet >= 0]
)
print(ks_test)

# 4. ggplot visualisering med facet
ggplot(clean_data, aes(x = miljø_afhængig)) +
  geom_density(aes(fill = centered_lagged_pervote_samlet >= 0), alpha = 0.5) +
  facet_wrap(~ (centered_lagged_pervote_samlet >= 0)) +
  labs(title = "KDE fordeling på begge sider af tærsklen",
       x = "Miljø Afhængig Variable",
       y = "Tæthed") +
  theme_minimal()

# 5. Tilføj bootstrap konfidensintervaller for KDE
library(boot)

# Funktion til at beregne KDE
kde_boot_function <- function(data, indices) {
  d <- density(data[indices])
  return(d$y)
}

# Bootstrap KDE
boot_result <- boot(clean_data$miljø_afhængig, 
                    statistic = kde_boot_function, 
                    R = 1000)

# Plot KDE med bootstrap konfidensintervaller
plot(kde_full, main="KDE med Bootstrap Konfidensintervaller")
lines(kde_full$x, apply(boot_result$t, 2, quantile, probs = 0.025), col = "red", lty = 2)
lines(kde_full$x, apply(boot_result$t, 2, quantile, probs = 0.975), col = "red", lty = 2)
```


# 3. Testing the Five Hypotheses

## 3.1 H1: When green parties enter parliament, climate focus in mainstream parties decreases

```{r h1_analysis}
# ============================================================================
# H1 Analysis: Effect of Green Party Entry on Climate Focus
# ============================================================================


# ============================================================================
# 1. Basic Linear Models with Regular and Clustered Standard Errors
# ============================================================================

# Simple linear model
h1_model_simple <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet + lagged_i_parlament,
                     data = final_dataset)
summary(h1_model_simple)

# Interaction model
h1_model_interaction <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                          data = final_dataset)
summary(h1_model_interaction)

# Clustered standard errors (by party)
if (exists("coeftest.cluster_grøn")) {
  data_used <- na.omit(final_dataset[, c("miljø_afhængig", "centered_lagged_pervote_samlet", 
                                      "lagged_i_parlament", "party", "edate", "country")])
  
  h1_robust <- coeftest.cluster_grøn(
    data = data_used,
    fm = h1_model_interaction,
    cluster1 = data_used$party  # Pass the vector directly
  )
  print(h1_robust)
  
  # Double-clustered standard errors (by party and election date)
  h1_robust_double <- summary.cluster_grøn(
    obj = h1_model_interaction, 
    data = data_used, 
    cluster1 = "party", 
    cluster2 = "edate"
  )
  print(h1_robust_double)
}

# ============================================================================
# 2. Two-Part Model for Zero-Inflated Distribution
# ============================================================================

# Part 1: Logit model for predicting non-zero climate focus
h1_binary <- glm(I(miljø_afhængig != 0) ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                family = binomial, data = final_dataset)
summary(h1_binary)

# Part 2: Linear model on non-zero values only
h1_continuous <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                   data = subset(final_dataset, miljø_afhængig != 0))
summary(h1_continuous)

# ============================================================================
# 3. Quantile Regression Analysis
# ============================================================================

# Median regression (tau = 0.5)
h1_median_rq <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                  tau = 0.5, data = final_dataset)
summary(h1_median_rq)

# Multiple quantiles to examine heterogeneous effects
h1_multi_quantile <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                       tau = c(0.25, 0.5, 0.75), data = final_dataset)
summary(h1_multi_quantile)

# Generate quantile plot to visualize coefficient variation across quantiles
h1_quantile_plot <- plot(summary(rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                                   tau = seq(0.1, 0.9, by = 0.1), data = final_dataset)))

# Save quantile plot
pdf("h1_quantile_coefficients.pdf", width = 10, height = 8)
print(h1_quantile_plot)
dev.off()

# ============================================================================
# 4. Robust Regression (less sensitive to outliers and non-normal distributions)
# ============================================================================

# MM-type robust regression
h1_robust_reg <- rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                    data = final_dataset, method = "MM")
summary(h1_robust_reg)

# ============================================================================
# 5. Enhanced RDD Analysis
# ============================================================================

# Multi-polynomial RDD with custom function
if (exists("rd.base_grøn")) {
  rd.multic_h1 <- rd.base_grøn(
    data = final_dataset,
    force.var = 'centered_lagged_pervote_samlet',
    yvar = 'miljø_afhængig',
    seat.identifier = 'factor_lagged_i_parlament',
    fixed.effects = 'country',
    clust1 = 'party',
    clust2 = 'edate',
    polynomials = c(1, 2, 3, 4),
    bws = NULL
  )
  print(rd.multic_h1)
}

# Robustness analysis with different bandwidths
covariates_to_use <- c("country", "edate")
results_df_h1 <- run_rdd_robustness(
  data = final_dataset,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = c(1, 1.5, 2, 2.5, 3),
  polynomials = c(1, 2, 3, 4),
  covariates = covariates_to_use,
  group_label = "H1 - Grøn parti effekt"
)
print(results_df_h1)

# Create a nice table with knitr
if (requireNamespace("knitr", quietly = TRUE)) {
  print(knitr::kable(results_df_h1, 
                    caption = "H1: Robusthedstest med forskellige båndbredder og polynomiegrader"))
}

# ============================================================================
# 6. Enhanced rdrobust Analysis (with various specifications)
# ============================================================================

# Standard RDD approach with optimal bandwidth
h1_rdd <- rdrobust(
  y = final_dataset$miljø_afhængig,
  x = final_dataset$centered_lagged_pervote_samlet,
  c = 0,
  p = 1,  # linear polynomial
  kernel = "triangular",
  bwselect = "mserd"  # MSE-optimal bandwidth
)
summary(h1_rdd)

# RDD with bias correction and robust standard errors
h1_rdd_robust <- rdrobust(
  y = final_dataset$miljø_afhængig,
  x = final_dataset$centered_lagged_pervote_samlet,
  c = 0,
  p = 1,  # linear polynomial
  kernel = "triangular",
  bwselect = "mserd"  # MSE-optimal bandwidth
  # Fjernet bias.correction og robust argumenter, da de ikke understøttes korrekt
)
summary(h1_rdd_robust)

# RDD with covariates for increased precision
h1_rdd_covs <- rdrobust(
  y = final_dataset$miljø_afhængig,
  x = final_dataset$centered_lagged_pervote_samlet,
  c = 0,
  covs = model.matrix(~ country + edate, data = final_dataset)[,-1],  # Covariates without intercept
  p = 1,
  kernel = "triangular",
  bwselect = "mserd"
)
summary(h1_rdd_covs)

# Alternative kernel function for robustness check
h1_rdd_uniform <- rdrobust(
  y = final_dataset$miljø_afhængig,
  x = final_dataset$centered_lagged_pervote_samlet,
  c = 0,
  p = 1,
  kernel = "uniform",  # Uniform kernel function
  bwselect = "mserd"
)
summary(h1_rdd_uniform)

# Focused analysis close to threshold
h1_rdd_local <- rdrobust(
  y = final_dataset$miljø_afhængig,
  x = final_dataset$centered_lagged_pervote_samlet,
  c = 0,
  h = 1,  # 1 percentage point around threshold
  p = 1
)
summary(h1_rdd_local)

# Alternative RDD specifications
h1_rdd_alt <- rdrobust(
  y = final_dataset$miljø_afhængig,
  x = final_dataset$centered_lagged_pervote_samlet,
  c = 0,
  p = 2,  # quadratic polynomial
  kernel = "triangular",
  h = 2  # fixed bandwidth
)
summary(h1_rdd_alt)

# ============================================================================
# 7. Instrumental Variables Estimation
# ============================================================================

# IV estimation (treating lagged_i_parlament as endogenous)
h1_iv <- ivreg(miljø_afhængig ~ lagged_i_parlament | centered_lagged_pervote_samlet, 
              data = final_dataset)
summary(h1_iv, diagnostics = TRUE)

# ============================================================================
# 8. Visual Confirmation and RDD Plots
# ============================================================================

# Standard RDD plot
h1_plot <- plot_rdd(
  data = final_dataset,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position",
  title = "H1: Effect of Green Party Entry on Mainstream Climate Focus"
)
print(h1_plot)

# Create an RDD plot specifically for zero vs non-zero values
# Alternativ tilgang uden color_by argument

# Først opdel data i to grupper
zero_data <- subset(final_dataset, miljø_afhængig == 0)
nonzero_data <- subset(final_dataset, miljø_afhængig != 0)

# Plot standard RDD for begge grupper separat
h1_plot_zeros <- plot_rdd(
  data = zero_data,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position (Zeros Only)",
  title = "H1: RDD Plot for Zero Climate Positions"
)

h1_plot_nonzeros <- plot_rdd(
  data = nonzero_data,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position (Non-Zeros Only)",
  title = "H1: RDD Plot for Non-Zero Climate Positions"
)

# Vis plottene
print(h1_plot_zeros)
print(h1_plot_nonzeros)

# ============================================================================
# 9. Summary Table of All Models 
# ============================================================================

# Create a table to compare coefficients across different model specifications
if (requireNamespace("texreg", quietly = TRUE)) {
  library(texreg)
  # Export HTML table comparing different models
  htmlreg(list(h1_model_interaction, h1_continuous, h1_median_rq, h1_robust_reg),
         file = "h1_model_comparison.html",
         custom.model.names = c("OLS (All)", "OLS (Non-Zero)", "Median Regression", "Robust Regression"),
         custom.coef.names = c("Intercept", "Vote Share", "Parliament", "Vote Share × Parliament"),
         caption = "Comparison of Different Modeling Approaches for H1")
}
```

## 3.2 H2: Radical right parties in parliament reduce climate focus in mainstream parties
```{r H2}
# ============================================================================
# 1. Basic Linear Models 
# ============================================================================

# Simple linear model med rrp_i_p_lag1
h2_model_simple <- lm(miljø_afhængig ~ rrp_i_p_lag1,
                     data = final_dataset)
summary(h2_model_simple)

# Kontrolleret model med flere variable
h2_model_kontrol <- lm(miljø_afhængig ~ rrp_i_p_lag1 + centered_lagged_pervote_samlet + lagged_i_parlament,
                       data = final_dataset)
summary(h2_model_kontrol)

# Interaction model
h2_model_interaction <- lm(miljø_afhængig ~ rrp_i_p_lag1 * centered_lagged_pervote_samlet * lagged_i_parlament, 
                          data = final_dataset)
summary(h2_model_interaction)

# Clustered standard errors (by party)
if (exists("coeftest.cluster_grøn")) {
  data_used <- na.omit(final_dataset[, c("miljø_afhængig", "rrp_i_p_lag1", "centered_lagged_pervote_samlet", 
                                      "lagged_i_parlament", "party", "edate", "country")])
  
  h2_robust <- coeftest.cluster_grøn(
    data = data_used,
    fm = h2_model_interaction,
    cluster1 = data_used$party  # Pass the vector directly
  )
  print(h2_robust)
  
  # Double-clustered standard errors (by party and election date)
  h2_robust_double <- summary.cluster_grøn(
    obj = h2_model_interaction, 
    data = data_used, 
    cluster1 = "party", 
    cluster2 = "edate"
  )
  print(h2_robust_double)
}

# ============================================================================
# 2. Two-Part Model for Zero-Inflated Distribution
# ============================================================================

# Opdel data baseret på RRP status
clean_data_no_rrp <- subset(final_dataset, rrp_i_p_lag1 == 0)
clean_data_with_rrp <- subset(final_dataset, rrp_i_p_lag1 == 1)

# Two-part model for no RRP in parliament
# Part 1: Logit model for predicting non-zero climate focus
h2_binary_no_rrp <- glm(I(miljø_afhængig != 0) ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                      family = binomial, data = clean_data_no_rrp)
summary(h2_binary_no_rrp)

# Part 2: Linear model on non-zero values only
h2_continuous_no_rrp <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                         data = subset(clean_data_no_rrp, miljø_afhængig != 0))
summary(h2_continuous_no_rrp)

# Two-part model for RRP in parliament
# Part 1: Logit model for predicting non-zero climate focus
h2_binary_with_rrp <- glm(I(miljø_afhængig != 0) ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                        family = binomial, data = clean_data_with_rrp)
summary(h2_binary_with_rrp)

# Part 2: Linear model on non-zero values only
h2_continuous_with_rrp <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                           data = subset(clean_data_with_rrp, miljø_afhængig != 0))
summary(h2_continuous_with_rrp)

# ============================================================================
# 3. Quantile Regression Analysis
# ============================================================================

# Quantile regression for each RRP group separately
# No RRP in parliament
h2_median_rq_no_rrp <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                        tau = 0.5, data = clean_data_no_rrp)
summary(h2_median_rq_no_rrp)

# Multiple quantiles to examine heterogeneous effects
h2_multi_quantile_no_rrp <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                             tau = c(0.25, 0.5, 0.75), data = clean_data_no_rrp)
summary(h2_multi_quantile_no_rrp)

# Generate quantile plot for no RRP
h2_quantile_plot_no_rrp <- plot(summary(rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                                        tau = seq(0.1, 0.9, by = 0.1), data = clean_data_no_rrp)))

# With RRP in parliament
h2_median_rq_with_rrp <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                          tau = 0.5, data = clean_data_with_rrp)
summary(h2_median_rq_with_rrp)

# Multiple quantiles to examine heterogeneous effects
h2_multi_quantile_with_rrp <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                               tau = c(0.25, 0.5, 0.75), data = clean_data_with_rrp)
summary(h2_multi_quantile_with_rrp)

# Generate quantile plot for with RRP
h2_quantile_plot_with_rrp <- plot(summary(rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                                          tau = seq(0.1, 0.9, by = 0.1), data = clean_data_with_rrp)))

# Save quantile plots
pdf("h2_quantile_coefficients_no_rrp.pdf", width = 10, height = 8)
print(h2_quantile_plot_no_rrp)
dev.off()

pdf("h2_quantile_coefficients_with_rrp.pdf", width = 10, height = 8)
print(h2_quantile_plot_with_rrp)
dev.off()

# ============================================================================
# 4. Robust Regression Analysis
# ============================================================================

# Robust regression for full sample
h2_robust_reg <- rlm(miljø_afhængig ~ rrp_i_p_lag1 * centered_lagged_pervote_samlet * lagged_i_parlament, 
                   data = final_dataset, method = "MM")
summary(h2_robust_reg)

# Robust regression for each RRP group separately
h2_robust_reg_no_rrp <- rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                          data = clean_data_no_rrp, method = "MM")
summary(h2_robust_reg_no_rrp)

h2_robust_reg_with_rrp <- rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                            data = clean_data_with_rrp, method = "MM")
summary(h2_robust_reg_with_rrp)

# ============================================================================
# 5. RDD Analysis with Fixed Effects
# ============================================================================

# Multi-polynomial RDD med rrp_i_p_lag1 som moderator
if (exists("rd.base_grøn")) {
  rd.multic_h2 <- rd.base_grøn(
    data = final_dataset,
    force.var = 'centered_lagged_pervote_samlet',
    yvar = 'miljø_afhængig',
    seat.identifier = 'factor_lagged_i_parlament',
    fixed.effects = c('country', 'rrp_i_p_lag1'),  # Tilføjet rrp_i_p_lag1 som fixed effect
    clust1 = 'party',
    clust2 = 'edate',
    polynomials = c(1, 2, 3, 4),
    bws = NULL
  )
  print(rd.multic_h2)
}

# ============================================================================
# 6. Standard RDD approach opdelt efter rrp_i_p_lag1
# ============================================================================

# Definer kovariater, der skal kontrolleres for
covariates_to_use <- c("country", "edate", "lagged_i_parlament")

# Kør robusthedsanalysen for data uden RRP i parlament
results_df_no_rrp <- run_rdd_robustness(
  data = clean_data_no_rrp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = c(1, 1.5, 2, 2.5, 3),
  polynomials = c(1, 2, 3, 4),
  covariates = covariates_to_use,
  group_label = "Ingen RRP i parlament (lag1)"
)

# Kør robusthedsanalysen for data med RRP i parlament
results_df_with_rrp <- run_rdd_robustness(
  data = clean_data_with_rrp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = c(1, 1.5, 2, 2.5, 3),
  polynomials = c(1, 2, 3, 4),
  covariates = covariates_to_use,
  group_label = "RRP i parlament (lag1)"
)

# Kombinér resultaterne for at sammenligne direkte
combined_results <- rbind(results_df_no_rrp, results_df_with_rrp)
print(combined_results)

# Vis resultaterne i en pæn tabel
if (requireNamespace("knitr", quietly = TRUE)) {
  print(knitr::kable(combined_results, 
                     caption = "H2: Robusthedstest med forskellige båndbredder opdelt efter RRP-status (lag1)"))
}

# ============================================================================
# 7. Enhanced rdrobust Analysis Separate by RRP Status
# ============================================================================

# Standard rdrobust for no RRP
h2_rdd_no_rrp <- rdrobust(
  y = clean_data_no_rrp$miljø_afhængig,
  x = clean_data_no_rrp$centered_lagged_pervote_samlet,
  c = 0,
  p = 1, # linear polynomial
  kernel = "triangular",
  bwselect = "mserd" # MSE-optimal bandwidth
)
summary(h2_rdd_no_rrp)

# RDD with covariates for no RRP
h2_rdd_covs_no_rrp <- rdrobust(
  y = clean_data_no_rrp$miljø_afhængig,
  x = clean_data_no_rrp$centered_lagged_pervote_samlet,
  c = 0,
  covs = model.matrix(~ country + edate, data = clean_data_no_rrp)[,-1],
  p = 1,
  kernel = "triangular",
  bwselect = "mserd"
)
summary(h2_rdd_covs_no_rrp)

# Focused analysis close to threshold for no RRP
h2_rdd_local_no_rrp <- rdrobust(
  y = clean_data_no_rrp$miljø_afhængig,
  x = clean_data_no_rrp$centered_lagged_pervote_samlet,
  c = 0,
  h = 1.5,  # 1 percentage point around threshold
  p = 1
)
summary(h2_rdd_local_no_rrp)

# Standard rdrobust for with RRP
h2_rdd_with_rrp <- rdrobust(
  y = clean_data_with_rrp$miljø_afhængig,
  x = clean_data_with_rrp$centered_lagged_pervote_samlet,
  c = 0,
  p = 1, # linear polynomial
  kernel = "triangular",
  bwselect = "mserd" # MSE-optimal bandwidth
)
summary(h2_rdd_with_rrp)

# RDD with covariates for with RRP
h2_rdd_covs_with_rrp <- rdrobust(
  y = clean_data_with_rrp$miljø_afhængig,
  x = clean_data_with_rrp$centered_lagged_pervote_samlet,
  c = 0,
  covs = model.matrix(~ country + edate, data = clean_data_with_rrp)[,-1],
  p = 1,
  kernel = "triangular",
  bwselect = "mserd"
)
summary(h2_rdd_covs_with_rrp)

# Focused analysis close to threshold for with RRP
h2_rdd_local_with_rrp <- rdrobust(
  y = clean_data_with_rrp$miljø_afhængig,
  x = clean_data_with_rrp$centered_lagged_pervote_samlet,
  c = 0,
  h = 1,  # 1 percentage point around threshold
  p = 1
)
summary(h2_rdd_local_with_rrp)

# ============================================================================
# 8. Separate Analysis for Zero and Non-Zero Values by RRP Status
# ============================================================================

# No RRP - Filter zero and non-zero values
zero_data_no_rrp <- subset(clean_data_no_rrp, miljø_afhængig == 0)
nonzero_data_no_rrp <- subset(clean_data_no_rrp, miljø_afhængig != 0)

# With RRP - Filter zero and non-zero values 
zero_data_with_rrp <- subset(clean_data_with_rrp, miljø_afhængig == 0)
nonzero_data_with_rrp <- subset(clean_data_with_rrp, miljø_afhængig != 0)

# RDD for non-zero values only (No RRP)
h2_rdd_nonzero_no_rrp <- rdrobust(
  y = nonzero_data_no_rrp$miljø_afhængig,
  x = nonzero_data_no_rrp$centered_lagged_pervote_samlet,
  c = 0,
  p = 1,
  kernel = "triangular",
  bwselect = "mserd"
)
summary(h2_rdd_nonzero_no_rrp)

# RDD for non-zero values only (With RRP)
h2_rdd_nonzero_with_rrp <- rdrobust(
  y = nonzero_data_with_rrp$miljø_afhængig,
  x = nonzero_data_with_rrp$centered_lagged_pervote_samlet,
  c = 0,
  p = 1,
  kernel = "triangular",
  bwselect = "mserd"
)
summary(h2_rdd_nonzero_with_rrp)

# ============================================================================
# 9. Visual Confirmation and Plots
# ============================================================================

# Plot 1: Standard RDD for No RRP
h2_plot_no_rrp <- plot_rdd(
  data = clean_data_no_rrp,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position",
  title = "H2a: Klimafokus uden højreradikale partier i parlamentet (lag1)"
)
print(h2_plot_no_rrp)

# Plot 2: Standard RDD for With RRP
h2_plot_with_rrp <- plot_rdd(
  data = clean_data_with_rrp,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position",
  title = "H2b: Klimafokus med højreradikale partier i parlamentet (lag1)"
)
print(h2_plot_with_rrp)

# Plot 3: RDD for Non-Zero Values Only (No RRP)
h2_plot_nonzero_no_rrp <- plot_rdd(
  data = nonzero_data_no_rrp,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position (Non-Zeros Only)",
  title = "H2a: Klimafokus uden højreradikale partier - Kun ikke-nul værdier"
)
print(h2_plot_nonzero_no_rrp)

# Plot 4: RDD for Non-Zero Values Only (With RRP)
h2_plot_nonzero_with_rrp <- plot_rdd(
  data = nonzero_data_with_rrp,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position (Non-Zeros Only)",
  title = "H2b: Klimafokus med højreradikale partier - Kun ikke-nul værdier"
)
print(h2_plot_nonzero_with_rrp)

# Kombiner plots til sammenligning (hvis du har gridExtra pakken)
if (requireNamespace("gridExtra", quietly = TRUE)) {
  gridExtra::grid.arrange(h2_plot_no_rrp, h2_plot_with_rrp, ncol = 2,
                         top = "Sammenligning af grøn partis effekt med/uden RRP i parlament (lag1)")
  
  gridExtra::grid.arrange(h2_plot_nonzero_no_rrp, h2_plot_nonzero_with_rrp, ncol = 2,
                         top = "Sammenligning (kun ikke-nul værdier) med/uden RRP i parlament (lag1)")
}

# ============================================================================
# 10. Interaction Effects Visualization
# ============================================================================

# Test for trevejs-interaktion mellem rrp_i_p_lag1, green party vote share og repræsentation
h2_model_3way <- lm(miljø_afhængig ~ rrp_i_p_lag1 * centered_lagged_pervote_samlet * lagged_i_parlament, 
                   data = final_dataset)
summary(h2_model_3way)

# Visuel sammenligning af interaktionseffekter
if (requireNamespace("ggplot2", quietly = TRUE) && requireNamespace("tidyr", quietly = TRUE)) {
  # Lav forudsigelser baseret på modellen
  pred_data <- expand.grid(
    rrp_i_p_lag1 = c(0, 1),
    centered_lagged_pervote_samlet = seq(-5, 5, by = 0.5),
    lagged_i_parlament = c(0, 1)
  )
  
  pred_data$predicted <- predict(h2_model_3way, newdata = pred_data)
  
  # Tilføj faktorer for pænere labels
  pred_data$rrp_status <- factor(pred_data$rrp_i_p_lag1, 
                               levels = c(0, 1),
                               labels = c("Ingen RRP i parlament (lag1)", "RRP i parlament (lag1)"))
  
  pred_data$gp_status <- factor(pred_data$lagged_i_parlament,
                              levels = c(0, 1),
                              labels = c("Grønt parti uden sæde", "Grønt parti med sæde"))
  
  # Plot interaktionen
  ggplot2::ggplot(pred_data, ggplot2::aes(x = centered_lagged_pervote_samlet, 
                                         y = predicted, 
                                         color = gp_status, 
                                         linetype = gp_status)) +
    ggplot2::geom_line() +
    ggplot2::facet_wrap(~ rrp_status) +
    ggplot2::geom_vline(xintercept = 0, linetype = "dashed") +
    ggplot2::theme_minimal() +
    ggplot2::labs(
      title = "Forudsagt klimaposition baseret på trevejs-interaktionsmodel (lag1)",
      x = "Grønt partis stemmeandel (centreret ved tærskel)",
      y = "Forudsagt klimaposition",
      color = "Grønt parti status",
      linetype = "Grønt parti status"
    )
}

# ============================================================================
# 11. Quantile Regression Interaction Effects
# ============================================================================

# Quantile regression specifically examining interaction between RRP and Green party effects
h2_quantile_interaction <- rq(miljø_afhængig ~ rrp_i_p_lag1 * lagged_i_parlament, 
                            tau = 0.5, data = final_dataset)
summary(h2_quantile_interaction)

# Multiple quantiles to see how interaction varies across distribution
h2_multi_quant_interaction <- rq(miljø_afhængig ~ rrp_i_p_lag1 * lagged_i_parlament, 
                               tau = c(0.25, 0.5, 0.75), data = final_dataset)
summary(h2_multi_quant_interaction)

# ============================================================================
# 12. Comparison Summary Table
# ============================================================================

# Create a table to compare coefficients across different model specifications
if (requireNamespace("texreg", quietly = TRUE)) {
  library(texreg)
  # Export HTML table comparing different models and RRP status
  htmlreg(list(h2_continuous_no_rrp, h2_continuous_with_rrp, 
              h2_median_rq_no_rrp, h2_median_rq_with_rrp, 
              h2_robust_reg_no_rrp, h2_robust_reg_with_rrp),
         file = "h2_model_comparison.html",
         custom.model.names = c("OLS No RRP", "OLS With RRP", 
                               "Median No RRP", "Median With RRP", 
                               "Robust No RRP", "Robust With RRP"),
         custom.coef.names = c("Intercept", "Vote Share", "Parliament", "Vote Share × Parliament"),
         caption = "Comparison of Different Modeling Approaches for H2 by RRP Status")
}
```


## 3.3

```{r h3_analysis}
# ============================================================================
# 0. Create economic indicators
# ============================================================================

# Create a composite economic indicator from existing variables in final_dataset
# Standardize each variable first (higher value = better economy)
final_dataset <- final_dataset %>%
  mutate(
    gdp_growth_std = scale(`GDP per capita growth`),
    inflation_std = -scale(`Inflation-consumer prices`),  # Minus because lower inflation is better
    unemployment_std = -scale(Unemployment)  # Minus because lower unemployment is better
  )

# Calculate an overall economic index (average of standardized values)
final_dataset <- final_dataset %>%
  mutate(
    economic_index = rowMeans(
      cbind(gdp_growth_std, inflation_std, unemployment_std),
      na.rm = TRUE
    ),
    # Create binary variable for good economy based on composite index
    good_economy = ifelse(economic_index > median(economic_index, na.rm = TRUE), 1, 0),
    # Add factor version of the variable for plots and models
    factor_good_economy = factor(good_economy, levels = c(0, 1), 
                                labels = c("Poor economy", "Good economy"))
  )

# Forberedelse af data med BNP-vækst som moderator
final_dataset <- final_dataset %>%
  mutate(
    # Opret binær variabel for høj/lav BNP-vækst baseret på median
    high_gdp_growth = ifelse(`GDP per capita growth` > median(`GDP per capita growth`, na.rm = TRUE), 1, 0),
    # Tilføj faktorniveauer for pænere plots og modeller
    factor_high_gdp_growth = factor(high_gdp_growth, levels = c(0, 1), 
                                  labels = c("Lav BNP-vækst", "Høj BNP-vækst"))
  )

# ============================================================================
# PART 1: ANALYSIS WITH GDP GROWTH AS MODERATOR
# ============================================================================

# Opdel data baseret på BNP-vækst
clean_data_high_gdp <- subset(final_dataset, high_gdp_growth == 1)
clean_data_low_gdp <- subset(final_dataset, high_gdp_growth == 0)

# ============================================================================
# 1.1 Basic Linear Models with GDP Growth
# ============================================================================

# Simple linear model
h3_gdp_model_simple <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet + lagged_i_parlament,
                     data = final_dataset)
summary(h3_gdp_model_simple)

# Interaction model med BNP-vækst
h3_gdp_interaction <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament * high_gdp_growth, 
                      data = final_dataset)
summary(h3_gdp_interaction)

# Clustered standard errors (by party)
if (exists("coeftest.cluster_grøn")) {
  data_used <- na.omit(final_dataset[, c("miljø_afhængig", "centered_lagged_pervote_samlet", 
                                     "lagged_i_parlament", "party", "edate", "country", "high_gdp_growth")])
  
  # Brug data_used i stedet for final_dataset
  h3_gdp_robust <- coeftest.cluster_grøn(
    data = data_used,
    fm = h3_gdp_interaction,
    cluster1 = data_used$party  # Pass the vector directly
  )
  print(h3_gdp_robust)
  
  # Double-clustered standard errors (by party and election date)
  h3_gdp_robust_double <- summary.cluster_grøn(
    obj = h3_gdp_interaction, 
    data = data_used, 
    cluster1 = "party", 
    cluster2 = "edate"
  )
  print(h3_gdp_robust_double)
}

# ============================================================================
# 1.2 Two-Part Model for GDP Growth Subsets
# ============================================================================

# HIGH GDP GROWTH: Two-Part Model
# Part 1: Logit model for predicting non-zero climate focus
h3_binary_high_gdp <- glm(I(miljø_afhængig != 0) ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                       family = binomial, data = clean_data_high_gdp)
summary(h3_binary_high_gdp)

# Part 2: Linear model on non-zero values only
h3_continuous_high_gdp <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                          data = subset(clean_data_high_gdp, miljø_afhængig != 0))
summary(h3_continuous_high_gdp)

# LOW GDP GROWTH: Two-Part Model
# Part 1: Logit model for predicting non-zero climate focus
h3_binary_low_gdp <- glm(I(miljø_afhængig != 0) ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                      family = binomial, data = clean_data_low_gdp)
summary(h3_binary_low_gdp)

# Part 2: Linear model on non-zero values only
h3_continuous_low_gdp <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                         data = subset(clean_data_low_gdp, miljø_afhængig != 0))
summary(h3_continuous_low_gdp)

# ============================================================================
# 1.3 Quantile Regression for GDP Growth Subsets
# ============================================================================

# HIGH GDP GROWTH: Quantile Regression
# Median regression
h3_median_rq_high_gdp <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                         tau = 0.5, data = clean_data_high_gdp)
summary(h3_median_rq_high_gdp)

# Multiple quantiles
h3_multi_quantile_high_gdp <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                              tau = c(0.25, 0.5, 0.75), data = clean_data_high_gdp)
summary(h3_multi_quantile_high_gdp)

# Generate plot for coefficients across quantiles
h3_quantile_plot_high_gdp <- plot(summary(rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                                         tau = seq(0.1, 0.9, by = 0.1), data = clean_data_high_gdp)))

# LOW GDP GROWTH: Quantile Regression
# Median regression
h3_median_rq_low_gdp <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                        tau = 0.5, data = clean_data_low_gdp)
summary(h3_median_rq_low_gdp)

# Multiple quantiles
h3_multi_quantile_low_gdp <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                             tau = c(0.25, 0.5, 0.75), data = clean_data_low_gdp)
summary(h3_multi_quantile_low_gdp)

# Generate plot for coefficients across quantiles
h3_quantile_plot_low_gdp <- plot(summary(rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                                        tau = seq(0.1, 0.9, by = 0.1), data = clean_data_low_gdp)))

# Save quantile plots
pdf("h3_quantile_coefficients_high_gdp.pdf", width = 10, height = 8)
print(h3_quantile_plot_high_gdp)
dev.off()

pdf("h3_quantile_coefficients_low_gdp.pdf", width = 10, height = 8)
print(h3_quantile_plot_low_gdp)
dev.off()

# ============================================================================
# 1.4 Robust Regression for GDP Growth Subsets
# ============================================================================

# Robust regression for full sample with GDP interaction
h3_robust_reg_gdp <- rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament * high_gdp_growth, 
                      data = final_dataset, method = "MM")
summary(h3_robust_reg_gdp)

# HIGH GDP GROWTH: Robust Regression
h3_robust_reg_high_gdp <- rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                           data = clean_data_high_gdp, method = "MM")
summary(h3_robust_reg_high_gdp)

# LOW GDP GROWTH: Robust Regression
h3_robust_reg_low_gdp <- rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                          data = clean_data_low_gdp, method = "MM")
summary(h3_robust_reg_low_gdp)

# ============================================================================
# 1.5 RDD Analysis for GDP Growth Subsets
# ============================================================================

# Multi-polynomial RDD with custom function
if (exists("rd.base_grøn")) {
  # Høj BNP-vækst sample
  rd.multic_h3_high_gdp <- rd.base_grøn(
    data = clean_data_high_gdp,
    force.var = 'centered_lagged_pervote_samlet',
    yvar = 'miljø_afhængig',
    seat.identifier = 'factor_lagged_i_parlament',
    fixed.effects = 'country',
    clust1 = 'party',
    clust2 = 'edate',
    polynomials = c(1, 2, 3, 4),
    bws = NULL
  )
  print(rd.multic_h3_high_gdp)
  
  # Lav BNP-vækst sample
  rd.multic_h3_low_gdp <- rd.base_grøn(
    data = clean_data_low_gdp,
    force.var = 'centered_lagged_pervote_samlet',
    yvar = 'miljø_afhængig',
    seat.identifier = 'factor_lagged_i_parlament',
    fixed.effects = 'country',
    clust1 = 'party',
    clust2 = 'edate',
    polynomials = c(1, 2, 3, 4),
    bws = NULL
  )
  print(rd.multic_h3_low_gdp)
}

# Robustness analysis med forskellige båndbredder
covariates_to_use <- c("country", "edate")

# Kør robusthedsanalysen på høj BNP-vækst data
results_df_h3_high_gdp <- run_rdd_robustness(
  data = clean_data_high_gdp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = c(1, 1.5, 2, 2.5, 3),
  polynomials = c(1, 2, 3, 4),
  covariates = covariates_to_use,
  group_label = "H3 - Høj BNP-vækst"
)

# Kør robusthedsanalysen på lav BNP-vækst data
results_df_h3_low_gdp <- run_rdd_robustness(
  data = clean_data_low_gdp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = c(1, 1.5, 2, 2.5, 3),
  polynomials = c(1, 2, 3, 4),
  covariates = covariates_to_use,
  group_label = "H3 - Lav BNP-vækst"
)

# Vis resultater
print(results_df_h3_high_gdp)
print(results_df_h3_low_gdp)

# Kombiner resultater i en pæn tabel med knitr
if (requireNamespace("knitr", quietly = TRUE)) {
  combined_results_gdp <- rbind(results_df_h3_high_gdp, results_df_h3_low_gdp)
  
  print(knitr::kable(combined_results_gdp, 
                    caption = "H3: Robusthedstest opdelt efter BNP-vækst"))
}

# ============================================================================
# 1.6 Enhanced rdrobust Analysis for GDP Growth Subsets - FIXED
# ============================================================================

# HIGH GDP GROWTH: Standard rdrobust (without covariates)
h3_rdd_high_gdp <- rdrobust(
  y = clean_data_high_gdp$miljø_afhængig,
  x = clean_data_high_gdp$centered_lagged_pervote_samlet,
  c = 0,
  p = 1,  # linear polynomial
  kernel = "triangular",
  bwselect = "mserd"  # MSE-optimal bandwidth
)
summary(h3_rdd_high_gdp)

# HIGH GDP GROWTH: rdrobust with simpler covariates and fixed bandwidth
tryCatch({
  # Try with fixed bandwidth first
  h3_rdd_covs_high_gdp <- rdrobust(
    y = clean_data_high_gdp$miljø_afhængig,
    x = clean_data_high_gdp$centered_lagged_pervote_samlet,
    c = 0,
    covs = model.matrix(~ factor(country), data = clean_data_high_gdp)[,-1],  # Simplified covariate
    p = 1,
    kernel = "triangular",
    h = 2  # Use fixed bandwidth instead of optimal selection
  )
  summary(h3_rdd_covs_high_gdp)
}, error = function(e) {
  cat("Fixed bandwidth with covariates still failed:", e$message, "\n")
  cat("Trying with just country fixed effects and no other covariates...\n")
  
  # Try with even simpler approach - just country FE
  tryCatch({
    h3_rdd_country_high_gdp <- rdrobust(
      y = clean_data_high_gdp$miljø_afhængig,
      x = clean_data_high_gdp$centered_lagged_pervote_samlet,
      c = 0,
      covs = model.matrix(~ factor(country), data = clean_data_high_gdp)[,-1],
      p = 1,
      kernel = "uniform",  # Try different kernel
      h = 3  # Try even wider bandwidth
    )
    summary(h3_rdd_country_high_gdp)
  }, error = function(e2) {
    cat("Even simpler approach failed:", e2$message, "\n")
    cat("Proceeding with analysis without covariates for high GDP growth subset\n")
  })
})

# LOW GDP GROWTH: rdrobust with error handling
tryCatch({
  h3_rdd_low_gdp <- rdrobust(
    y = clean_data_low_gdp$miljø_afhængig,
    x = clean_data_low_gdp$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,
    kernel = "triangular",
    bwselect = "mserd"
  )
  summary(h3_rdd_low_gdp)
}, error = function(e) {
  cat("Note: Kunne ikke beregne RDD for lav BNP-vækst gruppe pga:", e$message, "\n")
  cat("Dette kan skyldes utilstrækkelige data eller høj kollinearitet i subset med lav BNP-vækst.\n")
  
  # Try with fixed bandwidth
  tryCatch({
    cat("Forsøger med fast båndbredde i stedet...\n")
    h3_rdd_low_gdp_alt <- rdrobust(
      y = clean_data_low_gdp$miljø_afhængig,
      x = clean_data_low_gdp$centered_lagged_pervote_samlet,
      c = 0,
      p = 1,
      kernel = "triangular",
      h = 2
    )
    summary(h3_rdd_low_gdp_alt)
  }, error = function(e2) {
    cat("Alternativ specifikation fejlede også:", e2$message, "\n")
  })
})

# ============================================================================
# 1.7 Separate Analysis for Zero and Non-Zero Values by GDP Growth
# ============================================================================

# HIGH GDP GROWTH: Split data into zero and non-zero values
zero_data_high_gdp <- subset(clean_data_high_gdp, miljø_afhængig == 0)
nonzero_data_high_gdp <- subset(clean_data_high_gdp, miljø_afhængig != 0)

# LOW GDP GROWTH: Split data into zero and non-zero values
zero_data_low_gdp <- subset(clean_data_low_gdp, miljø_afhængig == 0)
nonzero_data_low_gdp <- subset(clean_data_low_gdp, miljø_afhængig != 0)

# RDD for non-zero values only (HIGH GDP GROWTH)
tryCatch({
  h3_rdd_nonzero_high_gdp <- rdrobust(
    y = nonzero_data_high_gdp$miljø_afhængig,
    x = nonzero_data_high_gdp$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,
    kernel = "triangular",
    bwselect = "mserd"
  )
  summary(h3_rdd_nonzero_high_gdp)
}, error = function(e) {
  cat("Note: RDD for non-zero values in high GDP group failed:", e$message, "\n")
  # Try with fixed bandwidth
  tryCatch({
    h3_rdd_nonzero_high_gdp_fixed <- rdrobust(
      y = nonzero_data_high_gdp$miljø_afhængig,
      x = nonzero_data_high_gdp$centered_lagged_pervote_samlet,
      c = 0,
      p = 1,
      kernel = "triangular",
      h = 2
    )
    summary(h3_rdd_nonzero_high_gdp_fixed)
  }, error = function(e2) {
    cat("Fixed bandwidth also failed:", e2$message, "\n")
  })
})

# RDD for non-zero values only (LOW GDP GROWTH)
tryCatch({
  h3_rdd_nonzero_low_gdp <- rdrobust(
    y = nonzero_data_low_gdp$miljø_afhængig,
    x = nonzero_data_low_gdp$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,
    kernel = "triangular",
    bwselect = "mserd"
  )
  summary(h3_rdd_nonzero_low_gdp)
}, error = function(e) {
  cat("Note: RDD for non-zero values in low GDP group failed:", e$message, "\n")
  # Try with fixed bandwidth
  tryCatch({
    h3_rdd_nonzero_low_gdp_fixed <- rdrobust(
      y = nonzero_data_low_gdp$miljø_afhængig,
      x = nonzero_data_low_gdp$centered_lagged_pervote_samlet,
      c = 0,
      p = 1,
      kernel = "triangular",
      h = 2
    )
    summary(h3_rdd_nonzero_low_gdp_fixed)
  }, error = function(e2) {
    cat("Fixed bandwidth also failed:", e2$message, "\n")
  })
})

# ============================================================================
# 1.8 Visual Confirmation and RDD Plots for GDP Growth
# ============================================================================

# Visuel bekræftelse - høj BNP-vækst
h3_plot_high_gdp <- plot_rdd(
  data = clean_data_high_gdp,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Grønt partis stemmeandel (centreret)",
  y_label = "Klimaposition",
  title = "H3: Effekt ved høj BNP-vækst"
)
print(h3_plot_high_gdp)

# Visuel bekræftelse - lav BNP-vækst
h3_plot_low_gdp <- plot_rdd(
  data = clean_data_low_gdp,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Grønt partis stemmeandel (centreret)",
  y_label = "Klimaposition",
  title = "H3: Effekt ved lav BNP-vækst"
)
print(h3_plot_low_gdp)

# Plots for non-zero values only - high GDP
h3_plot_nonzero_high_gdp <- plot_rdd(
  data = nonzero_data_high_gdp,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Grønt partis stemmeandel (centreret)",
  y_label = "Klimaposition (kun ikke-nul værdier)",
  title = "H3: Effekt ved høj BNP-vækst (kun ikke-nul værdier)"
)
print(h3_plot_nonzero_high_gdp)

# Plots for non-zero values only - low GDP
h3_plot_nonzero_low_gdp <- plot_rdd(
  data = nonzero_data_low_gdp,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Grønt partis stemmeandel (centreret)",
  y_label = "Klimaposition (kun ikke-nul værdier)",
  title = "H3: Effekt ved lav BNP-vækst (kun ikke-nul værdier)"
)
print(h3_plot_nonzero_low_gdp)

# Kombiner plots hvis gridExtra er tilgængelig
if (requireNamespace("gridExtra", quietly = TRUE)) {
  gridExtra::grid.arrange(h3_plot_high_gdp, h3_plot_low_gdp, ncol = 2,
                         top = "H3: Effekt opdelt efter BNP-vækst")
  
  gridExtra::grid.arrange(h3_plot_nonzero_high_gdp, h3_plot_nonzero_low_gdp, ncol = 2,
                         top = "H3: Effekt opdelt efter BNP-vækst (kun ikke-nul værdier)")
}

# ============================================================================
# PART 2: ANALYSIS WITH COMPOSITE ECONOMIC INDICATOR - UPDATED WITH FIXES
# ============================================================================

# Split data based on economic condition
clean_data_good_economy <- subset(final_dataset, good_economy == 1)
clean_data_bad_economy <- subset(final_dataset, good_economy == 0)

# ============================================================================
# 2.1 Basic Linear Models with Economic Index
# ============================================================================

# Simple linear model
h3_model_simple <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet + lagged_i_parlament,
                     data = final_dataset)
summary(h3_model_simple)

# Interaction model with economic factors
h3_model_interaction <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament * good_economy, 
                        data = final_dataset)
summary(h3_model_interaction)

# Clustered standard errors (by party)
if (exists("coeftest.cluster_grøn")) {
  data_used <- na.omit(final_dataset[, c("miljø_afhængig", "centered_lagged_pervote_samlet", 
                                     "lagged_i_parlament", "party", "edate", "country", "good_economy")])
  
  h3_robust <- coeftest.cluster_grøn(
    data = data_used,
    fm = h3_model_interaction,
    cluster1 = data_used$party  # Pass the vector directly
  )
  print(h3_robust)
  
  # Double-clustered standard errors (by party and election date)
  h3_robust_double <- summary.cluster_grøn(
    obj = h3_model_interaction, 
    data = data_used, 
    cluster1 = "party", 
    cluster2 = "edate"
  )
  print(h3_robust_double)
}

# ============================================================================
# 2.2 Two-Part Model for Economic Condition Subsets
# ============================================================================

# GOOD ECONOMY: Two-Part Model
# Part 1: Logit model for predicting non-zero climate focus
h3_binary_good_econ <- glm(I(miljø_afhængig != 0) ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                        family = binomial, data = clean_data_good_economy)
summary(h3_binary_good_econ)

# Part 2: Linear model on non-zero values only
h3_continuous_good_econ <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                           data = subset(clean_data_good_economy, miljø_afhængig != 0))
summary(h3_continuous_good_econ)

# BAD ECONOMY: Two-Part Model
# Part 1: Logit model for predicting non-zero climate focus
h3_binary_bad_econ <- glm(I(miljø_afhængig != 0) ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                       family = binomial, data = clean_data_bad_economy)
summary(h3_binary_bad_econ)

# Part 2: Linear model on non-zero values only
h3_continuous_bad_econ <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                          data = subset(clean_data_bad_economy, miljø_afhængig != 0))
summary(h3_continuous_bad_econ)

# ============================================================================
# 2.3 Quantile Regression for Economic Condition Subsets
# ============================================================================

# GOOD ECONOMY: Quantile Regression
# Median regression
h3_median_rq_good_econ <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                          tau = 0.5, data = clean_data_good_economy)
summary(h3_median_rq_good_econ)

# Multiple quantiles
h3_multi_quantile_good_econ <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                               tau = c(0.25, 0.5, 0.75), data = clean_data_good_economy)
summary(h3_multi_quantile_good_econ)

# Generate plot for coefficients across quantiles
h3_quantile_plot_good_econ <- plot(summary(rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                                          tau = seq(0.1, 0.9, by = 0.1), data = clean_data_good_economy)))

# BAD ECONOMY: Quantile Regression
# Median regression
h3_median_rq_bad_econ <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                         tau = 0.5, data = clean_data_bad_economy)
summary(h3_median_rq_bad_econ)

# Multiple quantiles
h3_multi_quantile_bad_econ <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                              tau = c(0.25, 0.5, 0.75), data = clean_data_bad_economy)
summary(h3_multi_quantile_bad_econ)

# Generate plot for coefficients across quantiles
h3_quantile_plot_bad_econ <- plot(summary(rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                                         tau = seq(0.1, 0.9, by = 0.1), data = clean_data_bad_economy)))

# Save quantile plots
pdf("h3_quantile_coefficients_good_econ.pdf", width = 10, height = 8)
print(h3_quantile_plot_good_econ)
dev.off()

pdf("h3_quantile_coefficients_bad_econ.pdf", width = 10, height = 8)
print(h3_quantile_plot_bad_econ)
dev.off()

# ============================================================================
# 2.4 Robust Regression for Economic Condition Subsets
# ============================================================================

# Robust regression for full sample with economic interaction
h3_robust_reg_econ <- rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament * good_economy, 
                       data = final_dataset, method = "MM")
summary(h3_robust_reg_econ)

# GOOD ECONOMY: Robust Regression
h3_robust_reg_good_econ <- rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                            data = clean_data_good_economy, method = "MM")
summary(h3_robust_reg_good_econ)

# BAD ECONOMY: Robust Regression
h3_robust_reg_bad_econ <- rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                           data = clean_data_bad_economy, method = "MM")
summary(h3_robust_reg_bad_econ)

# ============================================================================
# 2.5 RDD Analysis for Economic Condition Subsets - FIXED
# ============================================================================

# Multi-polynomial RDD with custom function
if (exists("rd.base_grøn")) {
  # Good economy sample
  rd.multic_h3_good <- rd.base_grøn(
    data = clean_data_good_economy,
    force.var = 'centered_lagged_pervote_samlet',
    yvar = 'miljø_afhængig',
    seat.identifier = 'factor_lagged_i_parlament',
    fixed.effects = 'country',
    clust1 = 'party',
    clust2 = 'edate',
    polynomials = c(1, 2, 3, 4),
    bws = NULL
  )
  print(rd.multic_h3_good)
  
  # Bad economy sample
  rd.multic_h3_bad <- rd.base_grøn(
    data = clean_data_bad_economy,
    force.var = 'centered_lagged_pervote_samlet',
    yvar = 'miljø_afhængig',
    seat.identifier = 'factor_lagged_i_parlament',
    fixed.effects = 'country',
    clust1 = 'party',
    clust2 = 'edate',
    polynomials = c(1, 2, 3, 4),
    bws = NULL
  )
  print(rd.multic_h3_bad)
}

# Robustness analysis with different bandwidths
# Define covariates to control for
covariates_to_use <- c("country", "edate")

# Run the robustness analysis on good economy data
results_df_h3_good <- run_rdd_robustness(
  data = clean_data_good_economy,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = c(1, 1.5, 2, 2.5, 3),
  polynomials = c(1, 2, 3, 4),
  covariates = covariates_to_use,
  group_label = "H3 - Good Economy"
)

# Run the robustness analysis on bad economy data
results_df_h3_bad <- run_rdd_robustness(
  data = clean_data_bad_economy,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = c(1, 1.5, 2, 2.5, 3),
  polynomials = c(1, 2, 3, 4),
  covariates = covariates_to_use,
  group_label = "H3 - Bad Economy"
)

# Show results
print(results_df_h3_good)
print(results_df_h3_bad)

# Create a nice table with knitr
if (requireNamespace("knitr", quietly = TRUE)) {
  # Combine results
  combined_results_economy <- rbind(results_df_h3_good, results_df_h3_bad)
  
  print(knitr::kable(combined_results_economy, 
                    caption = "H3: Robustness Test Across Economic Conditions"))
}

# ============================================================================
# 2.6 Enhanced rdrobust Analysis for Economic Condition Subsets - FIXED
# ============================================================================

# GOOD ECONOMY: Standard rdrobust (without covariates)
h3_rdd_good <- rdrobust(
  y = clean_data_good_economy$miljø_afhængig,
  x = clean_data_good_economy$centered_lagged_pervote_samlet,
  c = 0,
  p = 1,  # linear polynomial
  kernel = "triangular",
  bwselect = "mserd"  # MSE-optimal bandwidth
)
summary(h3_rdd_good)

# GOOD ECONOMY: rdrobust with simpler approach and fixed bandwidth
tryCatch({
  # Try with fixed bandwidth and minimal covariates
  h3_rdd_covs_good_simple <- rdrobust(
    y = clean_data_good_economy$miljø_afhængig,
    x = clean_data_good_economy$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,
    kernel = "triangular",
    h = 2  # Fixed bandwidth
  )
  summary(h3_rdd_covs_good_simple)
}, error = function(e) {
  cat("Note: Even simplified rdrobust for good economy failed:", e$message, "\n")
})

# BAD ECONOMY: rdrobust with error handling
tryCatch({
  h3_rdd_bad <- rdrobust(
    y = clean_data_bad_economy$miljø_afhængig,
    x = clean_data_bad_economy$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,  # linear polynomial
    kernel = "triangular",
    bwselect = "mserd"  # MSE-optimal bandwidth
  )
  summary(h3_rdd_bad)
}, error = function(e) {
  cat("Note: Could not compute RDD for bad economy group due to:", e$message, "\n")
  
  # Try with fixed bandwidth
  tryCatch({
    cat("Attempting with fixed bandwidth instead...\n")
    h3_rdd_bad_alt <- rdrobust(
      y = clean_data_bad_economy$miljø_afhængig,
      x = clean_data_bad_economy$centered_lagged_pervote_samlet,
      c = 0,
      p = 1,  # linear polynomial
      kernel = "triangular",
      h = 2  # fixed bandwidth
    )
    summary(h3_rdd_bad_alt)
  }, error = function(e2) {
    cat("Alternative specification also failed:", e2$message, "\n")
  })
})

# ============================================================================
# 2.7 Separate Analysis for Zero and Non-Zero Values by Economic Condition
# ============================================================================

# GOOD ECONOMY: Split data into zero and non-zero values
zero_data_good_econ <- subset(clean_data_good_economy, miljø_afhængig == 0)
nonzero_data_good_econ <- subset(clean_data_good_economy, miljø_afhængig != 0)

# BAD ECONOMY: Split data into zero and non-zero values
zero_data_bad_econ <- subset(clean_data_bad_economy, miljø_afhængig == 0)
nonzero_data_bad_econ <- subset(clean_data_bad_economy, miljø_afhængig != 0)

# RDD for non-zero values only (GOOD ECONOMY)
tryCatch({
  h3_rdd_nonzero_good_econ <- rdrobust(
    y = nonzero_data_good_econ$miljø_afhængig,
    x = nonzero_data_good_econ$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,
    kernel = "triangular",
    bwselect = "mserd"
  )
  summary(h3_rdd_nonzero_good_econ)
}, error = function(e) {
  cat("Note: RDD for non-zero values in good economy group failed:", e$message, "\n")
  # Try with fixed bandwidth
  tryCatch({
    h3_rdd_nonzero_good_econ_fixed <- rdrobust(
      y = nonzero_data_good_econ$miljø_afhængig,
      x = nonzero_data_good_econ$centered_lagged_pervote_samlet,
      c = 0,
      p = 1,
      kernel = "triangular",
      h = 2
    )
    summary(h3_rdd_nonzero_good_econ_fixed)
  }, error = function(e2) {
    cat("Fixed bandwidth also failed:", e2$message, "\n")
  })
})

# RDD for non-zero values only (BAD ECONOMY)
tryCatch({
  h3_rdd_nonzero_bad_econ <- rdrobust(
    y = nonzero_data_bad_econ$miljø_afhængig,
    x = nonzero_data_bad_econ$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,
    kernel = "triangular",
    bwselect = "mserd"
  )
  summary(h3_rdd_nonzero_bad_econ)
}, error = function(e) {
  cat("Note: RDD for non-zero values in bad economy group failed:", e$message, "\n")
  # Try with fixed bandwidth
  tryCatch({
    h3_rdd_nonzero_bad_econ_fixed <- rdrobust(
      y = nonzero_data_bad_econ$miljø_afhængig,
      x = nonzero_data_bad_econ$centered_lagged_pervote_samlet,
      c = 0,
      p = 1,
      kernel = "triangular",
      h = 2
    )
    summary(h3_rdd_nonzero_bad_econ_fixed)
  }, error = function(e2) {
    cat("Fixed bandwidth also failed:", e2$message, "\n")
  })
})

# ============================================================================
# 2.8 Visual Confirmation and RDD Plots for Economic Condition
# ============================================================================

# Visual confirmation - good economy
h3_plot_good <- plot_rdd(
  data = clean_data_good_economy,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position",
  title = "H3: Effect Under Good Economic Conditions"
)
print(h3_plot_good)

# Visual confirmation - bad economy
h3_plot_bad <- plot_rdd(
  data = clean_data_bad_economy,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position",
  title = "H3: Effect Under Poor Economic Conditions"
)
print(h3_plot_bad)

# Plots for non-zero values only - good economy
h3_plot_nonzero_good_econ <- plot_rdd(
  data = nonzero_data_good_econ,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position (Non-Zeros Only)",
  title = "H3: Effect Under Good Economy (Non-Zero Values Only)"
)
print(h3_plot_nonzero_good_econ)

# Plots for non-zero values only - bad economy
h3_plot_nonzero_bad_econ <- plot_rdd(
  data = nonzero_data_bad_econ,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position (Non-Zeros Only)",
  title = "H3: Effect Under Poor Economy (Non-Zero Values Only)"
)
print(h3_plot_nonzero_bad_econ)

# Combine plots if gridExtra is available
if (requireNamespace("gridExtra", quietly = TRUE)) {
  # Economic condition
  gridExtra::grid.arrange(h3_plot_good, h3_plot_bad, ncol = 2,
                         top = "H3: Effect Split by Economic Condition")
  
  gridExtra::grid.arrange(h3_plot_nonzero_good_econ, h3_plot_nonzero_bad_econ, ncol = 2,
                         top = "H3: Effect Split by Economic Condition (Non-Zero Values Only)")
}

# ============================================================================
# 3. Additional Models and Interaction Analysis
# ============================================================================

# Simpler interaction model for GDP growth
h3_gdp_simple_int <- lm(
  miljø_afhængig ~ lagged_i_parlament * high_gdp_growth + centered_lagged_pervote_samlet,
  data = final_dataset
)
summary(h3_gdp_simple_int)

# Simpler interaction model for economic condition
h3_econ_simple_int <- lm(
  miljø_afhængig ~ lagged_i_parlament * good_economy + centered_lagged_pervote_samlet,
  data = final_dataset
)
summary(h3_econ_simple_int)

# Triple interaction with GDP
h3_gdp_triple <- lm(
  miljø_afhængig ~ lagged_i_parlament * high_gdp_growth * centered_lagged_pervote_samlet,
  data = final_dataset
)
summary(h3_gdp_triple)

# Triple interaction with economic condition
h3_econ_triple <- lm(
  miljø_afhængig ~ lagged_i_parlament * good_economy * centered_lagged_pervote_samlet,
  data = final_dataset
)
summary(h3_econ_triple)

# IV estimation with interaction with GDP growth
h3_iv_gdp <- ivreg(miljø_afhængig ~ lagged_i_parlament * high_gdp_growth | 
                  centered_lagged_pervote_samlet * high_gdp_growth, 
                 data = final_dataset)
summary(h3_iv_gdp, diagnostics = TRUE)

# IV estimation with interaction with economic condition
h3_iv_econ <- ivreg(miljø_afhængig ~ lagged_i_parlament * good_economy | 
                   centered_lagged_pervote_samlet * good_economy, 
                  data = final_dataset)
summary(h3_iv_econ, diagnostics = TRUE)

# ============================================================================
# 4. Visual Interaction Effects and Predictions
# ============================================================================

# Visual comparison of GDP growth interaction effects
if (requireNamespace("ggplot2", quietly = TRUE) && requireNamespace("tidyr", quietly = TRUE)) {
  # Make predictions based on the model
  pred_data_gdp <- expand.grid(
    high_gdp_growth = c(0, 1),
    centered_lagged_pervote_samlet = seq(-5, 5, by = 0.5),
    lagged_i_parlament = c(0, 1)
  )
  
  pred_data_gdp$predicted <- predict(h3_gdp_triple, newdata = pred_data_gdp)
  
  # Add factors for nicer labels
  pred_data_gdp$gdp_status <- factor(pred_data_gdp$high_gdp_growth, 
                                   levels = c(0, 1),
                                   labels = c("Lav BNP-vækst", "Høj BNP-vækst"))
  
  pred_data_gdp$gp_status <- factor(pred_data_gdp$lagged_i_parlament,
                                  levels = c(0, 1),
                                  labels = c("Grønt parti uden sæde", "Grønt parti med sæde"))
  
  # Plot the interaction
  ggplot2::ggplot(pred_data_gdp, ggplot2::aes(x = centered_lagged_pervote_samlet, 
                                            y = predicted, 
                                            color = gp_status, 
                                            linetype = gp_status)) +
    ggplot2::geom_line() +
    ggplot2::facet_wrap(~ gdp_status) +
    ggplot2::geom_vline(xintercept = 0, linetype = "dashed") +
    ggplot2::theme_minimal() +
    ggplot2::labs(
      title = "H3: Forudsagt klimaposition baseret på BNP-vækst",
      x = "Grønt partis stemmeandel (centreret ved tærskel)",
      y = "Forudsagt klimaposition",
      color = "Grønt parti status",
      linetype = "Grønt parti status"
    )
}

# Visual comparison of economic index interaction effects
if (requireNamespace("ggplot2", quietly = TRUE) && requireNamespace("tidyr", quietly = TRUE)) {
  # Make predictions based on the model
  pred_data_econ <- expand.grid(
    good_economy = c(0, 1),
    centered_lagged_pervote_samlet = seq(-5, 5, by = 0.5),
    lagged_i_parlament = c(0, 1)
  )
  
  pred_data_econ$predicted <- predict(h3_econ_triple, newdata = pred_data_econ)
  
  # Add factors for nicer labels
  pred_data_econ$economy_status <- factor(pred_data_econ$good_economy, 
                                        levels = c(0, 1),
                                        labels = c("Poor Economic Conditions", "Good Economic Conditions"))
  
  pred_data_econ$gp_status <- factor(pred_data_econ$lagged_i_parlament,
                                   levels = c(0, 1),
                                   labels = c("Green Party w/o Seats", "Green Party w/ Seats"))
  
  # Plot the interaction
  ggplot2::ggplot(pred_data_econ, ggplot2::aes(x = centered_lagged_pervote_samlet, 
                                             y = predicted, 
                                             color = gp_status, 
                                             linetype = gp_status)) +
    ggplot2::geom_line() +
    ggplot2::facet_wrap(~ economy_status) +
    ggplot2::geom_vline(xintercept = 0, linetype = "dashed") +
    ggplot2::theme_minimal() +
    ggplot2::labs(
      title = "H3: Predicted Climate Position Based on Economic Conditions",
      x = "Green Party Vote Share (centered at threshold)",
      y = "Predicted Climate Position",
      color = "Green Party Status",
      linetype = "Green Party Status"
    )
}

# ============================================================================
# 5. Comparison Summary Tables
# ============================================================================

# Create tables to compare coefficients across different model specifications
if (requireNamespace("texreg", quietly = TRUE)) {
  library(texreg)
  
  # GDP Growth comparison
  htmlreg(list(h3_continuous_high_gdp, h3_continuous_low_gdp, 
              h3_median_rq_high_gdp, h3_median_rq_low_gdp,
              h3_robust_reg_high_gdp, h3_robust_reg_low_gdp),
         file = "h3_gdp_model_comparison.html",
         custom.model.names = c("OLS High GDP", "OLS Low GDP", 
                               "Median High GDP", "Median Low GDP", 
                               "Robust High GDP", "Robust Low GDP"),
         custom.coef.names = c("Intercept", "Vote Share", "Parliament", "Vote Share × Parliament"),
         caption = "Comparison of Different Modeling Approaches for H3 by GDP Growth")
  
  # Economic Condition comparison
  htmlreg(list(h3_continuous_good_econ, h3_continuous_bad_econ, 
              h3_median_rq_good_econ, h3_median_rq_bad_econ,
              h3_robust_reg_good_econ, h3_robust_reg_bad_econ),
         file = "h3_econ_model_comparison.html",
         custom.model.names = c("OLS Good Econ", "OLS Bad Econ", 
                               "Median Good Econ", "Median Bad Econ", 
                               "Robust Good Econ", "Robust Bad Econ"),
         custom.coef.names = c("Intercept", "Vote Share", "Parliament", "Vote Share × Parliament"),
         caption = "Comparison of Different Modeling Approaches for H3 by Economic Conditions")
}
```



## 3.2 H4: When green parties enter parliament, left-wing mainstream parties increase climate focus

```{r h4_analysis}
# ============================================================================
# 1. Basic Linear Models
# ============================================================================

# Simple linear model
h4_model_simple <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet + lagged_i_parlament,
                     data = final_dataset)
summary(h4_model_simple)

# Interaction model
h4_model_interaction <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                          data = final_dataset)
summary(h4_model_interaction)

# Interaction model with party ideology
h4_model_left_interaction <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament * left_party, 
                               data = final_dataset)
summary(h4_model_left_interaction)

# Clustered standard errors (by party)
if (exists("coeftest.cluster_grøn")) {
  data_used <- na.omit(final_dataset[, c("miljø_afhængig", "centered_lagged_pervote_samlet", 
                                      "lagged_i_parlament", "party", "edate", "country", "left_party")])
  
  h4_robust <- coeftest.cluster_grøn(
    data = data_used,
    fm = h4_model_interaction,
    cluster1 = data_used$party  # Pass the vector directly
  )
  print(h4_robust)
  
  # Double-clustered standard errors (by party and election date)
  h4_robust_double <- summary.cluster_grøn(
    obj = h4_model_interaction, 
    data = data_used, 
    cluster1 = "party", 
    cluster2 = "edate"
  )
  print(h4_robust_double)
  
  # Clustered SEs for ideology interaction model
  h4_ideology_robust <- coeftest.cluster_grøn(
    data = data_used,
    fm = h4_model_left_interaction,
    cluster1 = data_used$party
  )
  print(h4_ideology_robust)
}

# ============================================================================
# 2. Data Preparation for Subgroup Analysis
# ============================================================================

# Undersøg om effekten varierer baseret på partiideologi (H4)
# Opdel baseret på om partiet er venstre- eller højreorienteret
clean_data_right_party <- subset(clean_data, left_party == 0)
clean_data_left_party <- subset(clean_data, left_party == 1)

# ============================================================================
# 3. Two-Part Model for Party Ideology Subsets
# ============================================================================

# RIGHT PARTIES: Two-Part Model
# Part 1: Logit model for predicting non-zero climate focus
h4_binary_right <- glm(I(miljø_afhængig != 0) ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                     family = binomial, data = clean_data_right_party)
summary(h4_binary_right)

# Part 2: Linear model on non-zero values only
h4_continuous_right <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                        data = subset(clean_data_right_party, miljø_afhængig != 0))
summary(h4_continuous_right)

# LEFT PARTIES: Two-Part Model
# Part 1: Logit model for predicting non-zero climate focus
h4_binary_left <- glm(I(miljø_afhængig != 0) ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                    family = binomial, data = clean_data_left_party)
summary(h4_binary_left)

# Part 2: Linear model on non-zero values only
h4_continuous_left <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                       data = subset(clean_data_left_party, miljø_afhængig != 0))
summary(h4_continuous_left)

# ============================================================================
# 4. Quantile Regression for Party Ideology Subsets
# ============================================================================

# RIGHT PARTIES: Quantile Regression
# Median regression
h4_median_rq_right <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                       tau = 0.5, data = clean_data_right_party)
summary(h4_median_rq_right)

# Multiple quantiles
h4_multi_quantile_right <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                            tau = c(0.25, 0.5, 0.75), data = clean_data_right_party)
summary(h4_multi_quantile_right)

# Generate plot for coefficients across quantiles
h4_quantile_plot_right <- plot(summary(rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                                       tau = seq(0.1, 0.9, by = 0.1), data = clean_data_right_party)))

# LEFT PARTIES: Quantile Regression
# Median regression
h4_median_rq_left <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                      tau = 0.5, data = clean_data_left_party)
summary(h4_median_rq_left)

# Multiple quantiles
h4_multi_quantile_left <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                           tau = c(0.25, 0.5, 0.75), data = clean_data_left_party)
summary(h4_multi_quantile_left)

# Generate plot for coefficients across quantiles
h4_quantile_plot_left <- plot(summary(rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                                      tau = seq(0.1, 0.9, by = 0.1), data = clean_data_left_party)))

# Save quantile plots
pdf("h4_quantile_coefficients_right.pdf", width = 10, height = 8)
print(h4_quantile_plot_right)
dev.off()

pdf("h4_quantile_coefficients_left.pdf", width = 10, height = 8)
print(h4_quantile_plot_left)
dev.off()

# ============================================================================
# 5. Robust Regression for Party Ideology Subsets
# ============================================================================

# Robust regression for full sample with party ideology interaction
h4_robust_reg_ideology <- rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament * left_party, 
                           data = final_dataset, method = "MM")
summary(h4_robust_reg_ideology)

# RIGHT PARTIES: Robust Regression
h4_robust_reg_right <- rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                         data = clean_data_right_party, method = "MM")
summary(h4_robust_reg_right)

# LEFT PARTIES: Robust Regression
h4_robust_reg_left <- rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                        data = clean_data_left_party, method = "MM")
summary(h4_robust_reg_left)

# ============================================================================
# 6. RDD Analysis for Party Ideology Subsets
# ============================================================================

# Multi-polynomial RDD with custom function
if (exists("rd.base_grøn")) {
  # Multi-polynomial RDD with custom function
  rd.multic_h4 <- rd.base_grøn(
    data = final_dataset,
    force.var = 'centered_lagged_pervote_samlet',
    yvar = 'miljø_afhængig',
    seat.identifier = 'factor_lagged_i_parlament',
    fixed.effects = 'country',
    clust1 = 'party',
    clust2 = 'edate',
    polynomials = c(1, 2, 3, 4),
    bws = NULL
  )
  print(rd.multic_h4)
  
  # Right parties sample
  rd.multic_h4_right <- rd.base_grøn(
    data = clean_data_right_party,
    force.var = 'centered_lagged_pervote_samlet',
    yvar = 'miljø_afhængig',
    seat.identifier = 'factor_lagged_i_parlament',
    fixed.effects = 'country',
    clust1 = 'party',
    clust2 = 'edate',
    polynomials = c(1, 2, 3, 4),
    bws = NULL
  )
  print(rd.multic_h4_right)
  
  # Left parties sample
  rd.multic_h4_left <- rd.base_grøn(
    data = clean_data_left_party,
    force.var = 'centered_lagged_pervote_samlet',
    yvar = 'miljø_afhængig',
    seat.identifier = 'factor_lagged_i_parlament',
    fixed.effects = 'country',
    clust1 = 'party',
    clust2 = 'edate',
    polynomials = c(1, 2, 3, 4),
    bws = NULL
  )
  print(rd.multic_h4_left)
}

# Robustness analysis med forskellige båndbredder
covariates_to_use <- c("country", "edate")

# Kør robusthedsanalysen på alle data
results_df_h4 <- run_rdd_robustness(
  data = clean_data,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = c(1, 1.5, 2, 2.5, 3),
  polynomials = c(1, 2, 3, 4),
  covariates = covariates_to_use,
  group_label = "H4 - Fuld sample"
)

# Kør robusthedsanalysen for højreorienterede partier
results_df_h4_right <- run_rdd_robustness(
  data = clean_data_right_party,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = c(1, 1.5, 2, 2.5, 3),
  polynomials = c(1, 2),  # Begrænset til p=1,2 for at holde det enkelt
  covariates = covariates_to_use,
  group_label = "Højreorienterede partier"
)

# Kør robusthedsanalysen for venstreorienterede partier
results_df_h4_left <- run_rdd_robustness(
  data = clean_data_left_party,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = c(1, 1.5, 2, 2.5, 3),
  polynomials = c(1, 2),  # Begrænset til p=1,2 for at holde det enkelt
  covariates = covariates_to_use,
  group_label = "Venstreorienterede partier"
)

# Vis resultaterne
print(results_df_h4)

# Kombinér resultaterne for at sammenligne direkte
combined_results_ideology <- rbind(results_df_h4_right, results_df_h4_left)
print(combined_results_ideology)

# Vis kombinerede resultater i pæne tabeller
if (requireNamespace("knitr", quietly = TRUE)) {
  print(knitr::kable(results_df_h4, 
                    caption = "H4: Robusthedstest med forskellige båndbredder og polynomiegrader"))
  
  print(knitr::kable(combined_results_ideology, 
                    caption = "H4: Effekten opdelt efter partiideologi"))
}

# ============================================================================
# 7. Enhanced rdrobust Analysis for Party Ideology Subsets
# ============================================================================

# Standard RDD approach
h4_rdd <- rdrobust(
  y = clean_data$miljø_afhængig,
  x = clean_data$centered_lagged_pervote_samlet,
  c = 0,
  p = 1,  # linear polynomial
  kernel = "triangular",
  bwselect = "mserd"  # MSE-optimal bandwidth
)
summary(h4_rdd)

# Alternative RDD specifications
h4_rdd_alt <- rdrobust(
  y = clean_data$miljø_afhængig,
  x = clean_data$centered_lagged_pervote_samlet,
  c = 0,
  p = 2,  # quadratic polynomial
  kernel = "triangular",
  h = 2  # fixed bandwidth
)
summary(h4_rdd_alt)

# RIGHT PARTIES: Standard rdrobust (with error handling)
tryCatch({
  h4_rdd_right <- rdrobust(
    y = clean_data_right_party$miljø_afhængig,
    x = clean_data_right_party$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,
    kernel = "triangular",
    bwselect = "mserd"
  )
  summary(h4_rdd_right)
}, error = function(e) {
  cat("Standard rdrobust for right parties failed:", e$message, "\n")
  # Try with fixed bandwidth
  tryCatch({
    h4_rdd_right_fixed <- rdrobust(
      y = clean_data_right_party$miljø_afhængig,
      x = clean_data_right_party$centered_lagged_pervote_samlet,
      c = 0,
      p = 1,
      kernel = "triangular",
      h = 2  # fixed bandwidth
    )
    summary(h4_rdd_right_fixed)
  }, error = function(e2) {
    cat("Fixed bandwidth also failed for right parties:", e2$message, "\n")
  })
})

# LEFT PARTIES: Standard rdrobust (with error handling)
tryCatch({
  h4_rdd_left <- rdrobust(
    y = clean_data_left_party$miljø_afhængig,
    x = clean_data_left_party$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,
    kernel = "triangular",
    bwselect = "mserd"
  )
  summary(h4_rdd_left)
}, error = function(e) {
  cat("Standard rdrobust for left parties failed:", e$message, "\n")
  # Try with fixed bandwidth
  tryCatch({
    h4_rdd_left_fixed <- rdrobust(
      y = clean_data_left_party$miljø_afhængig,
      x = clean_data_left_party$centered_lagged_pervote_samlet,
      c = 0,
      p = 1,
      kernel = "triangular",
      h = 2  # fixed bandwidth
    )
    summary(h4_rdd_left_fixed)
  }, error = function(e2) {
    cat("Fixed bandwidth also failed for left parties:", e2$message, "\n")
  })
})

# ============================================================================
# 8. Separate Analysis for Zero and Non-Zero Values by Party Ideology
# ============================================================================

# RIGHT PARTIES: Split data into zero and non-zero values
zero_data_right <- subset(clean_data_right_party, miljø_afhængig == 0)
nonzero_data_right <- subset(clean_data_right_party, miljø_afhængig != 0)

# LEFT PARTIES: Split data into zero and non-zero values
zero_data_left <- subset(clean_data_left_party, miljø_afhængig == 0)
nonzero_data_left <- subset(clean_data_left_party, miljø_afhængig != 0)

# RDD for non-zero values only (RIGHT PARTIES)
tryCatch({
  h4_rdd_nonzero_right <- rdrobust(
    y = nonzero_data_right$miljø_afhængig,
    x = nonzero_data_right$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,
    kernel = "triangular",
    bwselect = "mserd"
  )
  summary(h4_rdd_nonzero_right)
}, error = function(e) {
  cat("RDD for non-zero values in right parties failed:", e$message, "\n")
  # Try with fixed bandwidth
  tryCatch({
    h4_rdd_nonzero_right_fixed <- rdrobust(
      y = nonzero_data_right$miljø_afhængig,
      x = nonzero_data_right$centered_lagged_pervote_samlet,
      c = 0,
      p = 1,
      kernel = "triangular",
      h = 2
    )
    summary(h4_rdd_nonzero_right_fixed)
  }, error = function(e2) {
    cat("Fixed bandwidth also failed:", e2$message, "\n")
  })
})

# RDD for non-zero values only (LEFT PARTIES)
tryCatch({
  h4_rdd_nonzero_left <- rdrobust(
    y = nonzero_data_left$miljø_afhængig,
    x = nonzero_data_left$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,
    kernel = "triangular",
    bwselect = "mserd"
  )
  summary(h4_rdd_nonzero_left)
}, error = function(e) {
  cat("RDD for non-zero values in left parties failed:", e$message, "\n")
  # Try with fixed bandwidth
  tryCatch({
    h4_rdd_nonzero_left_fixed <- rdrobust(
      y = nonzero_data_left$miljø_afhængig,
      x = nonzero_data_left$centered_lagged_pervote_samlet,
      c = 0,
      p = 1,
      kernel = "triangular",
      h = 2
    )
    summary(h4_rdd_nonzero_left_fixed)
  }, error = function(e2) {
    cat("Fixed bandwidth also failed:", e2$message, "\n")
  })
})

# ============================================================================
# 9. IV Estimation with Party Ideology Interaction
# ============================================================================

# IV estimation med interaktion med left_party
h4_iv <- ivreg(miljø_afhængig ~ lagged_i_parlament * left_party | 
               centered_lagged_pervote_samlet * left_party, 
              data = clean_data)
summary(h4_iv, diagnostics = TRUE)

# IV estimation for each subgroup
h4_iv_right <- ivreg(miljø_afhængig ~ lagged_i_parlament | centered_lagged_pervote_samlet, 
                    data = clean_data_right_party)
summary(h4_iv_right, diagnostics = TRUE)

h4_iv_left <- ivreg(miljø_afhængig ~ lagged_i_parlament | centered_lagged_pervote_samlet, 
                   data = clean_data_left_party)
summary(h4_iv_left, diagnostics = TRUE)

# ============================================================================
# 10. Visual Confirmation and RDD Plots
# ============================================================================

# Visual confirmation for full sample
h4_plot <- plot_rdd(
  data = clean_data,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position",
  title = "H4: Effect of Green Party Entry on Mainstream Climate Focus"
)
print(h4_plot)

# Plots for right parties
h4_plot_right <- plot_rdd(
  data = clean_data_right_party,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position",
  title = "H4: Effekt på højreorienterede partier"
)
print(h4_plot_right)

# Plots for left parties
h4_plot_left <- plot_rdd(
  data = clean_data_left_party,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position",
  title = "H4: Effekt på venstreorienterede partier"
)
print(h4_plot_left)

# Plots for non-zero values only - right parties
h4_plot_nonzero_right <- plot_rdd(
  data = nonzero_data_right,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position (Non-Zeros Only)",
  title = "H4: Effekt på højreorienterede partier (kun ikke-nul værdier)"
)
print(h4_plot_nonzero_right)

# Plots for non-zero values only - left parties
h4_plot_nonzero_left <- plot_rdd(
  data = nonzero_data_left,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position (Non-Zeros Only)",
  title = "H4: Effekt på venstreorienterede partier (kun ikke-nul værdier)"
)
print(h4_plot_nonzero_left)

# Kombiner plots hvis gridExtra er tilgængelig
if (requireNamespace("gridExtra", quietly = TRUE)) {
  # Partiideologi
  gridExtra::grid.arrange(h4_plot_right, h4_plot_left, ncol = 2,
                         top = "H4: Effekt opdelt efter partiideologi")
  
  # Partiideologi (kun ikke-nul værdier)
  gridExtra::grid.arrange(h4_plot_nonzero_right, h4_plot_nonzero_left, ncol = 2,
                         top = "H4: Effekt opdelt efter partiideologi (kun ikke-nul værdier)")
}

# ============================================================================
# 11. Visual Interaction Effects and Predictions
# ============================================================================

# Visuel sammenligning af interaktionseffekter
if (requireNamespace("ggplot2", quietly = TRUE) && requireNamespace("tidyr", quietly = TRUE)) {
  # Lav forudsigelser baseret på modellen
  pred_data <- expand.grid(
    left_party = c(0, 1),
    centered_lagged_pervote_samlet = seq(-5, 5, by = 0.5),
    lagged_i_parlament = c(0, 1)
  )
  
  pred_data$predicted <- predict(h4_model_left_interaction, newdata = pred_data)
  
  # Tilføj faktorer for pænere labels
  pred_data$ideology <- factor(pred_data$left_party, 
                             levels = c(0, 1),
                             labels = c("Højreorienteret parti", "Venstreorienteret parti"))
  
  pred_data$gp_status <- factor(pred_data$lagged_i_parlament,
                              levels = c(0, 1),
                              labels = c("Grønt parti uden sæde", "Grønt parti med sæde"))
  
  # Plot interaktionen
  ggplot2::ggplot(pred_data, ggplot2::aes(x = centered_lagged_pervote_samlet, 
                                         y = predicted, 
                                         color = gp_status, 
                                         linetype = gp_status)) +
    ggplot2::geom_line() +
    ggplot2::facet_wrap(~ ideology) +
    ggplot2::geom_vline(xintercept = 0, linetype = "dashed") +
    ggplot2::theme_minimal() +
    ggplot2::labs(
      title = "Forudsagt klimaposition baseret på H4 interaktionsmodel",
      x = "Grønt partis stemmeandel (centreret ved tærskel)",
      y = "Forudsagt klimaposition",
      color = "Grønt parti status",
      linetype = "Grønt parti status"
    )
}

# ============================================================================
# 12. Comparison Summary Tables
# ============================================================================

# Create tables to compare coefficients across different model specifications
if (requireNamespace("texreg", quietly = TRUE)) {
  library(texreg)
  
  # Party ideology comparison
  htmlreg(list(h4_continuous_right, h4_continuous_left, 
              h4_median_rq_right, h4_median_rq_left,
              h4_robust_reg_right, h4_robust_reg_left),
         file = "h4_ideology_model_comparison.html",
         custom.model.names = c("OLS Right", "OLS Left", 
                               "Median Right", "Median Left", 
                               "Robust Right", "Robust Left"),
         custom.coef.names = c("Intercept", "Vote Share", "Parliament", "Vote Share × Parliament"),
         caption = "Comparison of Different Modeling Approaches for H4 by Party Ideology")
}
```

## 3.3 H5: Larger mainstream parties respond less to green parties in parliament

```{r h5_analysis}
# ============================================================================
# H5 Analysis: Moderating Effect of Party Size
# ============================================================================

# Load necessary libraries (if not already loaded)
library(quantreg)    # For quantile regression
library(rdrobust)    # For robust RDD
library(MASS)        # For robust regression
library(lmtest)      # For coeftest
library(sandwich)    # For robust standard errors
library(dplyr)       # For data manipulation

# ============================================================================
# 1. Basic Linear Models
# ============================================================================

# Simple linear model for H5
h5_model_simple <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet + lagged_i_parlament + large_party,
                     data = final_dataset)
summary(h5_model_simple)

# Interaction model with binary party size
h5_model_interaction <- lm(miljø_afhængig ~ lagged_i_parlament * large_party + centered_lagged_pervote_samlet, 
                          data = final_dataset)
summary(h5_model_interaction)

# Full interaction model with binary party size
h5_model_full_interaction <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament * large_party, 
                               data = final_dataset)
summary(h5_model_full_interaction)

# Alternative specification with avg_pervote_main as continuous variable
h5_interaction_cont <- lm(
  miljø_afhængig ~ lagged_i_parlament * avg_pervote_main + centered_lagged_pervote_samlet,
  data = clean_data
)
summary(h5_interaction_cont)

# Three-way interaction with continuous party size
h5_triple <- lm(
  miljø_afhængig ~ lagged_i_parlament * avg_pervote_main * centered_lagged_pervote_samlet,
  data = clean_data
)
summary(h5_triple)

# Clustered standard errors (by party)
if (exists("coeftest.cluster_grøn")) {
  data_used <- na.omit(final_dataset[, c("miljø_afhængig", "centered_lagged_pervote_samlet", 
                                      "lagged_i_parlament", "large_party", "party", "edate", "country")])
  
  h5_robust <- coeftest.cluster_grøn(
    data = data_used,
    fm = h5_model_interaction,
    cluster1 = data_used$party  # Pass the vector directly
  )
  print(h5_robust)
  
  # Double-clustered standard errors (by party and election date)
  h5_robust_double <- summary.cluster_grøn(
    obj = h5_model_interaction, 
    data = data_used, 
    cluster1 = "party", 
    cluster2 = "edate"
  )
  print(h5_robust_double)
  
  # For the full interaction model
  h5_full_robust <- coeftest.cluster_grøn(
    data = data_used,
    fm = h5_model_full_interaction,
    cluster1 = data_used$party
  )
  print(h5_full_robust)
  
  # For the continuous specification
  data_used_cont <- na.omit(clean_data[, c("miljø_afhængig", "centered_lagged_pervote_samlet", 
                                     "lagged_i_parlament", "avg_pervote_main", "party", "edate", "country")])
  
  h5_robust_cont <- coeftest.cluster_grøn(
    data = data_used_cont,
    fm = h5_interaction_cont,
    cluster1 = data_used_cont$party
  )
  print(h5_robust_cont)
}

# ============================================================================
# 2. Data Preparation for Subgroup Analysis
# ============================================================================

# Split data based on party size
large_parties <- subset(clean_data, large_party == 1)
small_parties <- subset(clean_data, large_party == 0)

# ============================================================================
# 3. Two-Part Model for Party Size Subsets
# ============================================================================

# LARGE PARTIES: Two-Part Model
# Part 1: Logit model for predicting non-zero climate focus
h5_binary_large <- glm(I(miljø_afhængig != 0) ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                     family = binomial, data = large_parties)
summary(h5_binary_large)

# Part 2: Linear model on non-zero values only
h5_continuous_large <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                        data = subset(large_parties, miljø_afhængig != 0))
summary(h5_continuous_large)

# SMALL PARTIES: Two-Part Model
# Part 1: Logit model for predicting non-zero climate focus
h5_binary_small <- glm(I(miljø_afhængig != 0) ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                    family = binomial, data = small_parties)
summary(h5_binary_small)

# Part 2: Linear model on non-zero values only
h5_continuous_small <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                       data = subset(small_parties, miljø_afhængig != 0))
summary(h5_continuous_small)

# ============================================================================
# 4. Quantile Regression for Party Size Subsets
# ============================================================================

# LARGE PARTIES: Quantile Regression
# Median regression
h5_median_rq_large <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                       tau = 0.5, data = large_parties)
summary(h5_median_rq_large)

# Multiple quantiles
h5_multi_quantile_large <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                            tau = c(0.25, 0.5, 0.75), data = large_parties)
summary(h5_multi_quantile_large)

# Generate plot for coefficients across quantiles
h5_quantile_plot_large <- plot(summary(rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                                       tau = seq(0.1, 0.9, by = 0.1), data = large_parties)))

# SMALL PARTIES: Quantile Regression
# Median regression
h5_median_rq_small <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                      tau = 0.5, data = small_parties)
summary(h5_median_rq_small)

# Multiple quantiles
h5_multi_quantile_small <- rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                           tau = c(0.25, 0.5, 0.75), data = small_parties)
summary(h5_multi_quantile_small)

# Generate plot for coefficients across quantiles
h5_quantile_plot_small <- plot(summary(rq(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                                      tau = seq(0.1, 0.9, by = 0.1), data = small_parties)))

# Save quantile plots
pdf("h5_quantile_coefficients_large.pdf", width = 10, height = 8)
print(h5_quantile_plot_large)
dev.off()

pdf("h5_quantile_coefficients_small.pdf", width = 10, height = 8)
print(h5_quantile_plot_small)
dev.off()

# ============================================================================
# 5. Robust Regression for Party Size Subsets
# ============================================================================

# Robust regression for full sample with party size interaction
h5_robust_reg_size <- rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament * large_party, 
                       data = final_dataset, method = "MM")
summary(h5_robust_reg_size)

# Robust regression with continuous party size
h5_robust_reg_cont <- rlm(miljø_afhængig ~ lagged_i_parlament * avg_pervote_main * centered_lagged_pervote_samlet, 
                        data = clean_data, method = "MM")
summary(h5_robust_reg_cont)

# LARGE PARTIES: Robust Regression
h5_robust_reg_large <- rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                         data = large_parties, method = "MM")
summary(h5_robust_reg_large)

# SMALL PARTIES: Robust Regression
h5_robust_reg_small <- rlm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament, 
                        data = small_parties, method = "MM")
summary(h5_robust_reg_small)

# ============================================================================
# 6. RDD Analysis for Party Size Subsets
# ============================================================================

# Robustness analysis with different bandwidths
covariates_to_use <- c("country", "edate")

# Run the robustness analysis for large parties
results_df_h5_large <- run_rdd_robustness(
  data = large_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = c(1, 1.5, 2, 2.5, 3),
  polynomials = c(1, 2, 3, 4),
  covariates = covariates_to_use,
  group_label = "Store partier"
)

# Run the robustness analysis for small parties
results_df_h5_small <- run_rdd_robustness(
  data = small_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = c(1, 1.5, 2, 2.5, 3),
  polynomials = c(1, 2, 3, 4),
  covariates = covariates_to_use,
  group_label = "Små partier"
)

# Combine results for direct comparison
combined_results_size <- rbind(results_df_h5_large, results_df_h5_small)
print(combined_results_size)

# Display results in a nice table
if (requireNamespace("knitr", quietly = TRUE)) {
  print(knitr::kable(combined_results_size, 
                    caption = "H5: Robusthedstest med forskellige båndbredder opdelt efter partistørrelse"))
}

# ============================================================================
# 7. Enhanced rdrobust Analysis for Party Size Subsets
# ============================================================================

# LARGE PARTIES: Standard rdrobust (with error handling)
tryCatch({
  h5_large_rdd <- rdrobust(
    y = large_parties$miljø_afhængig,
    x = large_parties$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,
    kernel = "triangular",
    bwselect = "mserd"
  )
  summary(h5_large_rdd)
}, error = function(e) {
  cat("Standard rdrobust for large parties failed:", e$message, "\n")
  # Try with fixed bandwidth
  tryCatch({
    h5_large_rdd_fixed <- rdrobust(
      y = large_parties$miljø_afhængig,
      x = large_parties$centered_lagged_pervote_samlet,
      c = 0,
      p = 1,
      kernel = "triangular",
      h = 2  # fixed bandwidth
    )
    summary(h5_large_rdd_fixed)
  }, error = function(e2) {
    cat("Fixed bandwidth also failed for large parties:", e2$message, "\n")
  })
})

# SMALL PARTIES: Standard rdrobust (with error handling)
tryCatch({
  h5_small_rdd <- rdrobust(
    y = small_parties$miljø_afhængig,
    x = small_parties$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,
    kernel = "triangular",
    bwselect = "mserd"
  )
  summary(h5_small_rdd)
}, error = function(e) {
  cat("Standard rdrobust for small parties failed:", e$message, "\n")
  # Try with fixed bandwidth
  tryCatch({
    h5_small_rdd_fixed <- rdrobust(
      y = small_parties$miljø_afhængig,
      x = small_parties$centered_lagged_pervote_samlet,
      c = 0,
      p = 1,
      kernel = "triangular",
      h = 2  # fixed bandwidth
    )
    summary(h5_small_rdd_fixed)
  }, error = function(e2) {
    cat("Fixed bandwidth also failed for small parties:", e2$message, "\n")
  })
})

# Alternative specifications with fixed bandwidth (if previous attempts succeeded)
tryCatch({
  h5_large_rdd_alt <- rdrobust(
    y = large_parties$miljø_afhængig,
    x = large_parties$centered_lagged_pervote_samlet,
    c = 0,
    p = 2,  # quadratic polynomial
    kernel = "triangular",
    h = 2  # fixed bandwidth
  )
  summary(h5_large_rdd_alt)
}, error = function(e) {
  cat("Alternative specification for large parties failed:", e$message, "\n")
})

tryCatch({
  h5_small_rdd_alt <- rdrobust(
    y = small_parties$miljø_afhængig,
    x = small_parties$centered_lagged_pervote_samlet,
    c = 0,
    p = 2,  # quadratic polynomial
    kernel = "triangular",
    h = 2  # fixed bandwidth
  )
  summary(h5_small_rdd_alt)
}, error = function(e) {
  cat("Alternative specification for small parties failed:", e$message, "\n")
})

# ============================================================================
# 8. Separate Analysis for Zero and Non-Zero Values by Party Size
# ============================================================================

# LARGE PARTIES: Split data into zero and non-zero values
zero_data_large <- subset(large_parties, miljø_afhængig == 0)
nonzero_data_large <- subset(large_parties, miljø_afhængig != 0)

# SMALL PARTIES: Split data into zero and non-zero values
zero_data_small <- subset(small_parties, miljø_afhængig == 0)
nonzero_data_small <- subset(small_parties, miljø_afhængig != 0)

# RDD for non-zero values only (LARGE PARTIES)
tryCatch({
  h5_rdd_nonzero_large <- rdrobust(
    y = nonzero_data_large$miljø_afhængig,
    x = nonzero_data_large$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,
    kernel = "triangular",
    bwselect = "mserd"
  )
  summary(h5_rdd_nonzero_large)
}, error = function(e) {
  cat("RDD for non-zero values in large parties failed:", e$message, "\n")
  # Try with fixed bandwidth
  tryCatch({
    h5_rdd_nonzero_large_fixed <- rdrobust(
      y = nonzero_data_large$miljø_afhængig,
      x = nonzero_data_large$centered_lagged_pervote_samlet,
      c = 0,
      p = 1,
      kernel = "triangular",
      h = 2
    )
    summary(h5_rdd_nonzero_large_fixed)
  }, error = function(e2) {
    cat("Fixed bandwidth also failed:", e2$message, "\n")
  })
})

# RDD for non-zero values only (SMALL PARTIES)
tryCatch({
  h5_rdd_nonzero_small <- rdrobust(
    y = nonzero_data_small$miljø_afhængig,
    x = nonzero_data_small$centered_lagged_pervote_samlet,
    c = 0,
    p = 1,
    kernel = "triangular",
    bwselect = "mserd"
  )
  summary(h5_rdd_nonzero_small)
}, error = function(e) {
  cat("RDD for non-zero values in small parties failed:", e$message, "\n")
  # Try with fixed bandwidth
  tryCatch({
    h5_rdd_nonzero_small_fixed <- rdrobust(
      y = nonzero_data_small$miljø_afhængig,
      x = nonzero_data_small$centered_lagged_pervote_samlet,
      c = 0,
      p = 1,
      kernel = "triangular",
      h = 2
    )
    summary(h5_rdd_nonzero_small_fixed)
  }, error = function(e2) {
    cat("Fixed bandwidth also failed:", e2$message, "\n")
  })
})

# ============================================================================
# 9. IV Estimation for Party Size Subsets
# ============================================================================

# IV estimation split by party size
h5_large_iv <- ivreg(miljø_afhængig ~ lagged_i_parlament | centered_lagged_pervote_samlet, 
              data = large_parties)
summary(h5_large_iv, diagnostics = TRUE)

h5_small_iv <- ivreg(miljø_afhængig ~ lagged_i_parlament | centered_lagged_pervote_samlet, 
              data = small_parties)
summary(h5_small_iv, diagnostics = TRUE)

# IV estimation with interaction for full sample
h5_iv_interact <- ivreg(miljø_afhængig ~ lagged_i_parlament * large_party | 
                       centered_lagged_pervote_samlet * large_party, 
                      data = clean_data)
summary(h5_iv_interact, diagnostics = TRUE)

# IV with continuous party size
h5_iv_cont <- ivreg(miljø_afhængig ~ lagged_i_parlament * avg_pervote_main | 
                   centered_lagged_pervote_samlet * avg_pervote_main, 
                  data = clean_data)
summary(h5_iv_cont, diagnostics = TRUE)

# ============================================================================
# 10. Visual Confirmation and RDD Plots
# ============================================================================

# Visual confirmation for large parties
h5_large_plot <- plot_rdd(
  data = large_parties,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position",
  title = "H5: Effect on Large Mainstream Parties"
)
print(h5_large_plot)

# Visual confirmation for small parties
h5_small_plot <- plot_rdd(
  data = small_parties,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position",
  title = "H5: Effect on Small Mainstream Parties"
)
print(h5_small_plot)

# Plots for non-zero values only - large parties
h5_plot_nonzero_large <- plot_rdd(
  data = nonzero_data_large,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position (Non-Zeros Only)",
  title = "H5: Effect on Large Parties (Non-Zero Values Only)"
)
print(h5_plot_nonzero_large)

# Plots for non-zero values only - small parties
h5_plot_nonzero_small <- plot_rdd(
  data = nonzero_data_small,
  x_var = "centered_lagged_pervote_samlet",
  y_var = "miljø_afhængig",
  group_var = "factor_lagged_i_parlament",
  x_limit = 10,
  x_label = "Green Party Vote Share (centered)",
  y_label = "Climate Position (Non-Zeros Only)",
  title = "H5: Effect on Small Parties (Non-Zero Values Only)"
)
print(h5_plot_nonzero_small)

# Combine plots if gridExtra is available
if (requireNamespace("gridExtra", quietly = TRUE)) {
  # Party size
  gridExtra::grid.arrange(h5_large_plot, h5_small_plot, ncol = 2,
                         top = "H5: Effekt opdelt efter partistørrelse")
  
  # Party size (non-zero values only)
  gridExtra::grid.arrange(h5_plot_nonzero_large, h5_plot_nonzero_small, ncol = 2,
                         top = "H5: Effekt opdelt efter partistørrelse (kun ikke-nul værdier)")
}

# ============================================================================
# 11. Advanced Visualizations with Continuous Party Size
# ============================================================================

# Advanced visualization with continuous party size
if (requireNamespace("ggplot2", quietly = TRUE)) {
  # Interaction plot with continuous party size
  ggplot2::ggplot(clean_data, ggplot2::aes(x = centered_lagged_pervote_samlet, 
                                         y = miljø_afhængig)) +
    ggplot2::geom_point(ggplot2::aes(color = factor_lagged_i_parlament, 
                                   size = avg_pervote_main), 
                       alpha = 0.5) +
    ggplot2::geom_smooth(data = subset(clean_data, centered_lagged_pervote_samlet < 0),
                       method = "lm", formula = y ~ x, se = TRUE) +
    ggplot2::geom_smooth(data = subset(clean_data, centered_lagged_pervote_samlet >= 0),
                       method = "lm", formula = y ~ x, se = TRUE) +
    ggplot2::geom_vline(xintercept = 0, linetype = "dashed", color = "red") +
    ggplot2::labs(title = "Climate Position by Green Party Vote Share and Mainstream Party Size",
                x = "Green Party Vote Share (centered)",
                y = "Climate Position",
                color = "Green Party in Parliament",
                size = "Mainstream Party Size") +
    ggplot2::theme_minimal()
    
  # Visual comparison of interaction effects
  # Make predictions based on the model with continuous party size
  pred_data <- expand.grid(
    avg_pervote_main = c(10, 20, 30),  # Small, medium and large parties
    centered_lagged_pervote_samlet = seq(-5, 5, by = 0.5),
    lagged_i_parlament = c(0, 1)
  )
  
  pred_data$predicted <- predict(h5_interaction_cont, newdata = pred_data)
  
  # Add factors for nicer labels
  pred_data$party_size <- factor(pred_data$avg_pervote_main, 
                              levels = c(10, 20, 30),
                              labels = c("Lille parti (10%)", 
                                        "Mellemstort parti (20%)", 
                                        "Stort parti (30%)"))
  
  pred_data$gp_status <- factor(pred_data$lagged_i_parlament,
                              levels = c(0, 1),
                              labels = c("Grønt parti uden sæde", 
                                        "Grønt parti med sæde"))
  
  # Plot the interaction
  ggplot2::ggplot(pred_data, ggplot2::aes(x = centered_lagged_pervote_samlet, 
                                         y = predicted, 
                                         color = gp_status, 
                                         linetype = gp_status)) +
    ggplot2::geom_line() +
    ggplot2::facet_wrap(~ party_size) +
    ggplot2::geom_vline(xintercept = 0, linetype = "dashed") +
    ggplot2::theme_minimal() +
    ggplot2::labs(
      title = "Forudsagt klimaposition baseret på H5 interaktionsmodel",
      x = "Grønt partis stemmeandel (centreret ved tærskel)",
      y = "Forudsagt klimaposition",
      color = "Grønt parti status",
      linetype = "Grønt parti status"
    )
}

# ============================================================================
# 12. Comparison Summary Tables
# ============================================================================

# Create tables to compare coefficients across different model specifications
if (requireNamespace("texreg", quietly = TRUE)) {
  library(texreg)
  
  # Party size comparison
  htmlreg(list(h5_continuous_large, h5_continuous_small, 
              h5_median_rq_large, h5_median_rq_small,
              h5_robust_reg_large, h5_robust_reg_small),
         file = "h5_size_model_comparison.html",
         custom.model.names = c("OLS Large", "OLS Small", 
                               "Median Large", "Median Small", 
                               "Robust Large", "Robust Small"),
         custom.coef.names = c("Intercept", "Vote Share", "Parliament", "Vote Share × Parliament"),
         caption = "Comparison of Different Modeling Approaches for H5 by Party Size")
  
  # Comparison of binary versus continuous party size specifications
  htmlreg(list(h5_model_interaction, h5_interaction_cont, 
              h5_model_full_interaction, h5_triple),
         file = "h5_binary_continuous_comparison.html",
         custom.model.names = c("Binary Size", "Continuous Size", 
                               "Full Binary", "Full Continuous"),
         caption = "Comparison of Binary versus Continuous Party Size Specifications")
}
```


```{r Implementation af coefficient stability plots og placebo-tests}
source("coefficient_stability_plots.R")  
source("placebo_tests.R") 

# Definer nye funktioner for zero-inflation og kvantil regression
# Funktion til at visualisere two-part model resultater
create_two_part_model_visualization <- function(data, outcome_var, running_var, treatment_var, polynomial, bandwidth, covariates) {
  # Del 1: Sandsynlighed for ikke-nul værdier
  binary_formula <- as.formula(paste0("I(", outcome_var, " != 0) ~ ", 
                                     running_var, " * ", treatment_var, " + ", 
                                     paste0(covariates, collapse = " + ")))
  binary_model <- glm(binary_formula, family = binomial, data = data)
  
  # Del 2: Model for ikke-nul værdier
  nonzero_data <- subset(data, data[[outcome_var]] != 0)
  continuous_formula <- as.formula(paste0(outcome_var, " ~ ", 
                                        running_var, " * ", treatment_var, " + ", 
                                        paste0(covariates, collapse = " + ")))
  continuous_model <- lm(continuous_formula, data = nonzero_data)
  
  # Generer prædiktioner for visualisering
  pred_data <- expand.grid(
    temp_running = seq(min(data[[running_var]]), max(data[[running_var]]), length.out = 100),
    temp_treatment = c(0, 1)
  )
  names(pred_data) <- c(running_var, treatment_var)
  
  # Tilføj kovariater med gennemsnitsværdier
  for (cov in covariates) {
    if (is.factor(data[[cov]]) || is.character(data[[cov]])) {
      # For kategoriske variable, brug den hyppigste værdi
      pred_data[[cov]] <- names(sort(table(data[[cov]]), decreasing = TRUE)[1])
    } else {
      # For numeriske variable, brug gennemsnit
      pred_data[[cov]] <- mean(data[[cov]], na.rm = TRUE)
    }
  }
  
  # Beregn prædikterede værdier
  pred_data$binary_pred <- predict(binary_model, newdata = pred_data, type = "response")
  
  # For continuous_model, skal vi håndtere at det kun er for ikke-nul værdier
  # Vi bruger en dummy værdi for kontinuert model prædiktioner
  pred_data$continuous_pred <- 0
  try({
    pred_data$continuous_pred <- predict(continuous_model, newdata = pred_data)
  }, silent = TRUE)
  
  # Beregn samlet effekt (sandsynlighed for ikke-nul * værdi givet ikke-nul)
  pred_data$combined_effect <- pred_data$binary_pred * pred_data$continuous_pred
  
  # Forbered data til plot
  pred_data$treatment_label <- factor(pred_data[[treatment_var]], 
                                    levels = c(0, 1), 
                                    labels = c("Uden behandling", "Med behandling"))
  
  # Lav plot
  library(ggplot2)
  p1 <- ggplot(pred_data, aes(x = .data[[running_var]], y = binary_pred, color = treatment_label)) +
    geom_line() +
    geom_vline(xintercept = 0, linetype = "dashed") +
    labs(title = "Sandsynlighed for ikke-nul klimaposition",
         x = paste0(running_var, " (centreret)"),
         y = "Sandsynlighed",
         color = "Behandlingsstatus") +
    theme_minimal()
  
  p2 <- ggplot(pred_data, aes(x = .data[[running_var]], y = continuous_pred, color = treatment_label)) +
    geom_line() +
    geom_vline(xintercept = 0, linetype = "dashed") +
    labs(title = "Værdi af klimaposition givet ikke-nul",
         x = paste0(running_var, " (centreret)"),
         y = "Værdi",
         color = "Behandlingsstatus") +
    theme_minimal()
  
  p3 <- ggplot(pred_data, aes(x = .data[[running_var]], y = combined_effect, color = treatment_label)) +
    geom_line() +
    geom_vline(xintercept = 0, linetype = "dashed") +
    labs(title = "Samlet effekt: Sandsynlighed * Værdi",
         x = paste0(running_var, " (centreret)"),
         y = "Forventet værdi",
         color = "Behandlingsstatus") +
    theme_minimal()
  
  # Kombiner plots
  if (requireNamespace("gridExtra", quietly = TRUE)) {
    combined_plot <- gridExtra::grid.arrange(p1, p2, p3, ncol = 1,
                                           top = "Two-part model resultater")
    return(combined_plot)
  } else {
    # Returner det vigtigste plot hvis gridExtra ikke er tilgængelig
    return(p3)
  }
}

# Funktion til at visualisere kvantil regressionseffekter
create_quantile_effect_plot <- function(data, outcome_var, running_var, treatment_var, quantiles, covariates, title) {
  library(quantreg)
  library(ggplot2)
  
  # Forbered resultater
  results <- data.frame(
    Quantile = numeric(),
    Estimate = numeric(),
    StdError = numeric(),
    Lower = numeric(),
    Upper = numeric()
  )
  
  # Kør kvantil regression for hver kvantil
  for (q in quantiles) {
    formula_str <- paste0(outcome_var, " ~ ", running_var, " * ", treatment_var)
    if (length(covariates) > 0) {
      formula_str <- paste0(formula_str, " + ", paste0(covariates, collapse = " + "))
    }
    
    rq_model <- rq(as.formula(formula_str), tau = q, data = data)
    coef_summary <- summary(rq_model)
    
    # Få koefficienten for treatment
    coef_idx <- which(rownames(coef_summary$coefficients) == treatment_var)
    if (length(coef_idx) > 0) {
      estimate <- coef_summary$coefficients[coef_idx, 1]
      std_error <- coef_summary$coefficients[coef_idx, 2]
      
      # Beregn konfidensinterval
      lower <- estimate - 1.96 * std_error
      upper <- estimate + 1.96 * std_error
      
      results <- rbind(results, data.frame(
        Quantile = q,
        Estimate = estimate,
        StdError = std_error,
        Lower = lower,
        Upper = upper
      ))
    }
  }
  
  # Lav plot
  p <- ggplot(results, aes(x = Quantile, y = Estimate)) +
    geom_line() +
    geom_ribbon(aes(ymin = Lower, ymax = Upper), alpha = 0.2) +
    geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
    labs(title = title,
         x = "Kvantil",
         y = "Estimeret effekt af behandling") +
    theme_minimal()
  
  return(p)
}

# 1. Coefficient Stability Plots

## 1.1 For H1 (hovedmodellen)
h1_stability_plot <- create_coefficient_stability_plot(
  data = clean_data,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomials = c(1, 2, 3),
  covariates = c("country", "edate"),
  title = "H1: Når grønne partier kommer ind i parlamentet, falder klimafokus"
)

# Gem plottet
ggsave("h1_plot.png", plot = h1_stability_plot$plot, width = 10, height = 6, dpi = 300)

## 1.2 For H2 (RRP effekt) opdelt efter RRP status
# Opdel data baseret på RRP status
data_no_rrp <- subset(clean_data, rrp_i_p_lag1 == 0)
data_with_rrp <- subset(clean_data, rrp_i_p_lag1 == 1)

# Sammenlign de to modeller
h2_comparison_plot <- compare_coefficient_stability(
  data_list = list(data_no_rrp, data_with_rrp),
  labels = c("Ingen højreradikale partier", "Højreradikale partier i parlament"),
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomial = 1,  # Lineær model for sammenligning
  covariates = c("country", "edate"),
  title = "H2: Effekt af grønne partier modereret af højreradikale partier"
)

# Gem plottet
ggsave("h2_comparison_plot.png", plot = h2_comparison_plot, width = 10, height = 6, dpi = 300)

## 1.3 For H3 (økonomiske betingelser)
# H3 implementeringen har to varianter:
# 1. BNP-vækst som moderator
# 2. Sammensat økonomisk indikator som moderator

# Opdel data baseret på BNP-vækst
high_gdp_stability_plot <- create_coefficient_stability_plot(
  data = clean_data_high_gdp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomials = c(1, 2, 3),
  covariates = c("country", "edate"),
  title = "H3: Effekt ved høj BNP-vækst"
)

low_gdp_stability_plot <- create_coefficient_stability_plot(
  data = clean_data_low_gdp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomials = c(1, 2, 3),
  covariates = c("country", "edate"),
  title = "H3: Effekt ved lav BNP-vækst"
)

# Gem plottene
pdf("h3_high_gdp_stability.pdf", width = 10, height = 6)
print(high_gdp_stability_plot)
dev.off()

pdf("h3_low_gdp_stability.pdf", width = 10, height = 6)
print(low_gdp_stability_plot)
dev.off()
## 1.2 Sammensat økonomisk indikator
good_economy_stability_plot <- create_coefficient_stability_plot(
  data = clean_data_good_economy,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomials = c(1, 2, 3),
  covariates = c("country", "edate"),
  title = "H3: Effekt under gode økonomiske forhold"
)

bad_economy_stability_plot <- create_coefficient_stability_plot(
  data = clean_data_bad_economy,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomials = c(1, 2, 3),
  covariates = c("country", "edate"),
  title = "H3: Effekt under dårlige økonomiske forhold"
)

# Gem plottene
pdf("h3_good_economy_stability.pdf", width = 10, height = 6)
print(good_economy_stability_plot)
dev.off()

pdf("h3_bad_economy_stability.pdf", width = 10, height = 6)
print(bad_economy_stability_plot)
dev.off()

## 1.4 For H4 (partiideologi)
# Opdel data baseret på partiideologi
left_parties <- subset(clean_data, left_party == 1)
right_parties <- subset(clean_data, left_party == 0)

h4_comparison_plot <- compare_coefficient_stability(
  data_list = list(left_parties, right_parties),
  labels = c("Venstreorienterede partier", "Højreorienterede partier"),
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomial = 1,
  covariates = c("country", "edate"),
  title = "H4: Effekt af grønne partier opdelt efter partiideologi"
)

# Gem plottet
ggsave("h4_comparison_plot.png", plot = h4_comparison_plot, width = 10, height = 6, dpi = 300)

## 1.4 For H5 (partistørrelse)
# Opdel data baseret på partistørrelse
large_parties <- subset(clean_data, large_party == 1)
small_parties <- subset(clean_data, large_party == 0)

h5_comparison_plot <- compare_coefficient_stability(
  data_list = list(large_parties, small_parties),
  labels = c("Store partier", "Små partier"),
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomial = 1,
  covariates = c("country", "edate"),
  title = "H5: Effekt af grønne partier opdelt efter partistørrelse"
)

# Gem plottet
ggsave("h5_comparison_plot.png",plot = h5_comparison_plot, width = 10, height = 6, dpi = 300)

## 1.5 Dot-whisker plot for alle modeller
# Lav en kompakt sammenligning af alle modeller
all_models_dot_whisker <- create_dotwhisker_plot(
  data_list = list(
    clean_data,
    left_parties,
    right_parties,
    large_parties,
    small_parties,
    data_no_rrp,
    data_with_rrp,
    clean_data_high_gdp,
    clean_data_low_gdp,
    clean_data_good_economy,
    clean_data_bad_economy   
  ),
  labels = c(
    "Fuld sample",
    "Venstreorienterede",
    "Højreorienterede",
    "Store partier",
    "Små partier",
    "Uden højreradikale",
    "Med højreradikale",
    "Høj BNP-vækst",        
    "Lav BNP-vækst",         
    "God økonomi (indeks)",   
    "Dårlig økonomi (indeks)" 
  ),
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_values = c(1, 2, 3),
  polynomial = 1,
  covariates = c("country", "edate"),
  title = "Sammenligning af effekter på tværs af alle modeller og moderatorer"
)

# Gem plottet
ggsave("all_models_dot_whisker.png", plot = all_models_dot_whisker, width = 12, height = 8, dpi = 300)

## 1.6 Kvantil regression effektplot
# NY TILFØJELSE: Visualiser heterogene effekter på tværs af kvantiler
quantile_effect_plot <- create_quantile_effect_plot(
  data = clean_data,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  quantiles = seq(0.1, 0.9, by = 0.1),
  covariates = c("country", "edate"),
  title = "Heterogene effekter på tværs af kvantiler i fordelingen"
)

# Gem plottet
ggsave("h1_quantile_effects.png", plot = quantile_effect_plot, width = 10, height = 6, dpi = 300)

# 2. Placebo Tests

## 2.1 Placebo-tærskel test for H1 (hovedmodellen)
h1_placebo_threshold <- run_placebo_threshold_test(
  data = clean_data,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  true_cutpoint = 0,
  placebo_range = c(-4, 4),
  placebo_step = 0.5,
  polynomial = 1,
  bandwidth = 2,  # Fast båndbredde for konsistens
  covariates = c("country", "edate")
)

# Plot resultaterne
h1_placebo_plot <- plot_placebo_threshold_test(
  h1_placebo_threshold,
  title = "H1: Placebo-tærskel test for hovedmodellen"
)

# Gem plottet
ggsave("h1_placebo_plot.png", plot = h1_placebo_plot, width = 10, height = 6, dpi = 300)

## 2.2 Outcome placebo test for H1
# Vælg placebo variables som ikke burde påvirkes af grønne partiers indtrædelse
# For eksempel: andre politiske positioner eller non-relaterede manifesto-kategorier
placebo_vars <- c("rile_lowe")  # Erstatter med relevante placebo variables

# Kør outcome placebo test
h1_outcome_placebo <- run_outcome_placebo_test(
  data = clean_data,
  real_outcome_var = "miljø_afhængig",
  placebo_outcome_vars = placebo_vars,
  running_var = "centered_lagged_pervote_samlet",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

# Plot resultaterne
h1_outcome_placebo_plot <- plot_outcome_placebo_test(
  h1_outcome_placebo,
  title = "H1: Outcome placebo test"
)

# Gem plottet
ggsave("h1_outcome_placebo_plot.png", plot = h1_outcome_placebo_plot, width = 10, height = 6, dpi = 300)

## 2.3 Permutationstest for H1
h1_permutation <- run_permutation_test(
  data = clean_data,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  n_permutations = 500,  # Antal permutationer (kan øges for mere præcision)
  covariates = c("country", "edate")
)

# Plot resultaterne
h1_permutation_plot <- plot_permutation_test(
  h1_permutation,
  title = "H1: Permutationstest"
)

# Gem plottet
ggsave("h1_permutation_plot.png", plot = h1_permutation_plot, width = 10, height = 6, dpi = 300)

## 2.4 Visualisering af two-part model resultater
# NY TILFØJELSE: Visualisering af two-part model
two_part_plot <- create_two_part_model_visualization(
  data = clean_data,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

# Gem plottet
ggsave("h1_two_part_model.png", plot = two_part_plot, width = 10, height = 8, dpi = 300)

# 3. For inclusion in appendix - Coefficient stability plots for all hypotheses
# Generér individuelle coefficient stability plots for hver model som skal i appendix

## 3.1 H2 individuelle plots
h2_no_rrp_plot <- create_coefficient_stability_plot(
  data = data_no_rrp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomials = c(1, 2, 3),
  covariates = c("country", "edate"),
  title = "H2: Ingen højreradikale partier"
)

h2_with_rrp_plot <- create_coefficient_stability_plot(
  data = data_with_rrp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomials = c(1, 2, 3),
  covariates = c("country", "edate"),
  title = "H2: Med højreradikale partier"
)

# Gem plottene
# For h2_no_rrp_plot
pdf("h2_no_rrp_plot.pdf", width = 10, height = 6)
print(h2_no_rrp_plot)
dev.off()

# For h2_with_rrp_plot
pdf("h2_with_rrp_plot.pdf", width = 10, height = 6)
print(h2_with_rrp_plot)
dev.off()

## 3.2 Placebo-tærskel tests (bnp-vækst)
# Høj BNP-vækst
h3_high_gdp_placebo <- run_placebo_threshold_test(
  data = clean_data_high_gdp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  true_cutpoint = 0,
  placebo_range = c(-4, 4),
  placebo_step = 0.5,
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

h3_high_gdp_placebo_plot <- plot_placebo_threshold_test(
  h3_high_gdp_placebo,
  title = "H3: Placebo test (høj BNP-vækst)"
)

# Lav BNP-vækst
h3_low_gdp_placebo <- run_placebo_threshold_test(
  data = clean_data_low_gdp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  true_cutpoint = 0,
  placebo_range = c(-4, 4),
  placebo_step = 0.5,
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

h3_low_gdp_placebo_plot <- plot_placebo_threshold_test(
  h3_low_gdp_placebo,
  title = "H3: Placebo test (lav BNP-vækst)"
)

# Gem placebo plots for BNP-vækst
ggsave("h3_high_gdp_placebo.png", plot = h3_high_gdp_placebo_plot, width = 10, height = 10, dpi = 300)
ggsave("h3_low_gdp_placebo.png", plot = h3_low_gdp_placebo_plot, width = 10, height = 10, dpi = 300)

## Placebo-tærskel tests (sammensat økonomisk indikator)
# God økonomi
h3_good_economy_placebo <- run_placebo_threshold_test(
  data = clean_data_good_economy,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  true_cutpoint = 0,
  placebo_range = c(-4, 4),
  placebo_step = 0.5,
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

h3_good_economy_placebo_plot <- plot_placebo_threshold_test(
  h3_good_economy_placebo,
  title = "H3: Placebo test (god økonomi)"
)

# Dårlig økonomi
h3_bad_economy_placebo <- run_placebo_threshold_test(
  data = clean_data_bad_economy,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  true_cutpoint = 0,
  placebo_range = c(-4, 4),
  placebo_step = 0.5,
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

h3_bad_economy_placebo_plot <- plot_placebo_threshold_test(
  h3_bad_economy_placebo,
  title = "H3: Placebo test (dårlig økonomi)"
)

# Gem placebo plots for sammensat økonomisk indikator
ggsave("h3_good_economy_placebo.png", plot = h3_good_economy_placebo_plot, width = 10, height = 10, dpi = 300)
ggsave("h3_bad_economy_placebo.png", plot = h3_bad_economy_placebo_plot, width = 10, height = 10, dpi = 300)

## Outcome placebo tests
# For høj BNP-vækst
placebo_vars <- c("rile_lowe", "per410")  # Placebo variabler der ikke burde påvirkes

h3_high_gdp_outcome_placebo <- run_outcome_placebo_test(
  data = clean_data_high_gdp,
  real_outcome_var = "miljø_afhængig",
  placebo_outcome_vars = placebo_vars,
  running_var = "centered_lagged_pervote_samlet",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

h3_high_gdp_outcome_placebo_plot <- plot_outcome_placebo_test(
  h3_high_gdp_outcome_placebo,
  title = "H3: Outcome placebo test (høj BNP-vækst)"
)

# For lav BNP-vækst
h3_low_gdp_outcome_placebo <- run_outcome_placebo_test(
  data = clean_data_low_gdp,
  real_outcome_var = "miljø_afhængig",
  placebo_outcome_vars = placebo_vars,
  running_var = "centered_lagged_pervote_samlet",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

h3_low_gdp_outcome_placebo_plot <- plot_outcome_placebo_test(
  h3_low_gdp_outcome_placebo,
  title = "H3: Outcome placebo test (lav BNP-vækst)"
)

# Gem outcome placebo plots
ggsave("h3_high_gdp_outcome_placebo.png", plot = h3_high_gdp_outcome_placebo_plot, width = 8, height = 6, dpi = 300)
ggsave("h3_low_gdp_outcome_placebo.png", plot = h3_low_gdp_outcome_placebo_plot, width = 8, height = 6, dpi = 300)

## Permutations tests
# For høj BNP-vækst
h3_high_gdp_permutation <- run_permutation_test(
  data = clean_data_high_gdp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  n_permutations = 500,
  covariates = c("country", "edate")
)

h3_high_gdp_permutation_plot <- plot_permutation_test(
  h3_high_gdp_permutation,
  title = "H3: Permutationstest (høj BNP-vækst)"
)

# For lav BNP-vækst
h3_low_gdp_permutation <- run_permutation_test(
  data = clean_data_low_gdp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  n_permutations = 500,
  covariates = c("country", "edate")
)

h3_low_gdp_permutation_plot <- plot_permutation_test(
  h3_low_gdp_permutation,
  title = "H3: Permutationstest (lav BNP-vækst)"
)

# Gem permutation plots
ggsave("h3_high_gdp_permutation.png", plot = h3_high_gdp_permutation_plot, width = 8, height = 10, dpi = 300)
ggsave("h3_low_gdp_permutation.png", plot = h3_low_gdp_permutation_plot, width = 8, height = 10, dpi = 300)

## Permutationstest for H2 (RRP-effekt)
# For H2 uden højreradikale partier
h2_no_rrp_permutation <- run_permutation_test(
  data = data_no_rrp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  n_permutations = 500,
  covariates = c("country", "edate")
)

h2_no_rrp_permutation_plot <- plot_permutation_test(
  h2_no_rrp_permutation,
  title = "H2: Permutationstest (uden højreradikale partier)"
)

# For H2 med højreradikale partier
h2_with_rrp_permutation <- run_permutation_test(
  data = data_with_rrp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  n_permutations = 500,
  covariates = c("country", "edate")
)

h2_with_rrp_permutation_plot <- plot_permutation_test(
  h2_with_rrp_permutation,
  title = "H2: Permutationstest (med højreradikale partier)"
)

# Gem permutation plots for H2
ggsave("h2_no_rrp_permutation.png", plot = h2_no_rrp_permutation_plot, width = 8, height = 10, dpi = 300)
ggsave("h2_with_rrp_permutation.png", plot = h2_with_rrp_permutation_plot, width = 8, height = 10, dpi = 300)

## Permutationstest for H4 (partiideologi)
# For H4 venstreorienterede partier
h4_left_permutation <- run_permutation_test(
  data = left_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  n_permutations = 500,
  covariates = c("country", "edate")
)

h4_left_permutation_plot <- plot_permutation_test(
  h4_left_permutation,
  title = "H4: Permutationstest (venstreorienterede partier)"
)

# For H4 højreorienterede partier
h4_right_permutation <- run_permutation_test(
  data = right_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  n_permutations = 500,
  covariates = c("country", "edate")
)

h4_right_permutation_plot <- plot_permutation_test(
  h4_right_permutation,
  title = "H4: Permutationstest (højreorienterede partier)"
)

# Gem permutation plots for H4
ggsave("h4_left_permutation.png", plot = h4_left_permutation_plot, width = 8, height = 10, dpi = 300)
ggsave("h4_right_permutation.png", plot = h4_right_permutation_plot, width = 8, height = 10, dpi = 300)

## Permutationstest for H5 (partistørrelse)
# For H5 store partier
h5_large_permutation <- run_permutation_test(
  data = large_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  n_permutations = 500,
  covariates = c("country", "edate")
)

h5_large_permutation_plot <- plot_permutation_test(
  h5_large_permutation,
  title = "H5: Permutationstest (store partier)"
)

# For H5 små partier
h5_small_permutation <- run_permutation_test(
  data = small_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  n_permutations = 500,
  covariates = c("country", "edate")
)

h5_small_permutation_plot <- plot_permutation_test(
  h5_small_permutation,
  title = "H5: Permutationstest (små partier)"
)

# Gem permutation plots for H5
ggsave("h5_large_permutation.png", plot = h5_large_permutation_plot, width = 8, height = 10, dpi = 300)
ggsave("h5_small_permutation.png", plot = h5_small_permutation_plot, width = 8, height = 10, dpi = 300)

# Opsummering af resultater for metodeafsnittet
# Tilføj H3 resultater til den samlede oversigt over placebo p-værdier
h3_placebo_summary <- data.frame(
  Model = c(
    "H3: Høj BNP-vækst",
    "H3: Lav BNP-vækst",
    "H3: God økonomi (sammensat)",
    "H3: Dårlig økonomi (sammensat)"
  ),
  Placebo_p_value = c(
    h3_high_gdp_placebo$empirical_p_value,
    h3_low_gdp_placebo$empirical_p_value,
    h3_good_economy_placebo$empirical_p_value,
    h3_bad_economy_placebo$empirical_p_value
  )
)

## 3.2 H4 individuelle plots
h4_left_plot <- create_coefficient_stability_plot(
  data = left_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomials = c(1, 2, 3),
  covariates = c("country", "edate"),
  title = "H4: Venstreorienterede partier"
)

h4_right_plot <- create_coefficient_stability_plot(
  data = right_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomials = c(1, 2, 3),
  covariates = c("country", "edate"),
  title = "H4: Højreorienterede partier"
)

# Gem plottene
pdf("h4_left_plot.pdf", width = 10, height = 6)
print(h4_left_plot)
dev.off()

pdf("h4_right_plot.pdf", width = 10, height = 6)
print(h4_right_plot)
dev.off()

## 3.3 H5 individuelle plots
h5_large_plot <- create_coefficient_stability_plot(
  data = large_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomials = c(1, 2, 3),
  covariates = c("country", "edate"),
  title = "H5: Store partier"
)

h5_small_plot <- create_coefficient_stability_plot(
  data = small_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  bw_list = seq(1, 3, by = 0.5),
  polynomials = c(1, 2, 3),
  covariates = c("country", "edate"),
  title = "H5: Små partier"
)

# Gem plottene
pdf("h5_large_plot.pdf", width = 10, height = 6)
print(h5_large_plot)
dev.off()

pdf("h5_small_plot.pdf", width = 10, height = 6)
print(h5_small_plot)
dev.off()

# 4. Placebo tests i appendix
# Kør placebo tests for alle modeller (for appendix)

## 4.1 Placebo-tærskel tests for alle modeller
# For H2 opdelt efter RRP status
h2_no_rrp_placebo <- run_placebo_threshold_test(
  data = data_no_rrp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

h2_with_rrp_placebo <- run_placebo_threshold_test(
  data = data_with_rrp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

# Plot og gem
h2_no_rrp_placebo_plot <- plot_placebo_threshold_test(
  h2_no_rrp_placebo,
  title = "H2: Placebo test (uden højreradikale partier)"
)

h2_with_rrp_placebo_plot <- plot_placebo_threshold_test(
  h2_with_rrp_placebo,
  title = "H2: Placebo test (med højreradikale partier)"
)

ggsave("h2_no_rrp_placebo.png", plot = h2_no_rrp_placebo_plot, width = 10, height = 6, dpi = 300)
ggsave("h2_with_rrp_placebo.png", plot = h2_with_rrp_placebo_plot, width = 10, height = 6, dpi = 300)

# For H4 opdelt efter partiideologi
h4_left_placebo <- run_placebo_threshold_test(
  data = left_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

h4_right_placebo <- run_placebo_threshold_test(
  data = right_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

# Plot og gem
h4_left_placebo_plot <- plot_placebo_threshold_test(
  h4_left_placebo,
  title = "H4: Placebo test (venstreorienterede partier)"
)

h4_right_placebo_plot <- plot_placebo_threshold_test(
  h4_right_placebo,
  title = "H4: Placebo test (højreorienterede partier)"
)

ggsave("h4_left_placebo.png", plot = h4_left_placebo_plot, width = 10, height = 10, dpi = 300)
ggsave("h4_right_placebo.png", plot = h4_right_placebo_plot, width = 10, height = 10, dpi = 300)

# For H5 opdelt efter partistørrelse
h5_large_placebo <- run_placebo_threshold_test(
  data = large_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

h5_small_placebo <- run_placebo_threshold_test(
  data = small_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

# Plot og gem
h5_large_placebo_plot <- plot_placebo_threshold_test(
  h5_large_placebo,
  title = "H5: Placebo test (store partier)"
)

h5_small_placebo_plot <- plot_placebo_threshold_test(
  h5_small_placebo,
  title = "H5: Placebo test (små partier)"
)

ggsave("h5_large_placebo.png", plot = h5_large_placebo_plot, width = 10, height = 10, dpi = 300)
ggsave("h5_small_placebo.png", plot = h5_small_placebo_plot, width = 10, height = 10, dpi = 300)

# 5. Opsummering af resultater i tabelform
# Lav tabel til metodeafsnittet med resultater fra alle modeller

# Sammenfat empiriske p-værdier fra placebo tests
placebo_summary <- data.frame(
  Model = c(
    "H1: Alle partier",
    "H2: Uden højreradikale partier",
    "H2: Med højreradikale partier",
    "H3: Høj BNP-vækst",
    "H3: Lav BNP-vækst",
    "H3: God økonomi (sammensat)",
    "H3: Dårlig økonomi (sammensat)",
    "H4: Venstreorienterede partier",
    "H4: Højreorienterede partier",
    "H5: Store partier",
    "H5: Små partier"
  ),
  Placebo_p_value = c(
    h1_placebo_threshold$empirical_p_value,
    h2_no_rrp_placebo$empirical_p_value,
    h2_with_rrp_placebo$empirical_p_value,
    h3_high_gdp_placebo$empirical_p_value,
    h3_low_gdp_placebo$empirical_p_value,
    h3_good_economy_placebo$empirical_p_value,
    h3_bad_economy_placebo$empirical_p_value,
    h4_left_placebo$empirical_p_value,
    h4_right_placebo$empirical_p_value,
    h5_large_placebo$empirical_p_value,
    h5_small_placebo$empirical_p_value
  )
)

# Print tabellen
print(placebo_summary)

permutation_summary <- data.frame(
  Model = c(
    "H1: Alle partier",
    "H2: Uden højreradikale partier",
    "H2: Med højreradikale partier",
    "H3: Høj BNP-vækst",
    "H3: Lav BNP-vækst",
    "H4: Venstreorienterede partier",
    "H4: Højreorienterede partier",
    "H5: Store partier",
    "H5: Små partier"
  ),
  Permutation_p_value = c(
    h1_permutation$p_value_effect,
    h2_no_rrp_permutation$p_value_effect,
    h2_with_rrp_permutation$p_value_effect,
    h3_high_gdp_permutation$p_value_effect,
    h3_low_gdp_permutation$p_value_effect,
    h4_left_permutation$p_value_effect,
    h4_right_permutation$p_value_effect,
    h5_large_permutation$p_value_effect,
    h5_small_permutation$p_value_effect
  )
)

print(permutation_summary)

# Gem som fil
write.csv(placebo_summary, "placebo_summary.csv", row.names = FALSE)

# 6. Sammenligning af forskellige robuste estimationsmetoder (NY TILFØJELSE)
# Denne tabel sammenligner resultaterne fra forskellige robuste estimationsmetoder
# Bemærk: Dette kræver at modellerne fra H1-analysen er tilgængelige i environment

# Prøv at hente modellerne, hvis de findes
tryCatch({
  robust_methods_comparison <- data.frame(
    Model = c(
      "H1: OLS (alle observationer)",
      "H1: OLS (kun non-zero)",
      "H1: Quantile (median)",
      "H1: Robust regression (MM)",
      "H1: rdrobust (optimal bw)",
      "H1: rdrobust (fixed bw)"
    ),
    Estimate = c(
      # Indsæt de faktiske estimater fra dine modeller her
      coef(h1_model_interaction)["lagged_i_parlament"],
      coef(h1_continuous)["lagged_i_parlament"],
      coef(h1_median_rq)["lagged_i_parlament"],
      coef(h1_robust_reg)["lagged_i_parlament"],
      summary(h1_rdd)$coef[1],
      summary(h1_rdd_alt)$coef[1]
    ),
    SE = c(
      # Indsæt standardfejl her
      summary(h1_model_interaction)$coefficients["lagged_i_parlament", "Std. Error"],
      summary(h1_continuous)$coefficients["lagged_i_parlament", "Std. Error"],
      summary(h1_median_rq)$coefficients["lagged_i_parlament", "Std. Error"],
      summary(h1_robust_reg)$coefficients["lagged_i_parlament", "Std. Error"],
      summary(h1_rdd)$se[1],
      summary(h1_rdd_alt)$se[1]
    ),
    P_value = c(
      # Indsæt p-værdier her
      summary(h1_model_interaction)$coefficients["lagged_i_parlament", "Pr(>|t|)"],
      summary(h1_continuous)$coefficients["lagged_i_parlament", "Pr(>|t|)"],
      summary(h1_median_rq)$coefficients["lagged_i_parlament", 4],
      # Beregn p-værdi for robust regression
      2 * pt(abs(coef(h1_robust_reg)["lagged_i_parlament"] / 
                 summary(h1_robust_reg)$coefficients["lagged_i_parlament", "Std. Error"]), 
             df = nrow(clean_data) - ncol(model.matrix(h1_robust_reg)), lower.tail = FALSE),
      summary(h1_rdd)$pv[1],
      summary(h1_rdd_alt)$pv[1]
    )
  )
  
  # Tilføj signifikansstjerner
  robust_methods_comparison$Significance <- ""
  robust_methods_comparison$Significance[robust_methods_comparison$P_value < 0.1] <- "."
  robust_methods_comparison$Significance[robust_methods_comparison$P_value < 0.05] <- "*"
  robust_methods_comparison$Significance[robust_methods_comparison$P_value < 0.01] <- "**"
  robust_methods_comparison$Significance[robust_methods_comparison$P_value < 0.001] <- "***"
  
  # Formater tal
  robust_methods_comparison$Estimate <- sprintf("%.3f", robust_methods_comparison$Estimate)
  robust_methods_comparison$SE <- sprintf("%.3f", robust_methods_comparison$SE)
  robust_methods_comparison$P_value <- sprintf("%.4f", robust_methods_comparison$P_value)
  
  # Kombiner estimat og signifikans
  robust_methods_comparison$Estimate_with_stars <- paste0(
    robust_methods_comparison$Estimate, 
    robust_methods_comparison$Significance
  )
  
  # Print tabellen
  print(robust_methods_comparison)
  
  # Gem som fil
  write.csv(robust_methods_comparison, "robust_methods_comparison.csv", row.names = FALSE)
  
  # Gem som pæn tabel
  if (requireNamespace("knitr", quietly = TRUE)) {
    print(knitr::kable(robust_methods_comparison[, c("Model", "Estimate_with_stars", "SE", "P_value")], 
                      caption = "Sammenligning af forskellige robuste estimationsmetoder"))
  }
}, error = function(e) {
  cat("Kunne ikke generere robust methods comparison tabel: ", e$message, "\n")
  cat("Dette kræver at h1_model_interaction, h1_continuous, h1_median_rq, h1_robust_reg, h1_rdd og h1_rdd_alt er i dit environment.\n")
})

# 7. Two-part model tests for alle undergrupper (NY TILFØJELSE)
# Generer two-part model visualiseringer for hver undergruppe

# For H2 opdelt efter RRP status
h2_no_rrp_two_part <- create_two_part_model_visualization(
  data = data_no_rrp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

h2_with_rrp_two_part <- create_two_part_model_visualization(
  data = data_with_rrp,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

# Gem plottene
ggsave("h2_no_rrp_two_part.png", plot = h2_no_rrp_two_part, width = 10, height = 8, dpi = 300)
ggsave("h2_with_rrp_two_part.png", plot = h2_with_rrp_two_part, width = 10, height = 8, dpi = 300)

# For H4 opdelt efter partiideologi
h4_left_two_part <- create_two_part_model_visualization(
  data = left_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

h4_right_two_part <- create_two_part_model_visualization(
  data = right_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

# Gem plottene
ggsave("h4_left_two_part.png", plot = h4_left_two_part, width = 10, height = 8, dpi = 300)
ggsave("h4_right_two_part.png", plot = h4_right_two_part, width = 10, height = 8, dpi = 300)

# For H5 opdelt efter partistørrelse
h5_large_two_part <- create_two_part_model_visualization(
  data = large_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

h5_small_two_part <- create_two_part_model_visualization(
  data = small_parties,
  outcome_var = "miljø_afhængig",
  running_var = "centered_lagged_pervote_samlet",
  treatment_var = "lagged_i_parlament",
  polynomial = 1,
  bandwidth = 2,
  covariates = c("country", "edate")
)

# Gem plottene
ggsave("h5_large_two_part.png", plot = h5_large_two_part, width = 10, height = 8, dpi = 300)
ggsave("h5_small_two_part.png", plot = h5_small_two_part, width = 10, height = 8, dpi = 300)

# 8. Sammenligning af zero vs. non-zero effekter på tværs af alle undergrupper (NY TILFØJELSE)
# Denne tabel sammenligner effekten på sandsynligheden for ikke-nul værdier mod intensiteten af ikke-nul værdier

# For hver undergruppe, kør en binær model og en kontinuert model
# H1
h1_binary <- glm(I(miljø_afhængig != 0) ~ centered_lagged_pervote_samlet * lagged_i_parlament,
               family = binomial, data = clean_data)
h1_continuous <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                  data = subset(clean_data, miljø_afhængig != 0))

# H2
h2_no_rrp_binary <- glm(I(miljø_afhængig != 0) ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                      family = binomial, data = data_no_rrp)
h2_no_rrp_continuous <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                         data = subset(data_no_rrp, miljø_afhængig != 0))

h2_with_rrp_binary <- glm(I(miljø_afhængig != 0) ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                        family = binomial, data = data_with_rrp)
h2_with_rrp_continuous <- lm(miljø_afhængig ~ centered_lagged_pervote_samlet * lagged_i_parlament,
                           data = subset(data_with_rrp, miljø_afhængig != 0))

# Skab en sammenligningssabel
zero_nonzero_comparison <- data.frame(
  Model = c(
    "H1: Alle partier",
    "H2: Uden højreradikale partier",
    "H2: Med højreradikale partier",
    "H4: Venstreorienterede partier",
    "H4: Højreorienterede partier",
    "H5: Store partier",
    "H5: Små partier"
  ),
  Binary_Estimate = c(
    coef(h1_binary)["lagged_i_parlament"],
    coef(h2_no_rrp_binary)["lagged_i_parlament"],
    coef(h2_with_rrp_binary)["lagged_i_parlament"],
    coef(h4_binary_left)["lagged_i_parlament"],
    coef(h4_binary_right)["lagged_i_parlament"],
    coef(h5_binary_large)["lagged_i_parlament"],
    coef(h5_binary_small)["lagged_i_parlament"]
  ),
  Binary_SE = c(
    summary(h1_binary)$coefficients["lagged_i_parlament", "Std. Error"],
    summary(h2_no_rrp_binary)$coefficients["lagged_i_parlament", "Std. Error"],
    summary(h2_with_rrp_binary)$coefficients["lagged_i_parlament", "Std. Error"],
    summary(h4_binary_left)$coefficients["lagged_i_parlament", "Std. Error"],
    summary(h4_binary_right)$coefficients["lagged_i_parlament", "Std. Error"],
    summary(h5_binary_large)$coefficients["lagged_i_parlament", "Std. Error"],
    summary(h5_binary_small)$coefficients["lagged_i_parlament", "Std. Error"]
  ),
  Binary_P = c(
    summary(h1_binary)$coefficients["lagged_i_parlament", "Pr(>|z|)"],
    summary(h2_no_rrp_binary)$coefficients["lagged_i_parlament", "Pr(>|z|)"],
    summary(h2_with_rrp_binary)$coefficients["lagged_i_parlament", "Pr(>|z|)"],
    summary(h4_binary_left)$coefficients["lagged_i_parlament", "Pr(>|z|)"],
    summary(h4_binary_right)$coefficients["lagged_i_parlament", "Pr(>|z|)"],
    summary(h5_binary_large)$coefficients["lagged_i_parlament", "Pr(>|z|)"],
    summary(h5_binary_small)$coefficients["lagged_i_parlament", "Pr(>|z|)"]
  ),
  Continuous_Estimate = c(
    coef(h1_continuous)["lagged_i_parlament"],
    coef(h2_no_rrp_continuous)["lagged_i_parlament"],
    coef(h2_with_rrp_continuous)["lagged_i_parlament"],
    coef(h4_continuous_left)["lagged_i_parlament"],
    coef(h4_continuous_right)["lagged_i_parlament"],
    coef(h5_continuous_large)["lagged_i_parlament"],
    coef(h5_continuous_small)["lagged_i_parlament"]
  ),
  Continuous_SE = c(
    summary(h1_continuous)$coefficients["lagged_i_parlament", "Std. Error"],
    summary(h2_no_rrp_continuous)$coefficients["lagged_i_parlament", "Std. Error"],
    summary(h2_with_rrp_continuous)$coefficients["lagged_i_parlament", "Std. Error"],
    summary(h4_continuous_left)$coefficients["lagged_i_parlament", "Std. Error"],
    summary(h4_continuous_right)$coefficients["lagged_i_parlament", "Std. Error"],
    summary(h5_continuous_large)$coefficients["lagged_i_parlament", "Std. Error"],
    summary(h5_continuous_small)$coefficients["lagged_i_parlament", "Std. Error"]
  ),
  Continuous_P = c(
    summary(h1_continuous)$coefficients["lagged_i_parlament", "Pr(>|t|)"],
    summary(h2_no_rrp_continuous)$coefficients["lagged_i_parlament", "Pr(>|t|)"],
    summary(h2_with_rrp_continuous)$coefficients["lagged_i_parlament", "Pr(>|t|)"],
    summary(h4_continuous_left)$coefficients["lagged_i_parlament", "Pr(>|t|)"],
    summary(h4_continuous_right)$coefficients["lagged_i_parlament", "Pr(>|t|)"],
    summary(h5_continuous_large)$coefficients["lagged_i_parlament", "Pr(>|t|)"],
    summary(h5_continuous_small)$coefficients["lagged_i_parlament", "Pr(>|t|)"]
  )
)

# Tilføj signifikansstjerner
add_stars <- function(p_values) {
  stars <- rep("", length(p_values))
  stars[p_values < 0.1] <- "."
  stars[p_values < 0.05] <- "*"
  stars[p_values < 0.01] <- "**"
  stars[p_values < 0.001] <- "***"
  return(stars)
}

zero_nonzero_comparison$Binary_Stars <- add_stars(zero_nonzero_comparison$Binary_P)
zero_nonzero_comparison$Continuous_Stars <- add_stars(zero_nonzero_comparison$Continuous_P)

# Formater tal
zero_nonzero_comparison$Binary_Estimate <- sprintf("%.3f%s", 
                                                 zero_nonzero_comparison$Binary_Estimate,
                                                 zero_nonzero_comparison$Binary_Stars)
zero_nonzero_comparison$Continuous_Estimate <- sprintf("%.3f%s", 
                                                     zero_nonzero_comparison$Continuous_Estimate,
                                                     zero_nonzero_comparison$Continuous_Stars)

# Vis tabel
if (requireNamespace("knitr", quietly = TRUE)) {
  print(knitr::kable(zero_nonzero_comparison[, c("Model", "Binary_Estimate", "Continuous_Estimate")], 
                    col.names = c("Model", "Effekt på sandsynlighed for miljøposition", 
                                 "Effekt på intensitet af miljøposition"),
                    caption = "To-delt model: Effekter opdelt på sandsynlighed vs. intensitet"))
}

# Gem som fil
write.csv(zero_nonzero_comparison, "zero_nonzero_comparison.csv", row.names = FALSE)

# Afsluttende besked
cat("Alle plots og tabeller er nu genereret og gemt.\n")
cat("Denne analyse inkluderer nye robuste metoder, to-delt model, og kvantil regression.\n")
```




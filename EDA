# Opret først hovedmappen Robusthedstests, hvis den ikke allerede eksisterer
dir.create("Diskriptiv Analyse", showWarnings = FALSE)

# 1. Descriptive Statistics ------------------

# 1.1 Summary statistics table for key variables --------------
summary_stats <- final_dataset %>%
  dplyr::select(
    miljø_afhængig, per410, per416, per501, 
    pervote_samlet, lagged_pervote_samlet, 
    i_parlament, lagged_i_parlament,
    rile_lowe, avg_pervote_main, 
    rrp_i_p_lag1, `GDP_per_capita_lag1`, Unemployment, `Inflation-consumer prices`
  ) %>%
  summary()

# Creating a more formatted table
summary_table <- final_dataset %>%
  dplyr::select(
    miljø_afhængig, per410, per416, per501, 
    pervote_samlet, lagged_pervote_samlet, 
    i_parlament, lagged_i_parlament,
    rile_lowe, avg_pervote_main, 
    rrp_i_p_lag1, `GDP_per_capita_lag1`, Unemployment, `Inflation-consumer prices`
  ) %>%
  summarise(across(where(is.numeric), 
                   list(
                     mean = ~mean(., na.rm = TRUE),
                     median = ~median(., na.rm = TRUE),
                     sd = ~sd(., na.rm = TRUE),
                     min = ~min(., na.rm = TRUE),
                     max = ~max(., na.rm = TRUE),
                     n = ~sum(!is.na(.))
                   )))

# Reshape for better presentation
summary_long <- summary_table %>%
  pivot_longer(cols = everything(),
               names_to = c("variable", "stat"),
               names_pattern = "(.*)_(.*)",
               values_to = "value")

summary_wide <- summary_long %>%
  pivot_wider(names_from = stat, values_from = value) %>%
  arrange(variable)

# 1.2 Country-level summary --------------
country_summary <- final_dataset %>%
  group_by(countryname) %>%
  summarise(
    n_observations = n(),
    first_year = min(Year, na.rm = TRUE),
    last_year = max(Year, na.rm = TRUE),
    n_parties = n_distinct(party),
    avg_parties_per_year = n_parties / (last_year - first_year + 1),
    n_green_in_parl = sum(lagged_i_parlament, na.rm = TRUE),
    n_rrp_in_parl = sum(rrp_i_p_lag1, na.rm = TRUE),
    avg_climate_position = mean(miljø_afhængig, na.rm = TRUE)
  )

# 1.3 Electoral threshold variation --------------
threshold_summary <- final_dataset %>%
  group_by(countryname) %>%
  summarise(
    min_threshold = min(threshold, na.rm = TRUE),
    max_threshold = max(threshold, na.rm = TRUE),
    threshold_changed = min_threshold != max_threshold,
    avg_threshold = mean(threshold, na.rm = TRUE)
  )

# 1.4 Green party success rates over time --------------
green_success_time <- final_dataset %>%
  group_by(Year) %>%
  summarise(
    green_parties = sum(!is.na(pervote_samlet)),
    greens_in_parl = sum(i_parlament, na.rm = TRUE),
    success_rate = greens_in_parl / green_parties
  )

# Green party success by country
green_success_country <- final_dataset %>%
  group_by(countryname) %>%
  summarise(
    green_parties = sum(!is.na(pervote_samlet)),
    greens_in_parl = sum(i_parlament, na.rm = TRUE),
    success_rate = greens_in_parl / green_parties
  )

# 1.5 Visualize country coverage --------------
country_coverage_plot <- ggplot(country_summary, aes(x = reorder(countryname, n_observations), y = n_observations)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  labs(
    title = "Number of Observations by Country",
    x = "Country",
    y = "Number of Observations"
  ) +
  theme_minimal()

# 1.6 Time coverage by country --------------
time_coverage <- final_dataset %>%
  group_by(countryname, Year) %>%
  summarise(has_obs = TRUE, .groups = "drop") %>%
  complete(countryname, Year = min(final_dataset$Year, na.rm = TRUE):max(final_dataset$Year, na.rm = TRUE)) %>%
  mutate(has_obs = ifelse(is.na(has_obs), FALSE, TRUE))

time_coverage_plot <- ggplot(time_coverage, aes(x = Year, y = countryname, fill = has_obs)) +
  geom_tile(color = "white") +
  scale_fill_manual(values = c("TRUE" = "steelblue", "FALSE" = "lightgray")) +
  labs(
    title = "Time Coverage by Country",
    x = "Year",
    y = "Country",
    fill = "Has Data"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")

# 2. Outcome Variable Analysis ------------

# 2.1 Distribution of climate position --------------
climate_dist_plot <- ggplot(final_dataset, aes(x = miljø_afhængig)) +
  geom_histogram(aes(y = ..density..), bins = 30, fill = "steelblue", color = "darkblue", alpha = 0.7) +
  geom_density(color = "red", size = 1) +
  labs(
    title = "Distribution of Climate Position Variable",
    x = "Climate Position (miljø_afhængig)",
    y = "Density"
  ) +
  theme_minimal()

# 2.2 Climate position by country --------------
climate_country_plot <- ggplot(final_dataset, aes(x = reorder(countryname, miljø_afhængig, FUN = median, na.rm = TRUE), 
                                               y = miljø_afhængig)) +
  geom_boxplot(fill = "steelblue", alpha = 0.7) +
  coord_flip() +
  labs(
    title = "Climate Position by Country",
    x = "Country",
    y = "Climate Position"
  ) +
  theme_minimal()

# 2.3 Climate position over time --------------
climate_time_plot <- final_dataset %>%
  group_by(Year) %>%
  summarise(
    mean_climate = mean(miljø_afhængig, na.rm = TRUE),
    median_climate = median(miljø_afhængig, na.rm = TRUE),
    lower_ci = mean_climate - 1.96 * sd(miljø_afhængig, na.rm = TRUE) / sqrt(n()),
    upper_ci = mean_climate + 1.96 * sd(miljø_afhængig, na.rm = TRUE) / sqrt(n())
  ) %>%
  ggplot(aes(x = Year, y = mean_climate)) +
  geom_line(size = 1, color = "steelblue") +
  geom_ribbon(aes(ymin = lower_ci, ymax = upper_ci), alpha = 0.2) +
  geom_line(aes(y = median_climate), linetype = "dashed", color = "darkred") +
  labs(
    title = "Climate Position Over Time",
    x = "Year",
    y = "Average Climate Position",
    caption = "Solid line: mean with 95% CI; Dashed line: median"
  ) +
  theme_minimal()

# 2.4 Components of climate position --------------
components_data <- final_dataset %>%
  dplyr::select(countryname, edate, party, per410, per416, per501) %>%
  pivot_longer(cols = c(per410, per416, per501),
               names_to = "component",
               values_to = "value") %>%
  mutate(component = case_when(
    component == "per410" ~ "Environmental Protection (per410)",
    component == "per416" ~ "Anti-Growth Economy (per416)",
    component == "per501" ~ "Environmental Protection: Positive (per501)",
    TRUE ~ component
  ))

components_plot <- ggplot(components_data, aes(x = value, fill = component)) +
  geom_histogram(bins = 20, alpha = 0.7, position = "identity") +
  facet_wrap(~ component) +
  labs(
    title = "Distribution of Climate Position Components",
    x = "Value",
    y = "Count"
  ) +
  theme_minimal() +
  theme(legend.position = "none")

# 2.5 Climate position zero values analysis --------------
zero_prop <- final_dataset %>%
  dplyr::group_by(countryname) %>%
  summarise(
    total = n(),
    zero_values = sum(miljø_afhængig == 0, na.rm = TRUE),
    prop_zero = zero_values / total
  ) %>%
  arrange(desc(prop_zero))

zero_plot <- ggplot(zero_prop, aes(x = reorder(countryname, prop_zero), y = prop_zero)) +
  geom_bar(stat = "identity", fill = "darkred") +
  coord_flip() +
  labs(
    title = "Proportion of Zero Climate Position Values by Country",
    x = "Country",
    y = "Proportion of Zero Values"
  ) +
  theme_minimal()

# 2.6 Climate position by party family --------------
party_family_climate <- final_dataset %>%
  dplyr::mutate(
    party_family = case_when(
      parfam == "10" ~ "Green",
      parfam == "20" ~ "Socialist/Other left parties",
      parfam == "30" ~ "Social Democratic",
      parfam == "40" ~ "Liberal",
      parfam == "50" ~ "Christian Democratic",
      parfam == "60" ~ "Conservative",
      parfam == "70" ~ "Nationalist",
      parfam == "80" ~ "Agrarian",
      parfam == "90" ~ "Ethnic/Regional",
      parfam == "95" ~ "Special issue parties",
      parfam == "98" ~ "Electoral alliance w/o leader",
      TRUE ~ "Other"
    )
  ) %>%
  filter(!is.na(party_family))

family_climate_plot <- ggplot(party_family_climate, aes(x = reorder(party_family, miljø_afhængig, FUN = median, na.rm = TRUE), 
                                                     y = miljø_afhængig)) +
  geom_boxplot(fill = "steelblue", alpha = 0.7) +
  coord_flip() +
  labs(
    title = "Climate Position by Party Family",
    x = "Party Family",
    y = "Climate Position"
  ) +
  theme_minimal()

# 2.7 Andel nul-værdier for partifamilierne --------------
# Oprettelse af forbedret graf med de rigtige partifamilienavne
zero_climate_by_parfam <- final_dataset %>%
   mutate(
     party_family = case_when(
       parfam == "10" ~ "Green",
       parfam == "20" ~ "Socialist/Other left parties",
       parfam == "30" ~ "Social Democratic",
       parfam == "40" ~ "Liberal",
       parfam == "50" ~ "Christian Democratic",
       parfam == "60" ~ "Conservative",
       parfam == "70" ~ "Nationalist",
       parfam == "80" ~ "Agrarian",
       parfam == "90" ~ "Ethnic/Regional",
       parfam == "95" ~ "Special issue parties",
       parfam == "98" ~ "Electoral alliance w/o leader",
       TRUE ~ "Other"
     )
   ) %>%
   group_by(party_family) %>%
   summarise(
     zero_proportion = mean(miljø_afhængig == 0, na.rm = TRUE)
   ) %>%
   # Sortér fra høj til lav værdi
   arrange(desc(zero_proportion)) %>%
   # Omdanner til faktor med niveauerne i sorteret rækkefølge
   mutate(party_family = factor(party_family, levels = party_family))
 
 ggplot(zero_climate_by_parfam, aes(x = party_family, y = zero_proportion)) +
   geom_bar(stat = "identity", fill = "steelblue") +
   labs(
     title = "Proportion of Zero Climate Position Values by Party Family",
     x = "Party Family",
     y = "Proportion of Zero Values"
   ) +
   theme_minimal() +
   theme(
     panel.grid.major.y = element_blank(),
     panel.grid.minor.y = element_blank(),
     panel.grid.minor.x = element_blank(),
     axis.text.y = element_text(size = 9),
     plot.title = element_text(size = 12, face = "bold"),
     plot.margin = margin(10, 10, 10, 10)
   ) +
   coord_flip() +
   # Bruge decimaler i stedet for procent
   scale_y_continuous(labels = function(x) format(x, decimal.mark = ".", big.mark = ","), 
                     breaks = seq(0, 0.20, by = 0.05),
                     limits = c(0, 0.20))


# 3. Running Variable and Treatment Analysis --------------


# 3.1 Distribution of green party vote share relative to threshold --------------
rv_dist_plot <- ggplot(final_dataset, aes(x = centered_lagged_pervote_samlet)) +
  geom_histogram(binwidth = 0.5, fill = "steelblue", color = "darkblue") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red", size = 1) +
  labs(
    title = "Distribution of Green Party Vote Share (Centered at Threshold)",
    x = "Centered Vote Share",
    y = "Count"
  ) +
  theme_minimal()

# 3.2 Density test around threshold (McCrary test) --------------
# Estimér og test tæthedsdiskontinuitet
rdd_result <- rddensity(final_dataset$centered_lagged_pervote_samlet, c = 0)
density_test_summary <- summary(rdd_result)

# Plot med indbygget funktion (korrekt metode ifølge Cattaneo et al.)
rdplotdensity(rdd_result, 
              X = final_dataset$centered_lagged_pervote_samlet,
              type = "both",
              CItype = "region",
              title = "Density Manipulation Test around Threshold",
              xlabel = "Centered Vote Share",
              ylabel = "Density",
              lcol = c("blue", "red"),
              legendTitle = "Density Estimates",
              legendGroups = c("Below threshold", "Above threshold"))

DCdensity(final_dataset$centered_lagged_pervote_samlet, c = 0, ext.out = TRUE)



# 3.3 Relationship between vote share and seat allocation --------------
seat_allocation_plot <- ggplot(final_dataset, aes(x = centered_lagged_pervote_samlet, y = lagged_i_parlament)) +
  geom_jitter(aes(color = factor(lagged_i_parlament)), width = 0, height = 0.05, alpha = 0.5) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  labs(
    title = "Green Party Parliamentary Representation by Vote Share",
    x = "Vote Share (Centered at Threshold)",
    y = "In Parliament"
  ) +
  scale_color_manual(values = c("0" = "darkblue", "1" = "darkred"), 
                     name = "Parliamentary\nStatus",
                     labels = c("Not in Parliament", "In Parliament")) +
  theme_minimal()

# 3.4 Balance check for covariates around threshold --------------
# Create functions for balance check
balance_check_plot <- function(data, var_name, running_var, cutpoint = 0, bandwidth = 2) {
  # Convert running_var from character to actual variable
  running_var_value <- data[[running_var]]
  
  # Create subset without using dplyr filter to avoid grouping issues
  data_subset <- data[abs(running_var_value) <= bandwidth, ]
  
  formula_str <- as.formula(paste0(var_name, " ~ ", running_var, " * I(", 
                                  running_var, " >= ", cutpoint, ")"))
  
  model <- lm(formula_str, data = data_subset)
  model_summary <- summary(model)
  
  # Make sure to handle potential issues with the interaction term
  interaction_pval <- tryCatch({
    coef(model_summary)[4, 4]
  }, error = function(e) {
    NA
  })
  
  ggplot(data, aes_string(x = running_var, y = var_name)) +
    geom_point(alpha = 0.3) +
    geom_smooth(data = subset(data, data[[running_var]] < cutpoint), 
                method = "lm", formula = y ~ x, color = "blue") +
    geom_smooth(data = subset(data, data[[running_var]] >= cutpoint), 
                method = "lm", formula = y ~ x, color = "red") +
    geom_vline(xintercept = cutpoint, linetype = "dashed") +
    labs(
      title = paste("Balance Check:", var_name),
      subtitle = paste("Interaction p-value:", round(interaction_pval, 4)),
      x = "Running Variable",
      y = var_name
    ) +
    theme_minimal()
}

# Run balance checks for key variables
rile_balance <- balance_check_plot(final_dataset, "rile_lowe", "centered_lagged_pervote_samlet")
gdp_balance <- balance_check_plot(final_dataset, "GDP_per_capita_lag1", "centered_lagged_pervote_samlet")
unemp_balance <- balance_check_plot(final_dataset, "Unemployment", "centered_lagged_pervote_samlet")
#gdp_growth_balance <- balance_check_plot(final_dataset, `GDP_per_capita_lag1`, "centered_lagged_pervote_samlet")


# 3.5 Green party representation over time --------------
green_time_plot <- final_dataset %>%
  dplyr::group_by(Year) %>%
  summarise(
    prop_in_parl = mean(lagged_i_parlament, na.rm = TRUE),
    avg_vote_share = mean(lagged_pervote_samlet, na.rm = TRUE)
  ) %>%
  ggplot(aes(x = Year)) +
  geom_line(aes(y = prop_in_parl, color = "Proportion in Parliament"), size = 1) +
  geom_line(aes(y = avg_vote_share / 100, color = "Average Vote Share (scaled)"), size = 1) +
  scale_y_continuous(
    name = "Proportion in Parliament",
    sec.axis = sec_axis(~.*100, name = "Average Vote Share (%)")
  ) +
  scale_color_manual(values = c("Proportion in Parliament" = "darkred", 
                               "Average Vote Share (scaled)" = "darkblue")) +
  labs(
    title = "Green Party Representation Over Time",
    x = "Year",
    color = "Measure"
  ) +
  theme_minimal()


# 4. Moderating Variables Analysis --------------

# 4.1 Radical right presence over time --------------
rrp_time_plot <- final_dataset %>%
  dplyr::group_by(Year) %>%
  summarise(
    prop_rrp = mean(rrp_i_p_lag1, na.rm = TRUE)
  ) %>%
  ggplot(aes(x = Year, y = prop_rrp)) +
  geom_line(size = 1, color = "darkred") +
  geom_point(size = 2, color = "darkred") +
  labs(
    title = "Radical Right Party Presence Over Time",
    x = "Year",
    y = "Proportion of Observations with RRP in Parliament"
  ) +
  theme_minimal()

# 4.2 Economic conditions visualization --------------
# Opret de tre individuelle plots
# Plot for GDP growth
p1 <- final_dataset %>%
  dplyr::group_by(Year) %>%
  summarise(GDP_per_capita_lag1 = mean(`GDP_per_capita_lag1`, na.rm = TRUE)) %>%
  ggplot(aes(x = Year, y = GDP_per_capita_lag1)) +
  geom_line(size = 1, color = "red") +
  geom_point(size = 2, color = "red") +
  labs(title = "GDP Growth", y = "Value") +
  theme_minimal()

# Plot for inflation (med logaritmisk skala)
p2 <- final_dataset %>%
  dplyr::group_by(Year) %>%
  summarise(inflation = mean(`Inflation-consumer prices`, na.rm = TRUE)) %>%
  ggplot(aes(x = Year, y = inflation)) +
  geom_line(size = 1, color = "green") +
  geom_point(size = 2, color = "green") +
  scale_y_log10() +
  labs(title = "Inflation (log scale)", y = "Value") +
  theme_minimal()

# Plot for unemployment
p3 <- final_dataset %>%
  dplyr::group_by(Year) %>%
  summarise(unemployment = mean(Unemployment, na.rm = TRUE)) %>%
  ggplot(aes(x = Year, y = unemployment)) +
  geom_line(size = 1, color = "blue") +
  geom_point(size = 2, color = "blue") +
  labs(title = "Unemployment", y = "Value") +
  theme_minimal()

# Kombiner plots i én række (ligesom i dit eksempel)
econ_indicators_plot <- p1 + p2 + p3 +
  plot_layout(ncol = 3) +
  plot_annotation(
    title = "Economic Indicators Over Time",
    subtitle = "GDP Growth, Inflation (logarithmic scale), and Unemployment",
    theme = theme(plot.title = element_text(size = 14, face = "bold"),
                 plot.subtitle = element_text(size = 10))
  )

# Vis samlet plot
print(econ_indicators_plot)

# Gem plottet hvis nødvendigt
# ggsave("economic_indicators.png", econ_indicators_plot, width = 12, height = 5, dpi = 300)

# 4.3 Left-right party distribution --------------
ideology_dist_plot <- ggplot(final_dataset, aes(x = rile_lowe)) +
  geom_histogram(bins = 30, fill = "steelblue", color = "darkblue", alpha = 0.7) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red") +
  labs(
    title = "Distribution of Party Ideology (Lowe's RILE Score)",
    x = "RILE Score (Negative = Left, Positive = Right)",
    y = "Count"
  ) +
  theme_minimal()

# 4.4 Party size distribution --------------
party_size_plot <- ggplot(final_dataset, aes(x = avg_pervote_main)) +
  geom_histogram(bins = 30, fill = "steelblue", color = "darkblue", alpha = 0.7) +
  geom_vline(xintercept = median(final_dataset$avg_pervote_main, na.rm = TRUE), 
            linetype = "dashed", color = "red") +
  # Create a data frame for the label instead of using annotate
  geom_text(data = data.frame(
      x = median(final_dataset$avg_pervote_main, na.rm = TRUE) + 5,
      y = 50,
      label = "Median"
    ), 
    aes(x = x, y = y, label = label),
    color = "red"
  ) +
  labs(
    title = "Distribution of Party Size (Average Vote Share)",
    x = "Average Vote Share (%)",
    y = "Count"
  ) +
  theme_minimal()

# 4.5 Correlation matrix of moderating variables --------------
correlation_data <- final_dataset %>%
  dplyr::select(
    miljø_afhængig, rile_lowe, avg_pervote_main, 
    rrp_i_p_lag1, `GDP_per_capita_lag1`, 
    Unemployment, `Inflation-consumer prices`
  ) %>%
  na.omit()

correlation_matrix <- cor(correlation_data)

# Correlation plot
corrplot(correlation_matrix, method = "color", type = "upper", 
        order = "hclust", tl.col = "black", tl.srt = 45,
        title = "Correlation Matrix of Key Variables",
        mar = c(0,0,2,0))


# 5. Preliminary Relationship Exploration --------------

# 5.1 Bivariate relationship plot --------------
bivariate_plot <- ggplot(final_dataset, aes(x = centered_lagged_pervote_samlet, y = miljø_afhængig)) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "loess") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red") +
  labs(
    title = "Relationship Between Green Party Vote Share and Climate Position",
    x = "Green Party Vote Share (Centered)",
    y = "Climate Position"
  ) +
  theme_minimal()

# 5.2 Conditional means plot --------------
# Funktion til at lave conditional means plot med bin-data og forskellig polynomiegrad
create_conditional_means_plot <- function(data, poly_degree, bin_width = 0.5, x_limit = 10) {
  # Opret bins for data
  data$bin <- cut(data$centered_lagged_pervote_samlet, 
                 breaks = seq(-5, x_limit, by = bin_width),
                 include.lowest = TRUE)
  
  # Beregn gennemsnit for hver bin
  bin_means <- data %>%
    dplyr::group_by(bin, factor_lagged_i_parlament) %>%
    dplyr::summarise(
      mean_miljø = mean(miljø_afhængig, na.rm = TRUE),
      se_miljø = sd(miljø_afhængig, na.rm = TRUE) / sqrt(n()),
      median_bin = median(as.numeric(centered_lagged_pervote_samlet), na.rm = TRUE),
      n = n(),
      .groups = "drop"
    )
  
  # Plot binned means med polynomial fit
  ggplot() +
    # Tilføj punkter for hver bin
    geom_point(data = bin_means, 
              aes(x = median_bin, y = mean_miljø, color = factor_lagged_i_parlament, size = n),
              alpha = 0.7) +
    # Tilføj fejllinjer
    geom_errorbar(data = bin_means,
                 aes(x = median_bin, 
                     ymin = mean_miljø - se_miljø, 
                     ymax = mean_miljø + se_miljø,
                     color = factor_lagged_i_parlament),
                 width = 0.1, alpha = 0.5) +
    # Tilføj polynomial fit til venstre for tærsklen
    geom_smooth(data = subset(bin_means, median_bin < 0),
               aes(x = median_bin, y = mean_miljø),
               method = "lm", formula = paste0("y ~ poly(x, ", poly_degree, ", raw = TRUE)"),
               color = "blue", se = TRUE) +
    # Tilføj polynomial fit til højre for tærsklen
    geom_smooth(data = subset(bin_means, median_bin >= 0),
               aes(x = median_bin, y = mean_miljø),
               method = "lm", formula = paste0("y ~ poly(x, ", poly_degree, ", raw = TRUE)"),
               color = "red", se = TRUE) +
    # Tilføj vertikal linje ved tærsklen
    geom_vline(xintercept = 0, linetype = "dashed") +
    # Juster akser og titler
    coord_cartesian(xlim = c(-5, x_limit)) +
    scale_size_continuous(name = "Antal obs.", range = c(1, 5)) +
    labs(
      title = paste0("Conditional Means Plot (Polynomial Degree ", poly_degree, ")"),
      x = "Green Party Vote Share (Centered)",
      y = "Average Climate Position",
      color = "Parliamentary Status"
    ) +
    theme_minimal()
}

# Opret plots med forskellige polynomiegrader
cm1 <- create_conditional_means_plot(final_dataset, poly_degree = 1)
cm2 <- create_conditional_means_plot(final_dataset, poly_degree = 2)
cm3 <- create_conditional_means_plot(final_dataset, poly_degree = 3)
cm4 <- create_conditional_means_plot(final_dataset, poly_degree = 4)

# Kombiner plots i et 2x2 grid
conditional_means_comparison <- (cm1 + cm2) / (cm3 + cm4) + 
  plot_annotation(
    title = "Conditional Means Visualization: Comparison of Different Polynomial Specifications",
    subtitle = "Effect of Green Party Parliamentary Entry on Climate Position",
    theme = theme(plot.title = element_text(size = 14, face = "bold"),
                 plot.subtitle = element_text(size = 10))
  )

# Vis samlet plot
print(conditional_means_comparison)

# Gem plottet til en fil
ggsave("conditional_means_comparison.png", conditional_means_comparison, width = 12, height = 9, dpi = 300)

# 5.3 Enhanced RDD visualization --------------
# Funktion til at oprette RDD plot med specifik polynomiegrad
create_poly_rdd_plot <- function(data, poly_degree, x_limit = 10) {
  # Beregn y-position for annotationer
  max_y_value <- max(data$miljø_afhængig, na.rm = TRUE)
  annotation_y_position <- max_y_value * 0.9
  
  # Opret plottet
  ggplot(data, aes(x = centered_lagged_pervote_samlet, y = miljø_afhængig)) +
    # Begræns x-aksen til det specificerede interval
    coord_cartesian(xlim = c(-6, x_limit)) +
    # Tilføj punkter
    geom_point(aes(color = factor_lagged_i_parlament), alpha = 0.3, size = 1) +
    # Kurve for data til venstre for tærsklen
    geom_smooth(data = subset(data, centered_lagged_pervote_samlet < 0 & centered_lagged_pervote_samlet > -5),
               method = "lm", 
               formula = paste0("y ~ poly(x, ", poly_degree, ", raw = TRUE)"), 
               color = "blue", se = TRUE) +
    # Kurve for data til højre for tærsklen
    geom_smooth(data = subset(data, centered_lagged_pervote_samlet >= 0 & centered_lagged_pervote_samlet < x_limit),
               method = "lm", 
               formula = paste0("y ~ poly(x, ", poly_degree, ", raw = TRUE)"), 
               color = "red", se = TRUE) +
    # Tilføj vertikal linje ved tærsklen
    geom_vline(xintercept = 0, linetype = "dashed") +
    # Brug geom_text i stedet for annotate for at undgå fejl
    geom_text(aes(x = -3.5, y = annotation_y_position, label = "Green Party Below Threshold"), 
              color = "darkblue", size = 3, inherit.aes = FALSE) +
    geom_text(aes(x = 5, y = annotation_y_position, label = "Green Party Above Threshold"), 
              color = "darkred", size = 3, inherit.aes = FALSE) +
    # Titler og aksenavne
    labs(
      title = paste0("Polynomial Degree ", poly_degree),
      x = "Green Party Vote Share (Centered)",
      y = "Climate Position"
    ) +
    # Fjern farvenøglen da vi har tekstforklaringer
    theme_minimal() +
    theme(legend.position = "none")
}

# Kode til at køre i R med dit faktiske datasæt:
# Antagelse: final_dataset er dit datasæt med de nødvendige kolonner

# Opret individuelle plots med forskellige polynomiegrader
p1 <- create_poly_rdd_plot(final_dataset, poly_degree = 1)  # Lineær
p2 <- create_poly_rdd_plot(final_dataset, poly_degree = 2)  # Kvadratisk
p3 <- create_poly_rdd_plot(final_dataset, poly_degree = 3)  # Kubisk
p4 <- create_poly_rdd_plot(final_dataset, poly_degree = 4)  # Kvartisk

# Kombiner plots i et 2x2 grid
polynomial_comparison <- (p1 + p2) / (p3 + p4) + 
  plot_annotation(
    title = "RDD Visualization: Comparison of Different Polynomial Specifications",
    subtitle = "Effect of Green Party Parliamentary Entry on Climate Position",
    theme = theme(plot.title = element_text(size = 14, face = "bold"),
                 plot.subtitle = element_text(size = 10))
  )

# Vis samlet plot
print(polynomial_comparison)

# Gem plottet til en fil med høj opløsning
ggsave("rdd_polynomial_comparison.png", polynomial_comparison, width = 10, height = 8, dpi = 300)

# Kode til at eksperimentere med forskellige båndbredder
# Dette vil vise, hvordan estimaterne varierer med forskellige båndbredder
create_bandwidth_plot <- function(data, poly_degree = 1, bandwidth) {
  # Filtrér data baseret på båndbredde
  filtered_data <- data[abs(data$centered_lagged_pervote_samlet) <= bandwidth, ]
  
  # Opret plottet
  ggplot(filtered_data, aes(x = centered_lagged_pervote_samlet, y = miljø_afhængig)) +
    geom_point(aes(color = factor_lagged_i_parlament), alpha = 0.3, size = 1) +
    geom_smooth(data = subset(filtered_data, centered_lagged_pervote_samlet < 0),
               method = "lm", 
               formula = paste0("y ~ poly(x, ", poly_degree, ", raw = TRUE)"), 
               color = "blue", se = TRUE) +
    geom_smooth(data = subset(filtered_data, centered_lagged_pervote_samlet >= 0),
               method = "lm", 
               formula = paste0("y ~ poly(x, ", poly_degree, ", raw = TRUE)"), 
               color = "red", se = TRUE) +
    geom_vline(xintercept = 0, linetype = "dashed") +
    labs(
      title = paste0("Bandwidth = ±", bandwidth, ", Polynomial Degree ", poly_degree),
      x = "Green Party Vote Share (Centered)",
      y = "Climate Position"
    ) +
    theme_minimal() +
    theme(legend.position = "none")
}

# Opret plots med forskellige båndbredder (for lineær model)
b1 <- create_bandwidth_plot(final_dataset, poly_degree = 1, bandwidth = 1)
b2 <- create_bandwidth_plot(final_dataset, poly_degree = 1, bandwidth = 2)
b3 <- create_bandwidth_plot(final_dataset, poly_degree = 1, bandwidth = 3)
b4 <- create_bandwidth_plot(final_dataset, poly_degree = 1, bandwidth = 5)

# Kombiner båndbredde-plots
bandwidth_comparison <- (b1 + b2) / (b3 + b4) + 
  plot_annotation(
    title = "RDD Visualization: Comparison of Different Bandwidths",
    subtitle = "Effect of Green Party Parliamentary Entry on Climate Position (Linear Model)",
    theme = theme(plot.title = element_text(size = 14, face = "bold"),
                 plot.subtitle = element_text(size = 10))
  )

# Vis båndbredde-sammenligningsplot
print(bandwidth_comparison)

# Gem båndbredde-plottet
ggsave("rdd_bandwidth_comparison.png", bandwidth_comparison, width = 10, height = 8, dpi = 300)

# 5.4 Faceted RDD plots by moderating variables --------------
# By RRP presence
rrp_facet_plot <- ggplot(final_dataset, aes(x = centered_lagged_pervote_samlet, y = miljø_afhængig)) +
  geom_point(alpha = 0.3) +
  geom_smooth(data = subset(final_dataset, centered_lagged_pervote_samlet < 0),
             method = "lm", formula = y ~ poly(x, 2, raw = TRUE), 
             color = "blue") +
  geom_smooth(data = subset(final_dataset, centered_lagged_pervote_samlet >= 0),
             method = "lm", formula = y ~ poly(x, 2, raw = TRUE), 
             color = "red") +
  geom_vline(xintercept = 0, linetype = "dashed") +
  facet_wrap(~ factor(rrp_i_p_lag1, labels = c("No RRP in Parliament", "RRP in Parliament"))) +
  labs(
    title = "Effect of Green Party Entry by Radical Right Presence",
    x = "Green Party Vote Share (Centered)",
    y = "Climate Position"
  ) +
  theme_minimal()

# By economic conditions
# Filtrer NA-værdierne ud og lav kun plot for good/poor economy
economy_facet_plot <- ggplot(
  # Filtrer NA-værdier fra factor_good_economy
  final_dataset %>% filter(!is.na(factor_good_economy)), 
  aes(x = centered_lagged_pervote_samlet, y = miljø_afhængig)) +
  geom_point(alpha = 0.3) +
  # Opdater subsetting til også at filtrere NA væk
  geom_smooth(data = subset(final_dataset, 
                          !is.na(factor_good_economy) & centered_lagged_pervote_samlet < 0),
             method = "lm", formula = y ~ poly(x, 2, raw = TRUE), 
             color = "blue") +
  geom_smooth(data = subset(final_dataset, 
                          !is.na(factor_good_economy) & centered_lagged_pervote_samlet >= 0),
             method = "lm", formula = y ~ poly(x, 2, raw = TRUE), 
             color = "red") +
  geom_vline(xintercept = 0, linetype = "dashed") +
  facet_wrap(~ factor_good_economy) +
  labs(
    title = "Effect of Green Party Entry by Economic Conditions",
    x = "Green Party Vote Share (Centered)",
    y = "Climate Position"
  ) +
  theme_minimal()

# Vis plottet
print(economy_facet_plot)

# By party ideology
ideology_facet_plot <- ggplot(final_dataset, aes(x = centered_lagged_pervote_samlet, y = miljø_afhængig)) +
  geom_point(alpha = 0.3) +
  geom_smooth(data = subset(final_dataset, centered_lagged_pervote_samlet < 0),
             method = "lm", formula = y ~ poly(x, 2, raw = TRUE), 
             color = "blue") +
  geom_smooth(data = subset(final_dataset, centered_lagged_pervote_samlet >= 0),
             method = "lm", formula = y ~ poly(x, 2, raw = TRUE), 
             color = "red") +
  geom_vline(xintercept = 0, linetype = "dashed") +
  facet_wrap(~ factor(left_party_lag1, labels = c("Right-wing Parties", "Left-wing Parties"))) +
  labs(
    title = "Effect of Green Party Entry by Party Ideology",
    x = "Green Party Vote Share (Centered)",
    y = "Climate Position"
  ) +
  theme_minimal()

# By party size
size_facet_plot <- ggplot(final_dataset, aes(x = centered_lagged_pervote_samlet, y = miljø_afhængig)) +
  geom_point(alpha = 0.3) +
  geom_smooth(data = subset(final_dataset, centered_lagged_pervote_samlet < 0),
             method = "lm", formula = y ~ poly(x, 2, raw = TRUE), 
             color = "blue") +
  geom_smooth(data = subset(final_dataset, centered_lagged_pervote_samlet >= 0),
             method = "lm", formula = y ~ poly(x, 2, raw = TRUE), 
             color = "red") +
  geom_vline(xintercept = 0, linetype = "dashed") +
  facet_wrap(~ factor(large_party_lag1, labels = c("Small Parties", "Large Parties"))) +
  labs(
    title = "Effect of Green Party Entry by Party Size",
    x = "Green Party Vote Share (Centered)",
    y = "Climate Position"
  ) +
  theme_minimal()

# 5.5 Placebo outcomes check --------------
# Identify placebo outcomes (variables that shouldn't be affected by threshold crossing)
placebo_vars <- c("rile_lowe", "parfam")

# Example for one placebo outcome
placebo_plot <- ggplot(final_dataset, aes(x = centered_lagged_pervote_samlet, y = rile_lowe)) +
  geom_point(alpha = 0.3) +
  geom_smooth(data = subset(final_dataset, centered_lagged_pervote_samlet < 0),
             method = "lm", formula = y ~ poly(x, 2, raw = TRUE), 
             color = "blue") +
  geom_smooth(data = subset(final_dataset, centered_lagged_pervote_samlet >= 0),
             method = "lm", formula = y ~ poly(x, 2, raw = TRUE), 
             color = "red") +
  geom_vline(xintercept = 0, linetype = "dashed") +
  labs(
    title = "Placebo Outcome Check: Party Ideology (RILE)",
    x = "Green Party Vote Share (Centered)",
    y = "Party Ideology (RILE Score)"
  ) +
  theme_minimal()


# 6. Additional Analyses --------------

# 6.1 Missing data analysis --------------
missing_data_overview <- final_dataset %>%
  summarise(across(everything(), ~ sum(is.na(.)) / length(.))) %>%
  pivot_longer(cols = everything(), 
               names_to = "variable", 
               values_to = "missing_proportion") %>%
  filter(missing_proportion > 0) %>%
  arrange(desc(missing_proportion))

# Find columns that have missing values
columns_with_missing <- missing_data_overview$variable

# If no columns have missing values, select a subset of important ones
if(length(columns_with_missing) == 0) {
  columns_with_missing <- c("miljø_afhængig", "pervote_samlet", 
                          "lagged_pervote_samlet", "rrp_i_p_lag1",
                          "GDP_per_capita_lag1", "Unemployment")
}

# Create a subset of the data with only these columns
missing_data_subset <- final_dataset %>%
  dplyr::select(all_of(columns_with_missing))

# Try alternative approach with gg_miss_upset
library(naniar)
tryCatch({
  # Attempt to create the upset plot
  missing_patterns_plot <- gg_miss_upset(missing_data_subset)
}, error = function(e) {
  # If error occurs, print message and use a simpler visualization
  cat("Error with gg_miss_upset:", e$message, "\n")
  cat("Using vis_miss instead\n")
  missing_patterns_plot <- vis_miss(missing_data_subset)
})

# 6.2 Zero inflation analysis by party characteristics --------------
zero_inflation_analysis <- final_dataset %>%
  dplyr::mutate(has_zero = miljø_afhængig == 0) %>%
  dplyr::group_by(parfam) %>%
  summarise(
    total = n(),
    n_zero = sum(has_zero, na.rm = TRUE),
    prop_zero = n_zero / total
  ) %>%
  arrange(desc(prop_zero))

zero_by_parfam_plot <- ggplot(zero_inflation_analysis, 
                             aes(x = reorder(parfam, prop_zero), y = prop_zero)) +
  geom_bar(stat = "identity", fill = "darkred") +
  coord_flip() +
  labs(
    title = "Proportion of Zero Climate Position Values by Party Family",
    x = "Party Family",
    y = "Proportion of Zero Values"
  ) +
  theme_minimal()

# 6.3 Temporal evolution of climate position by party family --------------
party_family_time <- final_dataset %>%
  dplyr::mutate(
    party_family = case_when(
      parfam == "10" ~ "Green",
      parfam == "20" ~ "Communist/Socialist",
      parfam == "30" ~ "Social Democratic",
      parfam == "40" ~ "Liberal",
      parfam == "50" ~ "Christian Democratic",
      parfam == "60" ~ "Conservative",
      parfam == "70" ~ "Nationalist",
      parfam == "80" ~ "Agrarian",
      parfam == "90" ~ "Ethnic/Regional",
      parfam == "95" ~ "Special issue parties",
      parfam == "98" ~ "Electoral alliance w/o leader",
      TRUE ~ "Other"
    )
  ) %>%
  dplyr::filter(!is.na(party_family)) %>%
  dplyr::group_by(Year, party_family) %>%
  summarise(
    mean_climate = mean(miljø_afhængig, na.rm = TRUE),
    .groups = "drop"
  )

family_time_plot <- ggplot(party_family_time, aes(x = Year, y = mean_climate, color = party_family)) +
  geom_line(size = 1) +
  geom_point(size = 2) +
  labs(
    title = "Climate Position Over Time by Party Family",
    x = "Year",
    y = "Mean Climate Position",
    color = "Party Family"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")

# 6.4 Climate position by country with time trends --------------
country_time_trends <- final_dataset %>%
  dplyr::group_by(countryname, Year) %>%
  summarise(
    mean_climate = mean(miljø_afhængig, na.rm = TRUE),
    .groups = "drop"
  )

country_trends_plot <- ggplot(country_time_trends, aes(x = Year, y = mean_climate, color = countryname)) +
  geom_line() +
  geom_point(size = 1) +
  labs(
    title = "Climate Position Time Trends by Country",
    x = "Year",
    y = "Mean Climate Position",
    color = "Country"
  ) +
  theme_minimal() +
  theme(legend.position = "right") +
  guides(color = guide_legend(ncol = 2))

# 6.5 Event marker timeline --------------
# Create a dataframe of major climate events
climate_events <- data.frame(
  year = c(1992, 1997, 2005, 2009, 2015, 2016),
  event = c("Rio Earth Summit", "Kyoto Protocol", "Kyoto Protocol Enforcement", 
           "Copenhagen Accord", "Paris Agreement", "Paris Agreement Enforcement")
)

# Forbedret version af climate_events_plot med bedre placering af event labels
climate_events_plot <- climate_time_plot +
  # Tilføj lodrette linjer for klimabegivenheder
  geom_vline(data = climate_events, aes(xintercept = year), 
            linetype = "dotted", color = "darkgreen") +
  # Tilføj labels med forbedret rotation og placering
  geom_text(data = climate_events, 
           aes(x = year, 
               y = 3.3,  # Placer teksten højere oppe for at give mere plads
               label = event), 
           angle = 90,  # Lodret rotation af teksten
           hjust = 1,   # Justér tekstens placering (1 = bunden af teksten er på y-koordinaten)
           size = 3,    # Mindre tekststørrelse
           color = "darkgreen") +
  # Udvid y-aksens grænse for at give plads til labels
  ylim(-1.5, 3.5) +  # Øg den øvre grænse for at give plads til tekstlabels
  # Forbedret tema med mere plads i top og bund
  theme(
    plot.margin = margin(t = 50, r = 10, b = 10, l = 10, unit = "pt"),
    axis.text.x = element_text(angle = 0, hjust = 0.5)  # Vandret x-akse tekst
  )

# 6.6 Distribution of climate position by parliamentary status --------------
parl_status_dist <- ggplot(final_dataset, aes(x = miljø_afhængig, fill = factor_lagged_i_parlament)) +
  geom_density(alpha = 0.5) +
  labs(
    title = "Distribution of Climate Position by Green Party Parliamentary Status",
    x = "Climate Position",
    y = "Density",
    fill = "Green Party Status"
  ) +
  theme_minimal()

# 6.7 Climate position before and after green party entry --------------
before_after_analysis <- final_dataset %>%
  # Focus on observations around the threshold
  filter(abs(centered_lagged_pervote_samlet) <= 2) %>%
  mutate(threshold_status = ifelse(centered_lagged_pervote_samlet >= 0, "Above", "Below"))

before_after_plot <- ggplot(before_after_analysis, aes(x = threshold_status, y = miljø_afhængig, fill = threshold_status)) +
  geom_boxplot() +
  labs(
    title = "Climate Position Below vs. Above Threshold",
    x = "Threshold Status",
    y = "Climate Position",
    fill = "Threshold Status"
  ) +
  theme_minimal()

# 6.8 Climate position vs. economic indicators --------------
economy_scatter <- ggplot(final_dataset, aes(x = `GDP_per_capita_lag1`, y = miljø_afhængig)) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "loess") +
  facet_wrap(~ factor_lagged_i_parlament) +
  labs(
    title = "Climate Position vs. GDP Growth by Parliamentary Status",
    x = "GDP_per_capita_lag1",
    y = "Climate Position"
  ) +
  theme_minimal()

# 6.9 Ridge plot of climate position by country --------------
ridge_plot <- ggplot(final_dataset, aes(x = miljø_afhængig, y = countryname, fill = countryname)) +
  geom_density_ridges(alpha = 0.6) +
  labs(
    title = "Distribution of Climate Position by Country",
    x = "Climate Position",
    y = "Country"
  ) +
  theme_minimal() +
  theme(legend.position = "none")


# 7. Saving Plots and Tables for EDA Section --------------

# Create a list of plots for the EDA section
eda_plots <- list(
  # Section 1: Descriptive Statistics
  country_coverage_plot = country_coverage_plot,
  time_coverage_plot = time_coverage_plot,
  
  # Section 2: Outcome Variable Analysis --------------
  climate_dist_plot = climate_dist_plot,
  climate_country_plot = climate_country_plot,
  climate_time_plot = climate_time_plot,
  components_plot = components_plot,
  zero_plot = zero_plot,
  family_climate_plot = family_climate_plot,
  
  # Section 3: Running Variable and Treatment Analysis --------------
  rv_dist_plot = rv_dist_plot,
  rdplotdensity = rdplotdensity,
  seat_allocation_plot = seat_allocation_plot,
  rile_balance = rile_balance,
  gdp_balance = gdp_balance,
  unemp_balance = unemp_balance,
  green_time_plot = green_time_plot,
  
  # Section 4: Moderating Variables Analysis --------------
  rrp_time_plot = rrp_time_plot,
  econ_indicators_plot = econ_indicators_plot,
  ideology_dist_plot = ideology_dist_plot,
  party_size_plot = party_size_plot,
  
  # Section 5: Preliminary Relationship Exploration --------------
  bivariate_plot = bivariate_plot,
  conditional_means_comparison = conditional_means_comparison,
  polynomial_comparison = polynomial_comparison,
  bandwidth_comparison = bandwidth_comparison,
  rrp_facet_plot = rrp_facet_plot,
  economy_facet_plot = economy_facet_plot,
  ideology_facet_plot = ideology_facet_plot,
  size_facet_plot = size_facet_plot,
  placebo_plot = placebo_plot,
  
  # Section 6: Additional Analyses --------------
  # Skip missing_patterns_plot if it wasn't created successfully
  # missing_patterns_plot = missing_patterns_plot,
  zero_by_parfam_plot = zero_by_parfam_plot,
  family_time_plot = family_time_plot,
  country_trends_plot = country_trends_plot,
  climate_events_plot = climate_events_plot,
  parl_status_dist = parl_status_dist,
  before_after_plot = before_after_plot,
  economy_scatter = economy_scatter,
  ridge_plot = ridge_plot
)

# Create a list of tables for the EDA section
eda_tables <- list(
  summary_wide = summary_wide,
  country_summary = country_summary,
  threshold_summary = threshold_summary,
  green_success_time = green_success_time,
  green_success_country = green_success_country,
  zero_prop = zero_prop,
  missing_data_overview = missing_data_overview,
  zero_inflation_analysis = zero_inflation_analysis
)

# Save plots to PDF
pdf("eda_plots.pdf", width = 12, height = 8)
for (i in seq_along(eda_plots)) {
  print(eda_plots[[i]])
}
dev.off()

# Save tables to CSV, with better error handling
for (i in seq_along(eda_tables)) {
  # Print what we're trying to save for debugging
  cat("Attempting to save table:", names(eda_tables)[i], "\n")
  
  # Use tryCatch to handle any errors that might occur
  tryCatch({
    # First check if the object is already a data frame
    if (is.data.frame(eda_tables[[i]])) {
      write.csv(eda_tables[[i]], 
               file = paste0("eda_table_", names(eda_tables)[i], ".csv"), 
               row.names = FALSE)
      cat("Successfully saved as data frame\n")
    } 
    # Special handling for correlation matrix
    else if (is.matrix(eda_tables[[i]])) {
      write.csv(as.data.frame(eda_tables[[i]]), 
               file = paste0("eda_table_", names(eda_tables)[i], ".csv"), 
               row.names = TRUE)
      cat("Successfully saved as matrix\n")
    }
    # Try to handle simple lists that could be converted to data frames
    else if (is.list(eda_tables[[i]]) && !is.data.frame(eda_tables[[i]])) {
      # Use capture.output to prevent error messages from printing
      capture.output({
        # Check if the list has equal length elements (could be made into a data frame)
        if (length(unique(sapply(eda_tables[[i]], length))) == 1) {
          df <- as.data.frame(eda_tables[[i]], stringsAsFactors = FALSE)
          write.csv(df, 
                   file = paste0("eda_table_", names(eda_tables)[i], ".csv"), 
                   row.names = FALSE)
          cat("Successfully converted list to data frame\n")
        } else {
          # For more complex lists, try to save as RDS instead
          saveRDS(eda_tables[[i]], 
                 file = paste0("eda_table_", names(eda_tables)[i], ".rds"))
          cat("Saved as RDS file instead of CSV\n")
        }
      }, type = "message")
    }
    # For any other type, save as RDS
    else {
      saveRDS(eda_tables[[i]], 
             file = paste0("eda_table_", names(eda_tables)[i], ".rds"))
      cat("Saved as RDS file (unknown type)\n")
    }
  }, error = function(e) {
    # If any error occurs, print message and continue to next table
    cat("ERROR saving table", names(eda_tables)[i], ":", e$message, "\n")
    # Try to save as RDS as a fallback
    tryCatch({
      saveRDS(eda_tables[[i]], 
             file = paste0("eda_table_", names(eda_tables)[i], ".rds"))
      cat("Saved as RDS file after error\n")
    }, error = function(e2) {
      cat("Could not save in any format:", e2$message, "\n")
    })
  })
}

# Create directory for EDA figures if it doesn't exist
eda_dir <- "C:/Users/Tobias D/OneDrive - Syddansk Universitet/Dokumenter/Speciale/Figurer-EDA"
if (!dir.exists(eda_dir)) {
  dir.create(eda_dir, recursive = TRUE)
}

# Set working directory to the new folder
old_dir <- getwd()  # Save current directory to restore later
setwd(eda_dir)


# 8. Create Individual Files for Each EDA Section --------------

# Section 1: Descriptive Statistics --------------
pdf("eda_section1_descriptive.pdf", width = 12, height = 8)
print(country_coverage_plot)
print(time_coverage_plot)
dev.off()

# Section 2: Outcome Variable Analysis --------------
pdf("eda_section2_outcome.pdf", width = 12, height = 8)
print(climate_dist_plot)
print(climate_country_plot)
print(climate_time_plot)
print(components_plot)
print(zero_plot)
print(family_climate_plot)
dev.off()

# Create a simple histogram as a substitute for the density test
density_test_plot_substitute <- ggplot(final_dataset, aes(x = centered_lagged_pervote_samlet)) +
  geom_histogram(binwidth = 0.25, fill = "steelblue", color = "darkblue", alpha = 0.7) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red") +
  labs(
    title = "Distribution Around Threshold (Simple Histogram)",
    subtitle = "Note: rddensity test failed - showing basic histogram instead",
    x = "Centered Vote Share",
    y = "Count"
  ) +
  theme_minimal()

# Section 3: Running Variable and Treatment Analysis --------------
pdf("eda_section3_running_var.pdf", width = 12, height = 8)
print(rv_dist_plot)
print(rdplotdensity)
print(seat_allocation_plot)
print(rile_balance)
print(gdp_balance)
print(unemp_balance)
print(green_time_plot)
dev.off()

# Section 4: Moderating Variables Analysis --------------
pdf("eda_section4_moderating.pdf", width = 12, height = 8)
print(rrp_time_plot)
print(econ_indicators_plot)
print(ideology_dist_plot)
print(party_size_plot)
dev.off()

# Section 5: Preliminary Relationship Exploration --------------
pdf("eda_section5_relationships.pdf", width = 12, height = 8)
print(bivariate_plot)
print(conditional_means_comparison)
print(polynomial_comparison)
print(bandwidth_comparison)
print(rrp_facet_plot)
print(economy_facet_plot)
print(ideology_facet_plot)
print(size_facet_plot)
print(placebo_plot)
dev.off()

# Create substitute for missing patterns plot if needed
if (!exists("missing_patterns_plot")) {
  # Create simple missing data visualization as substitute
  missing_data_viz <- vis_miss(final_dataset %>% 
                              select(miljø_afhængig, pervote_samlet, 
                                    lagged_pervote_samlet, rrp_i_p_lag1, 
                                    `GDP_per_capita_lag1`, Unemployment))
  missing_patterns_plot <- missing_data_viz
}

# Section 6: Additional Analyses --------------
pdf("eda_section6_additional.pdf", width = 12, height = 8)
tryCatch({
  print(missing_patterns_plot)
}, error = function(e) {
  # If there's an error, print a message plot
  grid::grid.text("Missing patterns plot unavailable", 0.5, 0.5)
})
print(zero_by_parfam_plot)
print(family_time_plot)
print(country_trends_plot)
print(climate_events_plot)
print(parl_status_dist)
print(before_after_plot)
print(economy_scatter)
print(ridge_plot)
dev.off()

# Save tables to CSV with better error handling
for (i in seq_along(eda_tables)) {
  # Use tryCatch to handle any errors that might occur
  tryCatch({
    # First check if the object is already a data frame
    if (is.data.frame(eda_tables[[i]])) {
      write.csv(eda_tables[[i]], 
               file = paste0("eda_table_", names(eda_tables)[i], ".csv"), 
               row.names = FALSE)
    } 
    # Special handling for correlation matrix
    else if (is.matrix(eda_tables[[i]])) {
      write.csv(as.data.frame(eda_tables[[i]]), 
               file = paste0("eda_table_", names(eda_tables)[i], ".csv"), 
               row.names = TRUE)
    }
    # Try to handle simple lists that could be converted to data frames
    else if (is.list(eda_tables[[i]]) && !is.data.frame(eda_tables[[i]])) {
      # Use capture.output to prevent error messages from printing
      capture.output({
        # Check if the list has equal length elements (could be made into a data frame)
        if (length(unique(sapply(eda_tables[[i]], length))) == 1) {
          df <- as.data.frame(eda_tables[[i]], stringsAsFactors = FALSE)
          write.csv(df, 
                   file = paste0("eda_table_", names(eda_tables)[i], ".csv"), 
                   row.names = FALSE)
        } else {
          # For more complex lists, try to save as RDS instead
          saveRDS(eda_tables[[i]], 
                 file = paste0("eda_table_", names(eda_tables)[i], ".rds"))
        }
      }, type = "message")
    }
    # For any other type, save as RDS
    else {
      saveRDS(eda_tables[[i]], 
             file = paste0("eda_table_", names(eda_tables)[i], ".rds"))
    }
  }, error = function(e) {
    # If any error occurs, try to save as RDS as a fallback
    tryCatch({
      saveRDS(eda_tables[[i]], 
             file = paste0("eda_table_", names(eda_tables)[i], ".rds"))
    }, error = function(e2) {
      # If that fails too, write the error to a text file
      writeLines(paste("Error saving table", names(eda_tables)[i], ":", e2$message), 
                con = paste0("eda_table_", names(eda_tables)[i], "_error.txt"))
    })
  })
}

# Save all individual plots as PNG files for easier viewing
for (plot_name in names(eda_plots)) {
  if (exists(plot_name)) {
    tryCatch({
      plot_obj <- get(plot_name)
      ggsave(
        filename = paste0(plot_name, ".png"),
        plot = plot_obj,
        width = 10,
        height = 6,
        dpi = 300
      )
    }, error = function(e) {
      # If there's an error, write it to a log file
      writeLines(paste("Error saving plot", plot_name, ":", e$message), 
                con = paste0(plot_name, "_error.txt"))
    })
  }
}

# Create a single combined PDF with all plots
pdf("all_eda_plots.pdf", width = 12, height = 8)
for (plot_name in names(eda_plots)) {
  if (exists(plot_name)) {
    tryCatch({
      plot_obj <- get(plot_name)
      print(plot_obj)
    }, error = function(e) {
      # If there's an error, print a message in the PDF
      grid::grid.text(paste("Error with plot:", plot_name), 0.5, 0.5)
    })
  }
}
dev.off()

# Restore original working directory
setwd(old_dir)

# Print confirmation message
cat("All EDA figures and tables have been saved to:", eda_dir, "\n")
